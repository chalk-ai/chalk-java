// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chalk/pubsub/v1/pod_status.proto

// Protobuf Java Version: 3.25.1
package ai.chalk.protos.chalk.pubsub.v1;

/**
 * <pre>
 * PodStatusPubSub captures the state of a kubernetes pod.
 * </pre>
 *
 * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub}
 */
public final class PodStatusPubSub extends
    com.google.protobuf.GeneratedMessageV3 implements
    // @@protoc_insertion_point(message_implements:chalk.pubsub.v1.PodStatusPubSub)
    PodStatusPubSubOrBuilder {
private static final long serialVersionUID = 0L;
  // Use PodStatusPubSub.newBuilder() to construct.
  private PodStatusPubSub(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }
  private PodStatusPubSub() {
    team_ = "";
    app_ = "";
    component_ = "";
    datadogService_ = "";
    datadogVersion_ = "";
    podTemplateHash_ = "";
    cluster_ = "";
    uid_ = "";
    name_ = "";
    namespace_ = "";
  }

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(
      UnusedPrivateParameter unused) {
    return new PodStatusPubSub();
  }

  public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
    return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_descriptor;
  }

  @SuppressWarnings({"rawtypes"})
  @java.lang.Override
  protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
      int number) {
    switch (number) {
      case 21:
        return internalGetLabels();
      case 22:
        return internalGetAnnotations();
      default:
        throw new RuntimeException(
            "Invalid map field number: " + number);
    }
  }
  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Builder.class);
  }

  public interface VolumeOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chalk.pubsub.v1.PodStatusPubSub.Volume)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * name of the volume.
     * Must be a DNS_LABEL and unique within the pod.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     * </pre>
     *
     * <code>string name = 1 [json_name = "name"];</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * name of the volume.
     * Must be a DNS_LABEL and unique within the pod.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     * </pre>
     *
     * <code>string name = 1 [json_name = "name"];</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();
  }
  /**
   * <pre>
   * Volume represents a named volume in a pod that may be accessed by any container in the pod.
   * </pre>
   *
   * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.Volume}
   */
  public static final class Volume extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chalk.pubsub.v1.PodStatusPubSub.Volume)
      VolumeOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Volume.newBuilder() to construct.
    private Volume(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Volume() {
      name_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Volume();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_Volume_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_Volume_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume.Builder.class);
    }

    public static final int NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * name of the volume.
     * Must be a DNS_LABEL and unique within the pod.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     * </pre>
     *
     * <code>string name = 1 [json_name = "name"];</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * name of the volume.
     * Must be a DNS_LABEL and unique within the pod.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     * </pre>
     *
     * <code>string name = 1 [json_name = "name"];</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(name_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(name_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume)) {
        return super.equals(obj);
      }
      ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume other = (ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume) obj;

      if (!getName()
          .equals(other.getName())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Volume represents a named volume in a pod that may be accessed by any container in the pod.
     * </pre>
     *
     * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.Volume}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chalk.pubsub.v1.PodStatusPubSub.Volume)
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.VolumeOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_Volume_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_Volume_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume.Builder.class);
      }

      // Construct using ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        name_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_Volume_descriptor;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume getDefaultInstanceForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume.getDefaultInstance();
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume build() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume buildPartial() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume result = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.name_ = name_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume) {
          return mergeFrom((ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume other) {
        if (other == ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume.getDefaultInstance()) return this;
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                name_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * name of the volume.
       * Must be a DNS_LABEL and unique within the pod.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * </pre>
       *
       * <code>string name = 1 [json_name = "name"];</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * name of the volume.
       * Must be a DNS_LABEL and unique within the pod.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * </pre>
       *
       * <code>string name = 1 [json_name = "name"];</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * name of the volume.
       * Must be a DNS_LABEL and unique within the pod.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * </pre>
       *
       * <code>string name = 1 [json_name = "name"];</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * name of the volume.
       * Must be a DNS_LABEL and unique within the pod.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * </pre>
       *
       * <code>string name = 1 [json_name = "name"];</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * name of the volume.
       * Must be a DNS_LABEL and unique within the pod.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * </pre>
       *
       * <code>string name = 1 [json_name = "name"];</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chalk.pubsub.v1.PodStatusPubSub.Volume)
    }

    // @@protoc_insertion_point(class_scope:chalk.pubsub.v1.PodStatusPubSub.Volume)
    private static final ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume();
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Volume>
        PARSER = new com.google.protobuf.AbstractParser<Volume>() {
      @java.lang.Override
      public Volume parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Volume> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Volume> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ClaimSourceOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chalk.pubsub.v1.PodStatusPubSub.ClaimSource)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * ResourceClaimName is the name of a ResourceClaim object in the same
     * namespace as this pod.
     * </pre>
     *
     * <code>optional string resource_claim_name = 1 [json_name = "resourceClaimName"];</code>
     * @return Whether the resourceClaimName field is set.
     */
    boolean hasResourceClaimName();
    /**
     * <pre>
     * ResourceClaimName is the name of a ResourceClaim object in the same
     * namespace as this pod.
     * </pre>
     *
     * <code>optional string resource_claim_name = 1 [json_name = "resourceClaimName"];</code>
     * @return The resourceClaimName.
     */
    java.lang.String getResourceClaimName();
    /**
     * <pre>
     * ResourceClaimName is the name of a ResourceClaim object in the same
     * namespace as this pod.
     * </pre>
     *
     * <code>optional string resource_claim_name = 1 [json_name = "resourceClaimName"];</code>
     * @return The bytes for resourceClaimName.
     */
    com.google.protobuf.ByteString
        getResourceClaimNameBytes();

    /**
     * <pre>
     * ResourceClaimTemplateName is the name of a ResourceClaimTemplate
     * object in the same namespace as this pod.
     *
     * The template will be used to create a new ResourceClaim, which will
     * be bound to this pod. When this pod is deleted, the ResourceClaim
     * will also be deleted. The pod name and resource name, along with a
     * generated component, will be used to form a unique name for the
     * ResourceClaim, which will be recorded in pod.status.resourceClaimStatuses.
     *
     * This field is immutable and no changes will be made to the
     * corresponding ResourceClaim by the control plane after creating the
     * ResourceClaim.
     * </pre>
     *
     * <code>optional string resource_claim_template_name = 2 [json_name = "resourceClaimTemplateName"];</code>
     * @return Whether the resourceClaimTemplateName field is set.
     */
    boolean hasResourceClaimTemplateName();
    /**
     * <pre>
     * ResourceClaimTemplateName is the name of a ResourceClaimTemplate
     * object in the same namespace as this pod.
     *
     * The template will be used to create a new ResourceClaim, which will
     * be bound to this pod. When this pod is deleted, the ResourceClaim
     * will also be deleted. The pod name and resource name, along with a
     * generated component, will be used to form a unique name for the
     * ResourceClaim, which will be recorded in pod.status.resourceClaimStatuses.
     *
     * This field is immutable and no changes will be made to the
     * corresponding ResourceClaim by the control plane after creating the
     * ResourceClaim.
     * </pre>
     *
     * <code>optional string resource_claim_template_name = 2 [json_name = "resourceClaimTemplateName"];</code>
     * @return The resourceClaimTemplateName.
     */
    java.lang.String getResourceClaimTemplateName();
    /**
     * <pre>
     * ResourceClaimTemplateName is the name of a ResourceClaimTemplate
     * object in the same namespace as this pod.
     *
     * The template will be used to create a new ResourceClaim, which will
     * be bound to this pod. When this pod is deleted, the ResourceClaim
     * will also be deleted. The pod name and resource name, along with a
     * generated component, will be used to form a unique name for the
     * ResourceClaim, which will be recorded in pod.status.resourceClaimStatuses.
     *
     * This field is immutable and no changes will be made to the
     * corresponding ResourceClaim by the control plane after creating the
     * ResourceClaim.
     * </pre>
     *
     * <code>optional string resource_claim_template_name = 2 [json_name = "resourceClaimTemplateName"];</code>
     * @return The bytes for resourceClaimTemplateName.
     */
    com.google.protobuf.ByteString
        getResourceClaimTemplateNameBytes();
  }
  /**
   * <pre>
   * ClaimSource describes a reference to a ResourceClaim.
   *
   * Exactly one of these fields should be set.  Consumers of this type must
   * treat an empty object as if it has an unknown value.
   * </pre>
   *
   * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.ClaimSource}
   */
  public static final class ClaimSource extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chalk.pubsub.v1.PodStatusPubSub.ClaimSource)
      ClaimSourceOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ClaimSource.newBuilder() to construct.
    private ClaimSource(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ClaimSource() {
      resourceClaimName_ = "";
      resourceClaimTemplateName_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ClaimSource();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ClaimSource_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ClaimSource_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource.Builder.class);
    }

    private int bitField0_;
    public static final int RESOURCE_CLAIM_NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object resourceClaimName_ = "";
    /**
     * <pre>
     * ResourceClaimName is the name of a ResourceClaim object in the same
     * namespace as this pod.
     * </pre>
     *
     * <code>optional string resource_claim_name = 1 [json_name = "resourceClaimName"];</code>
     * @return Whether the resourceClaimName field is set.
     */
    @java.lang.Override
    public boolean hasResourceClaimName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * ResourceClaimName is the name of a ResourceClaim object in the same
     * namespace as this pod.
     * </pre>
     *
     * <code>optional string resource_claim_name = 1 [json_name = "resourceClaimName"];</code>
     * @return The resourceClaimName.
     */
    @java.lang.Override
    public java.lang.String getResourceClaimName() {
      java.lang.Object ref = resourceClaimName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        resourceClaimName_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * ResourceClaimName is the name of a ResourceClaim object in the same
     * namespace as this pod.
     * </pre>
     *
     * <code>optional string resource_claim_name = 1 [json_name = "resourceClaimName"];</code>
     * @return The bytes for resourceClaimName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getResourceClaimNameBytes() {
      java.lang.Object ref = resourceClaimName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        resourceClaimName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int RESOURCE_CLAIM_TEMPLATE_NAME_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object resourceClaimTemplateName_ = "";
    /**
     * <pre>
     * ResourceClaimTemplateName is the name of a ResourceClaimTemplate
     * object in the same namespace as this pod.
     *
     * The template will be used to create a new ResourceClaim, which will
     * be bound to this pod. When this pod is deleted, the ResourceClaim
     * will also be deleted. The pod name and resource name, along with a
     * generated component, will be used to form a unique name for the
     * ResourceClaim, which will be recorded in pod.status.resourceClaimStatuses.
     *
     * This field is immutable and no changes will be made to the
     * corresponding ResourceClaim by the control plane after creating the
     * ResourceClaim.
     * </pre>
     *
     * <code>optional string resource_claim_template_name = 2 [json_name = "resourceClaimTemplateName"];</code>
     * @return Whether the resourceClaimTemplateName field is set.
     */
    @java.lang.Override
    public boolean hasResourceClaimTemplateName() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * ResourceClaimTemplateName is the name of a ResourceClaimTemplate
     * object in the same namespace as this pod.
     *
     * The template will be used to create a new ResourceClaim, which will
     * be bound to this pod. When this pod is deleted, the ResourceClaim
     * will also be deleted. The pod name and resource name, along with a
     * generated component, will be used to form a unique name for the
     * ResourceClaim, which will be recorded in pod.status.resourceClaimStatuses.
     *
     * This field is immutable and no changes will be made to the
     * corresponding ResourceClaim by the control plane after creating the
     * ResourceClaim.
     * </pre>
     *
     * <code>optional string resource_claim_template_name = 2 [json_name = "resourceClaimTemplateName"];</code>
     * @return The resourceClaimTemplateName.
     */
    @java.lang.Override
    public java.lang.String getResourceClaimTemplateName() {
      java.lang.Object ref = resourceClaimTemplateName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        resourceClaimTemplateName_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * ResourceClaimTemplateName is the name of a ResourceClaimTemplate
     * object in the same namespace as this pod.
     *
     * The template will be used to create a new ResourceClaim, which will
     * be bound to this pod. When this pod is deleted, the ResourceClaim
     * will also be deleted. The pod name and resource name, along with a
     * generated component, will be used to form a unique name for the
     * ResourceClaim, which will be recorded in pod.status.resourceClaimStatuses.
     *
     * This field is immutable and no changes will be made to the
     * corresponding ResourceClaim by the control plane after creating the
     * ResourceClaim.
     * </pre>
     *
     * <code>optional string resource_claim_template_name = 2 [json_name = "resourceClaimTemplateName"];</code>
     * @return The bytes for resourceClaimTemplateName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getResourceClaimTemplateNameBytes() {
      java.lang.Object ref = resourceClaimTemplateName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        resourceClaimTemplateName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, resourceClaimName_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, resourceClaimTemplateName_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, resourceClaimName_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, resourceClaimTemplateName_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource)) {
        return super.equals(obj);
      }
      ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource other = (ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource) obj;

      if (hasResourceClaimName() != other.hasResourceClaimName()) return false;
      if (hasResourceClaimName()) {
        if (!getResourceClaimName()
            .equals(other.getResourceClaimName())) return false;
      }
      if (hasResourceClaimTemplateName() != other.hasResourceClaimTemplateName()) return false;
      if (hasResourceClaimTemplateName()) {
        if (!getResourceClaimTemplateName()
            .equals(other.getResourceClaimTemplateName())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasResourceClaimName()) {
        hash = (37 * hash) + RESOURCE_CLAIM_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getResourceClaimName().hashCode();
      }
      if (hasResourceClaimTemplateName()) {
        hash = (37 * hash) + RESOURCE_CLAIM_TEMPLATE_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getResourceClaimTemplateName().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ClaimSource describes a reference to a ResourceClaim.
     *
     * Exactly one of these fields should be set.  Consumers of this type must
     * treat an empty object as if it has an unknown value.
     * </pre>
     *
     * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.ClaimSource}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chalk.pubsub.v1.PodStatusPubSub.ClaimSource)
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSourceOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ClaimSource_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ClaimSource_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource.Builder.class);
      }

      // Construct using ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        resourceClaimName_ = "";
        resourceClaimTemplateName_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ClaimSource_descriptor;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource getDefaultInstanceForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource.getDefaultInstance();
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource build() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource buildPartial() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource result = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.resourceClaimName_ = resourceClaimName_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.resourceClaimTemplateName_ = resourceClaimTemplateName_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource) {
          return mergeFrom((ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource other) {
        if (other == ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource.getDefaultInstance()) return this;
        if (other.hasResourceClaimName()) {
          resourceClaimName_ = other.resourceClaimName_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasResourceClaimTemplateName()) {
          resourceClaimTemplateName_ = other.resourceClaimTemplateName_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                resourceClaimName_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                resourceClaimTemplateName_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object resourceClaimName_ = "";
      /**
       * <pre>
       * ResourceClaimName is the name of a ResourceClaim object in the same
       * namespace as this pod.
       * </pre>
       *
       * <code>optional string resource_claim_name = 1 [json_name = "resourceClaimName"];</code>
       * @return Whether the resourceClaimName field is set.
       */
      public boolean hasResourceClaimName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * ResourceClaimName is the name of a ResourceClaim object in the same
       * namespace as this pod.
       * </pre>
       *
       * <code>optional string resource_claim_name = 1 [json_name = "resourceClaimName"];</code>
       * @return The resourceClaimName.
       */
      public java.lang.String getResourceClaimName() {
        java.lang.Object ref = resourceClaimName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          resourceClaimName_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * ResourceClaimName is the name of a ResourceClaim object in the same
       * namespace as this pod.
       * </pre>
       *
       * <code>optional string resource_claim_name = 1 [json_name = "resourceClaimName"];</code>
       * @return The bytes for resourceClaimName.
       */
      public com.google.protobuf.ByteString
          getResourceClaimNameBytes() {
        java.lang.Object ref = resourceClaimName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          resourceClaimName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * ResourceClaimName is the name of a ResourceClaim object in the same
       * namespace as this pod.
       * </pre>
       *
       * <code>optional string resource_claim_name = 1 [json_name = "resourceClaimName"];</code>
       * @param value The resourceClaimName to set.
       * @return This builder for chaining.
       */
      public Builder setResourceClaimName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        resourceClaimName_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ResourceClaimName is the name of a ResourceClaim object in the same
       * namespace as this pod.
       * </pre>
       *
       * <code>optional string resource_claim_name = 1 [json_name = "resourceClaimName"];</code>
       * @return This builder for chaining.
       */
      public Builder clearResourceClaimName() {
        resourceClaimName_ = getDefaultInstance().getResourceClaimName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ResourceClaimName is the name of a ResourceClaim object in the same
       * namespace as this pod.
       * </pre>
       *
       * <code>optional string resource_claim_name = 1 [json_name = "resourceClaimName"];</code>
       * @param value The bytes for resourceClaimName to set.
       * @return This builder for chaining.
       */
      public Builder setResourceClaimNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        resourceClaimName_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object resourceClaimTemplateName_ = "";
      /**
       * <pre>
       * ResourceClaimTemplateName is the name of a ResourceClaimTemplate
       * object in the same namespace as this pod.
       *
       * The template will be used to create a new ResourceClaim, which will
       * be bound to this pod. When this pod is deleted, the ResourceClaim
       * will also be deleted. The pod name and resource name, along with a
       * generated component, will be used to form a unique name for the
       * ResourceClaim, which will be recorded in pod.status.resourceClaimStatuses.
       *
       * This field is immutable and no changes will be made to the
       * corresponding ResourceClaim by the control plane after creating the
       * ResourceClaim.
       * </pre>
       *
       * <code>optional string resource_claim_template_name = 2 [json_name = "resourceClaimTemplateName"];</code>
       * @return Whether the resourceClaimTemplateName field is set.
       */
      public boolean hasResourceClaimTemplateName() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * ResourceClaimTemplateName is the name of a ResourceClaimTemplate
       * object in the same namespace as this pod.
       *
       * The template will be used to create a new ResourceClaim, which will
       * be bound to this pod. When this pod is deleted, the ResourceClaim
       * will also be deleted. The pod name and resource name, along with a
       * generated component, will be used to form a unique name for the
       * ResourceClaim, which will be recorded in pod.status.resourceClaimStatuses.
       *
       * This field is immutable and no changes will be made to the
       * corresponding ResourceClaim by the control plane after creating the
       * ResourceClaim.
       * </pre>
       *
       * <code>optional string resource_claim_template_name = 2 [json_name = "resourceClaimTemplateName"];</code>
       * @return The resourceClaimTemplateName.
       */
      public java.lang.String getResourceClaimTemplateName() {
        java.lang.Object ref = resourceClaimTemplateName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          resourceClaimTemplateName_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * ResourceClaimTemplateName is the name of a ResourceClaimTemplate
       * object in the same namespace as this pod.
       *
       * The template will be used to create a new ResourceClaim, which will
       * be bound to this pod. When this pod is deleted, the ResourceClaim
       * will also be deleted. The pod name and resource name, along with a
       * generated component, will be used to form a unique name for the
       * ResourceClaim, which will be recorded in pod.status.resourceClaimStatuses.
       *
       * This field is immutable and no changes will be made to the
       * corresponding ResourceClaim by the control plane after creating the
       * ResourceClaim.
       * </pre>
       *
       * <code>optional string resource_claim_template_name = 2 [json_name = "resourceClaimTemplateName"];</code>
       * @return The bytes for resourceClaimTemplateName.
       */
      public com.google.protobuf.ByteString
          getResourceClaimTemplateNameBytes() {
        java.lang.Object ref = resourceClaimTemplateName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          resourceClaimTemplateName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * ResourceClaimTemplateName is the name of a ResourceClaimTemplate
       * object in the same namespace as this pod.
       *
       * The template will be used to create a new ResourceClaim, which will
       * be bound to this pod. When this pod is deleted, the ResourceClaim
       * will also be deleted. The pod name and resource name, along with a
       * generated component, will be used to form a unique name for the
       * ResourceClaim, which will be recorded in pod.status.resourceClaimStatuses.
       *
       * This field is immutable and no changes will be made to the
       * corresponding ResourceClaim by the control plane after creating the
       * ResourceClaim.
       * </pre>
       *
       * <code>optional string resource_claim_template_name = 2 [json_name = "resourceClaimTemplateName"];</code>
       * @param value The resourceClaimTemplateName to set.
       * @return This builder for chaining.
       */
      public Builder setResourceClaimTemplateName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        resourceClaimTemplateName_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ResourceClaimTemplateName is the name of a ResourceClaimTemplate
       * object in the same namespace as this pod.
       *
       * The template will be used to create a new ResourceClaim, which will
       * be bound to this pod. When this pod is deleted, the ResourceClaim
       * will also be deleted. The pod name and resource name, along with a
       * generated component, will be used to form a unique name for the
       * ResourceClaim, which will be recorded in pod.status.resourceClaimStatuses.
       *
       * This field is immutable and no changes will be made to the
       * corresponding ResourceClaim by the control plane after creating the
       * ResourceClaim.
       * </pre>
       *
       * <code>optional string resource_claim_template_name = 2 [json_name = "resourceClaimTemplateName"];</code>
       * @return This builder for chaining.
       */
      public Builder clearResourceClaimTemplateName() {
        resourceClaimTemplateName_ = getDefaultInstance().getResourceClaimTemplateName();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ResourceClaimTemplateName is the name of a ResourceClaimTemplate
       * object in the same namespace as this pod.
       *
       * The template will be used to create a new ResourceClaim, which will
       * be bound to this pod. When this pod is deleted, the ResourceClaim
       * will also be deleted. The pod name and resource name, along with a
       * generated component, will be used to form a unique name for the
       * ResourceClaim, which will be recorded in pod.status.resourceClaimStatuses.
       *
       * This field is immutable and no changes will be made to the
       * corresponding ResourceClaim by the control plane after creating the
       * ResourceClaim.
       * </pre>
       *
       * <code>optional string resource_claim_template_name = 2 [json_name = "resourceClaimTemplateName"];</code>
       * @param value The bytes for resourceClaimTemplateName to set.
       * @return This builder for chaining.
       */
      public Builder setResourceClaimTemplateNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        resourceClaimTemplateName_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chalk.pubsub.v1.PodStatusPubSub.ClaimSource)
    }

    // @@protoc_insertion_point(class_scope:chalk.pubsub.v1.PodStatusPubSub.ClaimSource)
    private static final ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource();
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ClaimSource>
        PARSER = new com.google.protobuf.AbstractParser<ClaimSource>() {
      @java.lang.Override
      public ClaimSource parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ClaimSource> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ClaimSource> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PodResourceClaimOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Name uniquely identifies this resource claim inside the pod.
     * This must be a DNS_LABEL.
     * </pre>
     *
     * <code>string name = 1 [json_name = "name"];</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * Name uniquely identifies this resource claim inside the pod.
     * This must be a DNS_LABEL.
     * </pre>
     *
     * <code>string name = 1 [json_name = "name"];</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * Source describes where to find the ResourceClaim.
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ClaimSource source = 2 [json_name = "source"];</code>
     * @return Whether the source field is set.
     */
    boolean hasSource();
    /**
     * <pre>
     * Source describes where to find the ResourceClaim.
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ClaimSource source = 2 [json_name = "source"];</code>
     * @return The source.
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource getSource();
    /**
     * <pre>
     * Source describes where to find the ResourceClaim.
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ClaimSource source = 2 [json_name = "source"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSourceOrBuilder getSourceOrBuilder();
  }
  /**
   * <pre>
   * PodResourceClaim references exactly one ResourceClaim through a ClaimSource.
   * It adds a name to it that uniquely identifies the ResourceClaim inside the Pod.
   * Containers that need access to the ResourceClaim reference it with this name.
   * </pre>
   *
   * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim}
   */
  public static final class PodResourceClaim extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim)
      PodResourceClaimOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use PodResourceClaim.newBuilder() to construct.
    private PodResourceClaim(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private PodResourceClaim() {
      name_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new PodResourceClaim();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_PodResourceClaim_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_PodResourceClaim_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * Name uniquely identifies this resource claim inside the pod.
     * This must be a DNS_LABEL.
     * </pre>
     *
     * <code>string name = 1 [json_name = "name"];</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Name uniquely identifies this resource claim inside the pod.
     * This must be a DNS_LABEL.
     * </pre>
     *
     * <code>string name = 1 [json_name = "name"];</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SOURCE_FIELD_NUMBER = 2;
    private ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource source_;
    /**
     * <pre>
     * Source describes where to find the ResourceClaim.
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ClaimSource source = 2 [json_name = "source"];</code>
     * @return Whether the source field is set.
     */
    @java.lang.Override
    public boolean hasSource() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Source describes where to find the ResourceClaim.
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ClaimSource source = 2 [json_name = "source"];</code>
     * @return The source.
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource getSource() {
      return source_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource.getDefaultInstance() : source_;
    }
    /**
     * <pre>
     * Source describes where to find the ResourceClaim.
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ClaimSource source = 2 [json_name = "source"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSourceOrBuilder getSourceOrBuilder() {
      return source_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource.getDefaultInstance() : source_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(name_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(2, getSource());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(name_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSource());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim)) {
        return super.equals(obj);
      }
      ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim other = (ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim) obj;

      if (!getName()
          .equals(other.getName())) return false;
      if (hasSource() != other.hasSource()) return false;
      if (hasSource()) {
        if (!getSource()
            .equals(other.getSource())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      if (hasSource()) {
        hash = (37 * hash) + SOURCE_FIELD_NUMBER;
        hash = (53 * hash) + getSource().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * PodResourceClaim references exactly one ResourceClaim through a ClaimSource.
     * It adds a name to it that uniquely identifies the ResourceClaim inside the Pod.
     * Containers that need access to the ResourceClaim reference it with this name.
     * </pre>
     *
     * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim)
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaimOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_PodResourceClaim_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_PodResourceClaim_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim.Builder.class);
      }

      // Construct using ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getSourceFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        name_ = "";
        source_ = null;
        if (sourceBuilder_ != null) {
          sourceBuilder_.dispose();
          sourceBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_PodResourceClaim_descriptor;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim getDefaultInstanceForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim.getDefaultInstance();
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim build() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim buildPartial() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim result = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.name_ = name_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.source_ = sourceBuilder_ == null
              ? source_
              : sourceBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim) {
          return mergeFrom((ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim other) {
        if (other == ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim.getDefaultInstance()) return this;
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasSource()) {
          mergeSource(other.getSource());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                name_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getSourceFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * Name uniquely identifies this resource claim inside the pod.
       * This must be a DNS_LABEL.
       * </pre>
       *
       * <code>string name = 1 [json_name = "name"];</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Name uniquely identifies this resource claim inside the pod.
       * This must be a DNS_LABEL.
       * </pre>
       *
       * <code>string name = 1 [json_name = "name"];</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Name uniquely identifies this resource claim inside the pod.
       * This must be a DNS_LABEL.
       * </pre>
       *
       * <code>string name = 1 [json_name = "name"];</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name uniquely identifies this resource claim inside the pod.
       * This must be a DNS_LABEL.
       * </pre>
       *
       * <code>string name = 1 [json_name = "name"];</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name uniquely identifies this resource claim inside the pod.
       * This must be a DNS_LABEL.
       * </pre>
       *
       * <code>string name = 1 [json_name = "name"];</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource source_;
      private com.google.protobuf.SingleFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSourceOrBuilder> sourceBuilder_;
      /**
       * <pre>
       * Source describes where to find the ResourceClaim.
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ClaimSource source = 2 [json_name = "source"];</code>
       * @return Whether the source field is set.
       */
      public boolean hasSource() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Source describes where to find the ResourceClaim.
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ClaimSource source = 2 [json_name = "source"];</code>
       * @return The source.
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource getSource() {
        if (sourceBuilder_ == null) {
          return source_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource.getDefaultInstance() : source_;
        } else {
          return sourceBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Source describes where to find the ResourceClaim.
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ClaimSource source = 2 [json_name = "source"];</code>
       */
      public Builder setSource(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource value) {
        if (sourceBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          source_ = value;
        } else {
          sourceBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Source describes where to find the ResourceClaim.
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ClaimSource source = 2 [json_name = "source"];</code>
       */
      public Builder setSource(
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource.Builder builderForValue) {
        if (sourceBuilder_ == null) {
          source_ = builderForValue.build();
        } else {
          sourceBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Source describes where to find the ResourceClaim.
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ClaimSource source = 2 [json_name = "source"];</code>
       */
      public Builder mergeSource(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource value) {
        if (sourceBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            source_ != null &&
            source_ != ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource.getDefaultInstance()) {
            getSourceBuilder().mergeFrom(value);
          } else {
            source_ = value;
          }
        } else {
          sourceBuilder_.mergeFrom(value);
        }
        if (source_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Source describes where to find the ResourceClaim.
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ClaimSource source = 2 [json_name = "source"];</code>
       */
      public Builder clearSource() {
        bitField0_ = (bitField0_ & ~0x00000002);
        source_ = null;
        if (sourceBuilder_ != null) {
          sourceBuilder_.dispose();
          sourceBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Source describes where to find the ResourceClaim.
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ClaimSource source = 2 [json_name = "source"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource.Builder getSourceBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSourceFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Source describes where to find the ResourceClaim.
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ClaimSource source = 2 [json_name = "source"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSourceOrBuilder getSourceOrBuilder() {
        if (sourceBuilder_ != null) {
          return sourceBuilder_.getMessageOrBuilder();
        } else {
          return source_ == null ?
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource.getDefaultInstance() : source_;
        }
      }
      /**
       * <pre>
       * Source describes where to find the ResourceClaim.
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ClaimSource source = 2 [json_name = "source"];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSourceOrBuilder> 
          getSourceFieldBuilder() {
        if (sourceBuilder_ == null) {
          sourceBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSource.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ClaimSourceOrBuilder>(
                  getSource(),
                  getParentForChildren(),
                  isClean());
          source_ = null;
        }
        return sourceBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim)
    }

    // @@protoc_insertion_point(class_scope:chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim)
    private static final ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim();
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<PodResourceClaim>
        PARSER = new com.google.protobuf.AbstractParser<PodResourceClaim>() {
      @java.lang.Override
      public PodResourceClaim parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<PodResourceClaim> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PodResourceClaim> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PodSpecOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chalk.pubsub.v1.PodStatusPubSub.PodSpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * List of volumes that can be mounted by containers belonging to the pod.
     * More info: https://kubernetes.io/docs/concepts/storage/volumes
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge,retainKeys
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
     */
    java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume> 
        getVolumesList();
    /**
     * <pre>
     * List of volumes that can be mounted by containers belonging to the pod.
     * More info: https://kubernetes.io/docs/concepts/storage/volumes
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge,retainKeys
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume getVolumes(int index);
    /**
     * <pre>
     * List of volumes that can be mounted by containers belonging to the pod.
     * More info: https://kubernetes.io/docs/concepts/storage/volumes
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge,retainKeys
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
     */
    int getVolumesCount();
    /**
     * <pre>
     * List of volumes that can be mounted by containers belonging to the pod.
     * More info: https://kubernetes.io/docs/concepts/storage/volumes
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge,retainKeys
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
     */
    java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.VolumeOrBuilder> 
        getVolumesOrBuilderList();
    /**
     * <pre>
     * List of volumes that can be mounted by containers belonging to the pod.
     * More info: https://kubernetes.io/docs/concepts/storage/volumes
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge,retainKeys
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.VolumeOrBuilder getVolumesOrBuilder(
        int index);

    /**
     * <pre>
     * List of initialization containers belonging to the pod.
     * Init containers are executed in order prior to containers being started. If any
     * init container fails, the pod is considered to have failed and is handled according
     * to its restartPolicy. The name for an init container or normal container must be
     * unique among all containers.
     * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
     * The resourceRequirements of an init container are taken into account during scheduling
     * by finding the highest request/limit for each resource type, and then using the max of
     * of that value or the sum of the normal containers. Limits are applied to init containers
     * in a similar fashion.
     * Init containers cannot currently be added or removed.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
     */
    java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container> 
        getInitContainersList();
    /**
     * <pre>
     * List of initialization containers belonging to the pod.
     * Init containers are executed in order prior to containers being started. If any
     * init container fails, the pod is considered to have failed and is handled according
     * to its restartPolicy. The name for an init container or normal container must be
     * unique among all containers.
     * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
     * The resourceRequirements of an init container are taken into account during scheduling
     * by finding the highest request/limit for each resource type, and then using the max of
     * of that value or the sum of the normal containers. Limits are applied to init containers
     * in a similar fashion.
     * Init containers cannot currently be added or removed.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container getInitContainers(int index);
    /**
     * <pre>
     * List of initialization containers belonging to the pod.
     * Init containers are executed in order prior to containers being started. If any
     * init container fails, the pod is considered to have failed and is handled according
     * to its restartPolicy. The name for an init container or normal container must be
     * unique among all containers.
     * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
     * The resourceRequirements of an init container are taken into account during scheduling
     * by finding the highest request/limit for each resource type, and then using the max of
     * of that value or the sum of the normal containers. Limits are applied to init containers
     * in a similar fashion.
     * Init containers cannot currently be added or removed.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
     */
    int getInitContainersCount();
    /**
     * <pre>
     * List of initialization containers belonging to the pod.
     * Init containers are executed in order prior to containers being started. If any
     * init container fails, the pod is considered to have failed and is handled according
     * to its restartPolicy. The name for an init container or normal container must be
     * unique among all containers.
     * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
     * The resourceRequirements of an init container are taken into account during scheduling
     * by finding the highest request/limit for each resource type, and then using the max of
     * of that value or the sum of the normal containers. Limits are applied to init containers
     * in a similar fashion.
     * Init containers cannot currently be added or removed.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
     */
    java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerOrBuilder> 
        getInitContainersOrBuilderList();
    /**
     * <pre>
     * List of initialization containers belonging to the pod.
     * Init containers are executed in order prior to containers being started. If any
     * init container fails, the pod is considered to have failed and is handled according
     * to its restartPolicy. The name for an init container or normal container must be
     * unique among all containers.
     * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
     * The resourceRequirements of an init container are taken into account during scheduling
     * by finding the highest request/limit for each resource type, and then using the max of
     * of that value or the sum of the normal containers. Limits are applied to init containers
     * in a similar fashion.
     * Init containers cannot currently be added or removed.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerOrBuilder getInitContainersOrBuilder(
        int index);

    /**
     * <pre>
     * List of containers belonging to the pod.
     * Containers cannot currently be added or removed.
     * There must be at least one container in a Pod.
     * Cannot be updated.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
     */
    java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container> 
        getContainersList();
    /**
     * <pre>
     * List of containers belonging to the pod.
     * Containers cannot currently be added or removed.
     * There must be at least one container in a Pod.
     * Cannot be updated.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container getContainers(int index);
    /**
     * <pre>
     * List of containers belonging to the pod.
     * Containers cannot currently be added or removed.
     * There must be at least one container in a Pod.
     * Cannot be updated.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
     */
    int getContainersCount();
    /**
     * <pre>
     * List of containers belonging to the pod.
     * Containers cannot currently be added or removed.
     * There must be at least one container in a Pod.
     * Cannot be updated.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
     */
    java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerOrBuilder> 
        getContainersOrBuilderList();
    /**
     * <pre>
     * List of containers belonging to the pod.
     * Containers cannot currently be added or removed.
     * There must be at least one container in a Pod.
     * Cannot be updated.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerOrBuilder getContainersOrBuilder(
        int index);

    /**
     * <pre>
     * Restart policy for all containers within the pod.
     * One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted.
     * Default to Always.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
     * +optional
     * </pre>
     *
     * <code>optional string restart_policy = 3 [json_name = "restartPolicy"];</code>
     * @return Whether the restartPolicy field is set.
     */
    boolean hasRestartPolicy();
    /**
     * <pre>
     * Restart policy for all containers within the pod.
     * One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted.
     * Default to Always.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
     * +optional
     * </pre>
     *
     * <code>optional string restart_policy = 3 [json_name = "restartPolicy"];</code>
     * @return The restartPolicy.
     */
    java.lang.String getRestartPolicy();
    /**
     * <pre>
     * Restart policy for all containers within the pod.
     * One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted.
     * Default to Always.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
     * +optional
     * </pre>
     *
     * <code>optional string restart_policy = 3 [json_name = "restartPolicy"];</code>
     * @return The bytes for restartPolicy.
     */
    com.google.protobuf.ByteString
        getRestartPolicyBytes();

    /**
     * <pre>
     * Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
     * Value must be non-negative integer. The value zero indicates stop immediately via
     * the kill signal (no opportunity to shut down).
     * If this value is nil, the default grace period will be used instead.
     * The grace period is the duration in seconds after the processes running in the pod are sent
     * a termination signal and the time when the processes are forcibly halted with a kill signal.
     * Set this value longer than the expected cleanup time for your process.
     * Defaults to 30 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int64 termination_grace_period_seconds = 4 [json_name = "terminationGracePeriodSeconds"];</code>
     * @return Whether the terminationGracePeriodSeconds field is set.
     */
    boolean hasTerminationGracePeriodSeconds();
    /**
     * <pre>
     * Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
     * Value must be non-negative integer. The value zero indicates stop immediately via
     * the kill signal (no opportunity to shut down).
     * If this value is nil, the default grace period will be used instead.
     * The grace period is the duration in seconds after the processes running in the pod are sent
     * a termination signal and the time when the processes are forcibly halted with a kill signal.
     * Set this value longer than the expected cleanup time for your process.
     * Defaults to 30 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int64 termination_grace_period_seconds = 4 [json_name = "terminationGracePeriodSeconds"];</code>
     * @return The terminationGracePeriodSeconds.
     */
    long getTerminationGracePeriodSeconds();

    /**
     * <pre>
     * Optional duration in seconds the pod may be active on the node relative to
     * start_time before the system will actively try to mark it failed and kill associated containers.
     * Value must be a positive integer.
     * +optional
     * </pre>
     *
     * <code>optional int64 active_deadline_seconds = 5 [json_name = "activeDeadlineSeconds"];</code>
     * @return Whether the activeDeadlineSeconds field is set.
     */
    boolean hasActiveDeadlineSeconds();
    /**
     * <pre>
     * Optional duration in seconds the pod may be active on the node relative to
     * start_time before the system will actively try to mark it failed and kill associated containers.
     * Value must be a positive integer.
     * +optional
     * </pre>
     *
     * <code>optional int64 active_deadline_seconds = 5 [json_name = "activeDeadlineSeconds"];</code>
     * @return The activeDeadlineSeconds.
     */
    long getActiveDeadlineSeconds();

    /**
     * <pre>
     * Set DNS policy for the pod.
     * Defaults to "ClusterFirst".
     * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
     * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
     * To have DNS options set along with hostNetwork, you have to specify DNS policy
     * explicitly to 'ClusterFirstWithHostNet'.
     * +optional
     * </pre>
     *
     * <code>optional string dns_policy = 6 [json_name = "dnsPolicy"];</code>
     * @return Whether the dnsPolicy field is set.
     */
    boolean hasDnsPolicy();
    /**
     * <pre>
     * Set DNS policy for the pod.
     * Defaults to "ClusterFirst".
     * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
     * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
     * To have DNS options set along with hostNetwork, you have to specify DNS policy
     * explicitly to 'ClusterFirstWithHostNet'.
     * +optional
     * </pre>
     *
     * <code>optional string dns_policy = 6 [json_name = "dnsPolicy"];</code>
     * @return The dnsPolicy.
     */
    java.lang.String getDnsPolicy();
    /**
     * <pre>
     * Set DNS policy for the pod.
     * Defaults to "ClusterFirst".
     * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
     * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
     * To have DNS options set along with hostNetwork, you have to specify DNS policy
     * explicitly to 'ClusterFirstWithHostNet'.
     * +optional
     * </pre>
     *
     * <code>optional string dns_policy = 6 [json_name = "dnsPolicy"];</code>
     * @return The bytes for dnsPolicy.
     */
    com.google.protobuf.ByteString
        getDnsPolicyBytes();

    /**
     * <pre>
     * NodeSelector is a selector which must be true for the pod to fit on a node.
     * Selector which must match a node's labels for the pod to be scheduled on that node.
     * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
     * +optional
     * +mapType=atomic
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_selector = 7 [json_name = "nodeSelector"];</code>
     */
    int getNodeSelectorCount();
    /**
     * <pre>
     * NodeSelector is a selector which must be true for the pod to fit on a node.
     * Selector which must match a node's labels for the pod to be scheduled on that node.
     * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
     * +optional
     * +mapType=atomic
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_selector = 7 [json_name = "nodeSelector"];</code>
     */
    boolean containsNodeSelector(
        java.lang.String key);
    /**
     * Use {@link #getNodeSelectorMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getNodeSelector();
    /**
     * <pre>
     * NodeSelector is a selector which must be true for the pod to fit on a node.
     * Selector which must match a node's labels for the pod to be scheduled on that node.
     * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
     * +optional
     * +mapType=atomic
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_selector = 7 [json_name = "nodeSelector"];</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getNodeSelectorMap();
    /**
     * <pre>
     * NodeSelector is a selector which must be true for the pod to fit on a node.
     * Selector which must match a node's labels for the pod to be scheduled on that node.
     * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
     * +optional
     * +mapType=atomic
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_selector = 7 [json_name = "nodeSelector"];</code>
     */
    /* nullable */
java.lang.String getNodeSelectorOrDefault(
        java.lang.String key,
        /* nullable */
java.lang.String defaultValue);
    /**
     * <pre>
     * NodeSelector is a selector which must be true for the pod to fit on a node.
     * Selector which must match a node's labels for the pod to be scheduled on that node.
     * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
     * +optional
     * +mapType=atomic
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_selector = 7 [json_name = "nodeSelector"];</code>
     */
    java.lang.String getNodeSelectorOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
     * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
     * +optional
     * </pre>
     *
     * <code>optional string service_account_name = 8 [json_name = "serviceAccountName"];</code>
     * @return Whether the serviceAccountName field is set.
     */
    boolean hasServiceAccountName();
    /**
     * <pre>
     * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
     * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
     * +optional
     * </pre>
     *
     * <code>optional string service_account_name = 8 [json_name = "serviceAccountName"];</code>
     * @return The serviceAccountName.
     */
    java.lang.String getServiceAccountName();
    /**
     * <pre>
     * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
     * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
     * +optional
     * </pre>
     *
     * <code>optional string service_account_name = 8 [json_name = "serviceAccountName"];</code>
     * @return The bytes for serviceAccountName.
     */
    com.google.protobuf.ByteString
        getServiceAccountNameBytes();

    /**
     * <pre>
     * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
     * +optional
     * </pre>
     *
     * <code>optional bool automount_service_account_token = 21 [json_name = "automountServiceAccountToken"];</code>
     * @return Whether the automountServiceAccountToken field is set.
     */
    boolean hasAutomountServiceAccountToken();
    /**
     * <pre>
     * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
     * +optional
     * </pre>
     *
     * <code>optional bool automount_service_account_token = 21 [json_name = "automountServiceAccountToken"];</code>
     * @return The automountServiceAccountToken.
     */
    boolean getAutomountServiceAccountToken();

    /**
     * <pre>
     * NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
     * the scheduler simply schedules this pod onto that node, assuming that it fits resource
     * requirements.
     * +optional
     * </pre>
     *
     * <code>optional string node_name = 10 [json_name = "nodeName"];</code>
     * @return Whether the nodeName field is set.
     */
    boolean hasNodeName();
    /**
     * <pre>
     * NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
     * the scheduler simply schedules this pod onto that node, assuming that it fits resource
     * requirements.
     * +optional
     * </pre>
     *
     * <code>optional string node_name = 10 [json_name = "nodeName"];</code>
     * @return The nodeName.
     */
    java.lang.String getNodeName();
    /**
     * <pre>
     * NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
     * the scheduler simply schedules this pod onto that node, assuming that it fits resource
     * requirements.
     * +optional
     * </pre>
     *
     * <code>optional string node_name = 10 [json_name = "nodeName"];</code>
     * @return The bytes for nodeName.
     */
    com.google.protobuf.ByteString
        getNodeNameBytes();

    /**
     * <pre>
     * Host networking requested for this pod. Use the host's network namespace.
     * If this option is set, the ports that will be used must be specified.
     * Default to false.
     * +k8s:conversion-gen=false
     * +optional
     * </pre>
     *
     * <code>bool host_network = 11 [json_name = "hostNetwork"];</code>
     * @return The hostNetwork.
     */
    boolean getHostNetwork();

    /**
     * <pre>
     * Use the host's pid namespace.
     * Optional: Default to false.
     * +k8s:conversion-gen=false
     * +optional
     * </pre>
     *
     * <code>bool host_pid = 12 [json_name = "hostPid"];</code>
     * @return The hostPid.
     */
    boolean getHostPid();

    /**
     * <pre>
     * Use the host's ipc namespace.
     * Optional: Default to false.
     * +k8s:conversion-gen=false
     * +optional
     * </pre>
     *
     * <code>bool host_ipc = 13 [json_name = "hostIpc"];</code>
     * @return The hostIpc.
     */
    boolean getHostIpc();

    /**
     * <pre>
     * Share a single process namespace between all of the containers in a pod.
     * When this is set containers will be able to view and signal processes from other containers
     * in the same pod, and the first process in each container will not be assigned PID 1.
     * HostPID and ShareProcessNamespace cannot both be set.
     * Optional: Default to false.
     * +k8s:conversion-gen=false
     * +optional
     * </pre>
     *
     * <code>bool share_process_namespace = 27 [json_name = "shareProcessNamespace"];</code>
     * @return The shareProcessNamespace.
     */
    boolean getShareProcessNamespace();

    /**
     * <pre>
     * Specifies the hostname of the Pod
     * If not specified, the pod's hostname will be set to a system-defined value.
     * +optional
     * </pre>
     *
     * <code>optional string hostname = 16 [json_name = "hostname"];</code>
     * @return Whether the hostname field is set.
     */
    boolean hasHostname();
    /**
     * <pre>
     * Specifies the hostname of the Pod
     * If not specified, the pod's hostname will be set to a system-defined value.
     * +optional
     * </pre>
     *
     * <code>optional string hostname = 16 [json_name = "hostname"];</code>
     * @return The hostname.
     */
    java.lang.String getHostname();
    /**
     * <pre>
     * Specifies the hostname of the Pod
     * If not specified, the pod's hostname will be set to a system-defined value.
     * +optional
     * </pre>
     *
     * <code>optional string hostname = 16 [json_name = "hostname"];</code>
     * @return The bytes for hostname.
     */
    com.google.protobuf.ByteString
        getHostnameBytes();

    /**
     * <pre>
     * If specified, the fully qualified Pod hostname will be "&lt;hostname&gt;.&lt;subdomain&gt;.&lt;pod namespace&gt;.svc.&lt;cluster domain&gt;".
     * If not specified, the pod will not have a domainname at all.
     * +optional
     * </pre>
     *
     * <code>optional string subdomain = 17 [json_name = "subdomain"];</code>
     * @return Whether the subdomain field is set.
     */
    boolean hasSubdomain();
    /**
     * <pre>
     * If specified, the fully qualified Pod hostname will be "&lt;hostname&gt;.&lt;subdomain&gt;.&lt;pod namespace&gt;.svc.&lt;cluster domain&gt;".
     * If not specified, the pod will not have a domainname at all.
     * +optional
     * </pre>
     *
     * <code>optional string subdomain = 17 [json_name = "subdomain"];</code>
     * @return The subdomain.
     */
    java.lang.String getSubdomain();
    /**
     * <pre>
     * If specified, the fully qualified Pod hostname will be "&lt;hostname&gt;.&lt;subdomain&gt;.&lt;pod namespace&gt;.svc.&lt;cluster domain&gt;".
     * If not specified, the pod will not have a domainname at all.
     * +optional
     * </pre>
     *
     * <code>optional string subdomain = 17 [json_name = "subdomain"];</code>
     * @return The bytes for subdomain.
     */
    com.google.protobuf.ByteString
        getSubdomainBytes();

    /**
     * <pre>
     * If specified, the pod will be dispatched by specified scheduler.
     * If not specified, the pod will be dispatched by default scheduler.
     * +optional
     * </pre>
     *
     * <code>optional string scheduler_name = 19 [json_name = "schedulerName"];</code>
     * @return Whether the schedulerName field is set.
     */
    boolean hasSchedulerName();
    /**
     * <pre>
     * If specified, the pod will be dispatched by specified scheduler.
     * If not specified, the pod will be dispatched by default scheduler.
     * +optional
     * </pre>
     *
     * <code>optional string scheduler_name = 19 [json_name = "schedulerName"];</code>
     * @return The schedulerName.
     */
    java.lang.String getSchedulerName();
    /**
     * <pre>
     * If specified, the pod will be dispatched by specified scheduler.
     * If not specified, the pod will be dispatched by default scheduler.
     * +optional
     * </pre>
     *
     * <code>optional string scheduler_name = 19 [json_name = "schedulerName"];</code>
     * @return The bytes for schedulerName.
     */
    com.google.protobuf.ByteString
        getSchedulerNameBytes();

    /**
     * <pre>
     * If specified, indicates the pod's priority. "system-node-critical" and
     * "system-cluster-critical" are two special keywords which indicate the
     * highest priorities with the former being the highest priority. Any other
     * name must be defined by creating a PriorityClass object with that name.
     * If not specified, the pod priority will be default or zero if there is no
     * default.
     * +optional
     * </pre>
     *
     * <code>optional string priority_class_name = 24 [json_name = "priorityClassName"];</code>
     * @return Whether the priorityClassName field is set.
     */
    boolean hasPriorityClassName();
    /**
     * <pre>
     * If specified, indicates the pod's priority. "system-node-critical" and
     * "system-cluster-critical" are two special keywords which indicate the
     * highest priorities with the former being the highest priority. Any other
     * name must be defined by creating a PriorityClass object with that name.
     * If not specified, the pod priority will be default or zero if there is no
     * default.
     * +optional
     * </pre>
     *
     * <code>optional string priority_class_name = 24 [json_name = "priorityClassName"];</code>
     * @return The priorityClassName.
     */
    java.lang.String getPriorityClassName();
    /**
     * <pre>
     * If specified, indicates the pod's priority. "system-node-critical" and
     * "system-cluster-critical" are two special keywords which indicate the
     * highest priorities with the former being the highest priority. Any other
     * name must be defined by creating a PriorityClass object with that name.
     * If not specified, the pod priority will be default or zero if there is no
     * default.
     * +optional
     * </pre>
     *
     * <code>optional string priority_class_name = 24 [json_name = "priorityClassName"];</code>
     * @return The bytes for priorityClassName.
     */
    com.google.protobuf.ByteString
        getPriorityClassNameBytes();

    /**
     * <pre>
     * The priority value. Various system components use this field to find the
     * priority of the pod. When Priority Admission Controller is enabled, it
     * prevents users from setting this field. The admission controller populates
     * this field from priority_class_name.
     * The higher the value, the higher the priority.
     * +optional
     * </pre>
     *
     * <code>optional int32 priority = 25 [json_name = "priority"];</code>
     * @return Whether the priority field is set.
     */
    boolean hasPriority();
    /**
     * <pre>
     * The priority value. Various system components use this field to find the
     * priority of the pod. When Priority Admission Controller is enabled, it
     * prevents users from setting this field. The admission controller populates
     * this field from priority_class_name.
     * The higher the value, the higher the priority.
     * +optional
     * </pre>
     *
     * <code>optional int32 priority = 25 [json_name = "priority"];</code>
     * @return The priority.
     */
    int getPriority();

    /**
     * <pre>
     * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
     * to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
     * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
     * empty definition that uses the default runtime handler.
     * More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
     * +optional
     * </pre>
     *
     * <code>optional string runtime_class_name = 29 [json_name = "runtimeClassName"];</code>
     * @return Whether the runtimeClassName field is set.
     */
    boolean hasRuntimeClassName();
    /**
     * <pre>
     * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
     * to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
     * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
     * empty definition that uses the default runtime handler.
     * More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
     * +optional
     * </pre>
     *
     * <code>optional string runtime_class_name = 29 [json_name = "runtimeClassName"];</code>
     * @return The runtimeClassName.
     */
    java.lang.String getRuntimeClassName();
    /**
     * <pre>
     * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
     * to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
     * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
     * empty definition that uses the default runtime handler.
     * More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
     * +optional
     * </pre>
     *
     * <code>optional string runtime_class_name = 29 [json_name = "runtimeClassName"];</code>
     * @return The bytes for runtimeClassName.
     */
    com.google.protobuf.ByteString
        getRuntimeClassNameBytes();

    /**
     * <pre>
     * EnableServiceLinks indicates whether information about services should be injected into pod's
     * environment variables, matching the syntax of Docker links.
     * Optional: Defaults to true.
     * +optional
     * </pre>
     *
     * <code>optional bool enable_service_links = 30 [json_name = "enableServiceLinks"];</code>
     * @return Whether the enableServiceLinks field is set.
     */
    boolean hasEnableServiceLinks();
    /**
     * <pre>
     * EnableServiceLinks indicates whether information about services should be injected into pod's
     * environment variables, matching the syntax of Docker links.
     * Optional: Defaults to true.
     * +optional
     * </pre>
     *
     * <code>optional bool enable_service_links = 30 [json_name = "enableServiceLinks"];</code>
     * @return The enableServiceLinks.
     */
    boolean getEnableServiceLinks();

    /**
     * <pre>
     * PreemptionPolicy is the Policy for preempting pods with lower priority.
     * One of Never, PreemptLowerPriority.
     * Defaults to PreemptLowerPriority if unset.
     * +optional
     * </pre>
     *
     * <code>optional string preemption_policy = 31 [json_name = "preemptionPolicy"];</code>
     * @return Whether the preemptionPolicy field is set.
     */
    boolean hasPreemptionPolicy();
    /**
     * <pre>
     * PreemptionPolicy is the Policy for preempting pods with lower priority.
     * One of Never, PreemptLowerPriority.
     * Defaults to PreemptLowerPriority if unset.
     * +optional
     * </pre>
     *
     * <code>optional string preemption_policy = 31 [json_name = "preemptionPolicy"];</code>
     * @return The preemptionPolicy.
     */
    java.lang.String getPreemptionPolicy();
    /**
     * <pre>
     * PreemptionPolicy is the Policy for preempting pods with lower priority.
     * One of Never, PreemptLowerPriority.
     * Defaults to PreemptLowerPriority if unset.
     * +optional
     * </pre>
     *
     * <code>optional string preemption_policy = 31 [json_name = "preemptionPolicy"];</code>
     * @return The bytes for preemptionPolicy.
     */
    com.google.protobuf.ByteString
        getPreemptionPolicyBytes();

    /**
     * <pre>
     * Use the host's user namespace.
     * Optional: Default to true.
     * If set to true or not present, the pod will be run in the host user namespace, useful
     * for when the pod needs a feature only available to the host user namespace, such as
     * loading a kernel module with CAP_SYS_MODULE.
     * When set to false, a new userns is created for the pod. Setting false is useful for
     * mitigating container breakout vulnerabilities even allowing users to run their
     * containers as root without actually having root privileges on the host.
     * This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.
     * +k8s:conversion-gen=false
     * +optional
     * </pre>
     *
     * <code>optional bool host_users = 37 [json_name = "hostUsers"];</code>
     * @return Whether the hostUsers field is set.
     */
    boolean hasHostUsers();
    /**
     * <pre>
     * Use the host's user namespace.
     * Optional: Default to true.
     * If set to true or not present, the pod will be run in the host user namespace, useful
     * for when the pod needs a feature only available to the host user namespace, such as
     * loading a kernel module with CAP_SYS_MODULE.
     * When set to false, a new userns is created for the pod. Setting false is useful for
     * mitigating container breakout vulnerabilities even allowing users to run their
     * containers as root without actually having root privileges on the host.
     * This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.
     * +k8s:conversion-gen=false
     * +optional
     * </pre>
     *
     * <code>optional bool host_users = 37 [json_name = "hostUsers"];</code>
     * @return The hostUsers.
     */
    boolean getHostUsers();

    /**
     * <pre>
     * ResourceClaims defines which ResourceClaims must be allocated
     * and reserved before the Pod is allowed to start. The resources
     * will be made available to those containers which consume them
     * by name.
     *
     * This is an alpha field and requires enabling the
     * DynamicResourceAllocation feature gate.
     *
     * This field is immutable.
     *
     * +patchMergeKey=name
     * +patchStrategy=merge,retainKeys
     * +listType=map
     * +listMapKey=name
     * +featureGate=DynamicResourceAllocation
     * +optional
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
     */
    java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim> 
        getResourceClaimsList();
    /**
     * <pre>
     * ResourceClaims defines which ResourceClaims must be allocated
     * and reserved before the Pod is allowed to start. The resources
     * will be made available to those containers which consume them
     * by name.
     *
     * This is an alpha field and requires enabling the
     * DynamicResourceAllocation feature gate.
     *
     * This field is immutable.
     *
     * +patchMergeKey=name
     * +patchStrategy=merge,retainKeys
     * +listType=map
     * +listMapKey=name
     * +featureGate=DynamicResourceAllocation
     * +optional
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim getResourceClaims(int index);
    /**
     * <pre>
     * ResourceClaims defines which ResourceClaims must be allocated
     * and reserved before the Pod is allowed to start. The resources
     * will be made available to those containers which consume them
     * by name.
     *
     * This is an alpha field and requires enabling the
     * DynamicResourceAllocation feature gate.
     *
     * This field is immutable.
     *
     * +patchMergeKey=name
     * +patchStrategy=merge,retainKeys
     * +listType=map
     * +listMapKey=name
     * +featureGate=DynamicResourceAllocation
     * +optional
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
     */
    int getResourceClaimsCount();
    /**
     * <pre>
     * ResourceClaims defines which ResourceClaims must be allocated
     * and reserved before the Pod is allowed to start. The resources
     * will be made available to those containers which consume them
     * by name.
     *
     * This is an alpha field and requires enabling the
     * DynamicResourceAllocation feature gate.
     *
     * This field is immutable.
     *
     * +patchMergeKey=name
     * +patchStrategy=merge,retainKeys
     * +listType=map
     * +listMapKey=name
     * +featureGate=DynamicResourceAllocation
     * +optional
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
     */
    java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaimOrBuilder> 
        getResourceClaimsOrBuilderList();
    /**
     * <pre>
     * ResourceClaims defines which ResourceClaims must be allocated
     * and reserved before the Pod is allowed to start. The resources
     * will be made available to those containers which consume them
     * by name.
     *
     * This is an alpha field and requires enabling the
     * DynamicResourceAllocation feature gate.
     *
     * This field is immutable.
     *
     * +patchMergeKey=name
     * +patchStrategy=merge,retainKeys
     * +listType=map
     * +listMapKey=name
     * +featureGate=DynamicResourceAllocation
     * +optional
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaimOrBuilder getResourceClaimsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * PodSpec is a description of a pod.
   * </pre>
   *
   * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.PodSpec}
   */
  public static final class PodSpec extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chalk.pubsub.v1.PodStatusPubSub.PodSpec)
      PodSpecOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use PodSpec.newBuilder() to construct.
    private PodSpec(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private PodSpec() {
      volumes_ = java.util.Collections.emptyList();
      initContainers_ = java.util.Collections.emptyList();
      containers_ = java.util.Collections.emptyList();
      restartPolicy_ = "";
      dnsPolicy_ = "";
      serviceAccountName_ = "";
      nodeName_ = "";
      hostname_ = "";
      subdomain_ = "";
      schedulerName_ = "";
      priorityClassName_ = "";
      runtimeClassName_ = "";
      preemptionPolicy_ = "";
      resourceClaims_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new PodSpec();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_PodSpec_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
        int number) {
      switch (number) {
        case 7:
          return internalGetNodeSelector();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_PodSpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec.Builder.class);
    }

    private int bitField0_;
    public static final int VOLUMES_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume> volumes_;
    /**
     * <pre>
     * List of volumes that can be mounted by containers belonging to the pod.
     * More info: https://kubernetes.io/docs/concepts/storage/volumes
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge,retainKeys
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
     */
    @java.lang.Override
    public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume> getVolumesList() {
      return volumes_;
    }
    /**
     * <pre>
     * List of volumes that can be mounted by containers belonging to the pod.
     * More info: https://kubernetes.io/docs/concepts/storage/volumes
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge,retainKeys
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
     */
    @java.lang.Override
    public java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.VolumeOrBuilder> 
        getVolumesOrBuilderList() {
      return volumes_;
    }
    /**
     * <pre>
     * List of volumes that can be mounted by containers belonging to the pod.
     * More info: https://kubernetes.io/docs/concepts/storage/volumes
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge,retainKeys
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
     */
    @java.lang.Override
    public int getVolumesCount() {
      return volumes_.size();
    }
    /**
     * <pre>
     * List of volumes that can be mounted by containers belonging to the pod.
     * More info: https://kubernetes.io/docs/concepts/storage/volumes
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge,retainKeys
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume getVolumes(int index) {
      return volumes_.get(index);
    }
    /**
     * <pre>
     * List of volumes that can be mounted by containers belonging to the pod.
     * More info: https://kubernetes.io/docs/concepts/storage/volumes
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge,retainKeys
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.VolumeOrBuilder getVolumesOrBuilder(
        int index) {
      return volumes_.get(index);
    }

    public static final int INIT_CONTAINERS_FIELD_NUMBER = 20;
    @SuppressWarnings("serial")
    private java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container> initContainers_;
    /**
     * <pre>
     * List of initialization containers belonging to the pod.
     * Init containers are executed in order prior to containers being started. If any
     * init container fails, the pod is considered to have failed and is handled according
     * to its restartPolicy. The name for an init container or normal container must be
     * unique among all containers.
     * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
     * The resourceRequirements of an init container are taken into account during scheduling
     * by finding the highest request/limit for each resource type, and then using the max of
     * of that value or the sum of the normal containers. Limits are applied to init containers
     * in a similar fashion.
     * Init containers cannot currently be added or removed.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
     */
    @java.lang.Override
    public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container> getInitContainersList() {
      return initContainers_;
    }
    /**
     * <pre>
     * List of initialization containers belonging to the pod.
     * Init containers are executed in order prior to containers being started. If any
     * init container fails, the pod is considered to have failed and is handled according
     * to its restartPolicy. The name for an init container or normal container must be
     * unique among all containers.
     * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
     * The resourceRequirements of an init container are taken into account during scheduling
     * by finding the highest request/limit for each resource type, and then using the max of
     * of that value or the sum of the normal containers. Limits are applied to init containers
     * in a similar fashion.
     * Init containers cannot currently be added or removed.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
     */
    @java.lang.Override
    public java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerOrBuilder> 
        getInitContainersOrBuilderList() {
      return initContainers_;
    }
    /**
     * <pre>
     * List of initialization containers belonging to the pod.
     * Init containers are executed in order prior to containers being started. If any
     * init container fails, the pod is considered to have failed and is handled according
     * to its restartPolicy. The name for an init container or normal container must be
     * unique among all containers.
     * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
     * The resourceRequirements of an init container are taken into account during scheduling
     * by finding the highest request/limit for each resource type, and then using the max of
     * of that value or the sum of the normal containers. Limits are applied to init containers
     * in a similar fashion.
     * Init containers cannot currently be added or removed.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
     */
    @java.lang.Override
    public int getInitContainersCount() {
      return initContainers_.size();
    }
    /**
     * <pre>
     * List of initialization containers belonging to the pod.
     * Init containers are executed in order prior to containers being started. If any
     * init container fails, the pod is considered to have failed and is handled according
     * to its restartPolicy. The name for an init container or normal container must be
     * unique among all containers.
     * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
     * The resourceRequirements of an init container are taken into account during scheduling
     * by finding the highest request/limit for each resource type, and then using the max of
     * of that value or the sum of the normal containers. Limits are applied to init containers
     * in a similar fashion.
     * Init containers cannot currently be added or removed.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container getInitContainers(int index) {
      return initContainers_.get(index);
    }
    /**
     * <pre>
     * List of initialization containers belonging to the pod.
     * Init containers are executed in order prior to containers being started. If any
     * init container fails, the pod is considered to have failed and is handled according
     * to its restartPolicy. The name for an init container or normal container must be
     * unique among all containers.
     * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
     * The resourceRequirements of an init container are taken into account during scheduling
     * by finding the highest request/limit for each resource type, and then using the max of
     * of that value or the sum of the normal containers. Limits are applied to init containers
     * in a similar fashion.
     * Init containers cannot currently be added or removed.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerOrBuilder getInitContainersOrBuilder(
        int index) {
      return initContainers_.get(index);
    }

    public static final int CONTAINERS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container> containers_;
    /**
     * <pre>
     * List of containers belonging to the pod.
     * Containers cannot currently be added or removed.
     * There must be at least one container in a Pod.
     * Cannot be updated.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
     */
    @java.lang.Override
    public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container> getContainersList() {
      return containers_;
    }
    /**
     * <pre>
     * List of containers belonging to the pod.
     * Containers cannot currently be added or removed.
     * There must be at least one container in a Pod.
     * Cannot be updated.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
     */
    @java.lang.Override
    public java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerOrBuilder> 
        getContainersOrBuilderList() {
      return containers_;
    }
    /**
     * <pre>
     * List of containers belonging to the pod.
     * Containers cannot currently be added or removed.
     * There must be at least one container in a Pod.
     * Cannot be updated.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
     */
    @java.lang.Override
    public int getContainersCount() {
      return containers_.size();
    }
    /**
     * <pre>
     * List of containers belonging to the pod.
     * Containers cannot currently be added or removed.
     * There must be at least one container in a Pod.
     * Cannot be updated.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container getContainers(int index) {
      return containers_.get(index);
    }
    /**
     * <pre>
     * List of containers belonging to the pod.
     * Containers cannot currently be added or removed.
     * There must be at least one container in a Pod.
     * Cannot be updated.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerOrBuilder getContainersOrBuilder(
        int index) {
      return containers_.get(index);
    }

    public static final int RESTART_POLICY_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object restartPolicy_ = "";
    /**
     * <pre>
     * Restart policy for all containers within the pod.
     * One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted.
     * Default to Always.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
     * +optional
     * </pre>
     *
     * <code>optional string restart_policy = 3 [json_name = "restartPolicy"];</code>
     * @return Whether the restartPolicy field is set.
     */
    @java.lang.Override
    public boolean hasRestartPolicy() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Restart policy for all containers within the pod.
     * One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted.
     * Default to Always.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
     * +optional
     * </pre>
     *
     * <code>optional string restart_policy = 3 [json_name = "restartPolicy"];</code>
     * @return The restartPolicy.
     */
    @java.lang.Override
    public java.lang.String getRestartPolicy() {
      java.lang.Object ref = restartPolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        restartPolicy_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Restart policy for all containers within the pod.
     * One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted.
     * Default to Always.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
     * +optional
     * </pre>
     *
     * <code>optional string restart_policy = 3 [json_name = "restartPolicy"];</code>
     * @return The bytes for restartPolicy.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getRestartPolicyBytes() {
      java.lang.Object ref = restartPolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        restartPolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TERMINATION_GRACE_PERIOD_SECONDS_FIELD_NUMBER = 4;
    private long terminationGracePeriodSeconds_ = 0L;
    /**
     * <pre>
     * Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
     * Value must be non-negative integer. The value zero indicates stop immediately via
     * the kill signal (no opportunity to shut down).
     * If this value is nil, the default grace period will be used instead.
     * The grace period is the duration in seconds after the processes running in the pod are sent
     * a termination signal and the time when the processes are forcibly halted with a kill signal.
     * Set this value longer than the expected cleanup time for your process.
     * Defaults to 30 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int64 termination_grace_period_seconds = 4 [json_name = "terminationGracePeriodSeconds"];</code>
     * @return Whether the terminationGracePeriodSeconds field is set.
     */
    @java.lang.Override
    public boolean hasTerminationGracePeriodSeconds() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
     * Value must be non-negative integer. The value zero indicates stop immediately via
     * the kill signal (no opportunity to shut down).
     * If this value is nil, the default grace period will be used instead.
     * The grace period is the duration in seconds after the processes running in the pod are sent
     * a termination signal and the time when the processes are forcibly halted with a kill signal.
     * Set this value longer than the expected cleanup time for your process.
     * Defaults to 30 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int64 termination_grace_period_seconds = 4 [json_name = "terminationGracePeriodSeconds"];</code>
     * @return The terminationGracePeriodSeconds.
     */
    @java.lang.Override
    public long getTerminationGracePeriodSeconds() {
      return terminationGracePeriodSeconds_;
    }

    public static final int ACTIVE_DEADLINE_SECONDS_FIELD_NUMBER = 5;
    private long activeDeadlineSeconds_ = 0L;
    /**
     * <pre>
     * Optional duration in seconds the pod may be active on the node relative to
     * start_time before the system will actively try to mark it failed and kill associated containers.
     * Value must be a positive integer.
     * +optional
     * </pre>
     *
     * <code>optional int64 active_deadline_seconds = 5 [json_name = "activeDeadlineSeconds"];</code>
     * @return Whether the activeDeadlineSeconds field is set.
     */
    @java.lang.Override
    public boolean hasActiveDeadlineSeconds() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Optional duration in seconds the pod may be active on the node relative to
     * start_time before the system will actively try to mark it failed and kill associated containers.
     * Value must be a positive integer.
     * +optional
     * </pre>
     *
     * <code>optional int64 active_deadline_seconds = 5 [json_name = "activeDeadlineSeconds"];</code>
     * @return The activeDeadlineSeconds.
     */
    @java.lang.Override
    public long getActiveDeadlineSeconds() {
      return activeDeadlineSeconds_;
    }

    public static final int DNS_POLICY_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private volatile java.lang.Object dnsPolicy_ = "";
    /**
     * <pre>
     * Set DNS policy for the pod.
     * Defaults to "ClusterFirst".
     * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
     * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
     * To have DNS options set along with hostNetwork, you have to specify DNS policy
     * explicitly to 'ClusterFirstWithHostNet'.
     * +optional
     * </pre>
     *
     * <code>optional string dns_policy = 6 [json_name = "dnsPolicy"];</code>
     * @return Whether the dnsPolicy field is set.
     */
    @java.lang.Override
    public boolean hasDnsPolicy() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Set DNS policy for the pod.
     * Defaults to "ClusterFirst".
     * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
     * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
     * To have DNS options set along with hostNetwork, you have to specify DNS policy
     * explicitly to 'ClusterFirstWithHostNet'.
     * +optional
     * </pre>
     *
     * <code>optional string dns_policy = 6 [json_name = "dnsPolicy"];</code>
     * @return The dnsPolicy.
     */
    @java.lang.Override
    public java.lang.String getDnsPolicy() {
      java.lang.Object ref = dnsPolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        dnsPolicy_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Set DNS policy for the pod.
     * Defaults to "ClusterFirst".
     * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
     * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
     * To have DNS options set along with hostNetwork, you have to specify DNS policy
     * explicitly to 'ClusterFirstWithHostNet'.
     * +optional
     * </pre>
     *
     * <code>optional string dns_policy = 6 [json_name = "dnsPolicy"];</code>
     * @return The bytes for dnsPolicy.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDnsPolicyBytes() {
      java.lang.Object ref = dnsPolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        dnsPolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NODE_SELECTOR_FIELD_NUMBER = 7;
    private static final class NodeSelectorDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_PodSpec_NodeSelectorEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    @SuppressWarnings("serial")
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> nodeSelector_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetNodeSelector() {
      if (nodeSelector_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            NodeSelectorDefaultEntryHolder.defaultEntry);
      }
      return nodeSelector_;
    }
    public int getNodeSelectorCount() {
      return internalGetNodeSelector().getMap().size();
    }
    /**
     * <pre>
     * NodeSelector is a selector which must be true for the pod to fit on a node.
     * Selector which must match a node's labels for the pod to be scheduled on that node.
     * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
     * +optional
     * +mapType=atomic
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_selector = 7 [json_name = "nodeSelector"];</code>
     */
    @java.lang.Override
    public boolean containsNodeSelector(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      return internalGetNodeSelector().getMap().containsKey(key);
    }
    /**
     * Use {@link #getNodeSelectorMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getNodeSelector() {
      return getNodeSelectorMap();
    }
    /**
     * <pre>
     * NodeSelector is a selector which must be true for the pod to fit on a node.
     * Selector which must match a node's labels for the pod to be scheduled on that node.
     * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
     * +optional
     * +mapType=atomic
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_selector = 7 [json_name = "nodeSelector"];</code>
     */
    @java.lang.Override
    public java.util.Map<java.lang.String, java.lang.String> getNodeSelectorMap() {
      return internalGetNodeSelector().getMap();
    }
    /**
     * <pre>
     * NodeSelector is a selector which must be true for the pod to fit on a node.
     * Selector which must match a node's labels for the pod to be scheduled on that node.
     * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
     * +optional
     * +mapType=atomic
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_selector = 7 [json_name = "nodeSelector"];</code>
     */
    @java.lang.Override
    public /* nullable */
java.lang.String getNodeSelectorOrDefault(
        java.lang.String key,
        /* nullable */
java.lang.String defaultValue) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetNodeSelector().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * NodeSelector is a selector which must be true for the pod to fit on a node.
     * Selector which must match a node's labels for the pod to be scheduled on that node.
     * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
     * +optional
     * +mapType=atomic
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_selector = 7 [json_name = "nodeSelector"];</code>
     */
    @java.lang.Override
    public java.lang.String getNodeSelectorOrThrow(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetNodeSelector().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int SERVICE_ACCOUNT_NAME_FIELD_NUMBER = 8;
    @SuppressWarnings("serial")
    private volatile java.lang.Object serviceAccountName_ = "";
    /**
     * <pre>
     * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
     * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
     * +optional
     * </pre>
     *
     * <code>optional string service_account_name = 8 [json_name = "serviceAccountName"];</code>
     * @return Whether the serviceAccountName field is set.
     */
    @java.lang.Override
    public boolean hasServiceAccountName() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
     * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
     * +optional
     * </pre>
     *
     * <code>optional string service_account_name = 8 [json_name = "serviceAccountName"];</code>
     * @return The serviceAccountName.
     */
    @java.lang.Override
    public java.lang.String getServiceAccountName() {
      java.lang.Object ref = serviceAccountName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        serviceAccountName_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
     * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
     * +optional
     * </pre>
     *
     * <code>optional string service_account_name = 8 [json_name = "serviceAccountName"];</code>
     * @return The bytes for serviceAccountName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getServiceAccountNameBytes() {
      java.lang.Object ref = serviceAccountName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        serviceAccountName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int AUTOMOUNT_SERVICE_ACCOUNT_TOKEN_FIELD_NUMBER = 21;
    private boolean automountServiceAccountToken_ = false;
    /**
     * <pre>
     * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
     * +optional
     * </pre>
     *
     * <code>optional bool automount_service_account_token = 21 [json_name = "automountServiceAccountToken"];</code>
     * @return Whether the automountServiceAccountToken field is set.
     */
    @java.lang.Override
    public boolean hasAutomountServiceAccountToken() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
     * +optional
     * </pre>
     *
     * <code>optional bool automount_service_account_token = 21 [json_name = "automountServiceAccountToken"];</code>
     * @return The automountServiceAccountToken.
     */
    @java.lang.Override
    public boolean getAutomountServiceAccountToken() {
      return automountServiceAccountToken_;
    }

    public static final int NODE_NAME_FIELD_NUMBER = 10;
    @SuppressWarnings("serial")
    private volatile java.lang.Object nodeName_ = "";
    /**
     * <pre>
     * NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
     * the scheduler simply schedules this pod onto that node, assuming that it fits resource
     * requirements.
     * +optional
     * </pre>
     *
     * <code>optional string node_name = 10 [json_name = "nodeName"];</code>
     * @return Whether the nodeName field is set.
     */
    @java.lang.Override
    public boolean hasNodeName() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
     * the scheduler simply schedules this pod onto that node, assuming that it fits resource
     * requirements.
     * +optional
     * </pre>
     *
     * <code>optional string node_name = 10 [json_name = "nodeName"];</code>
     * @return The nodeName.
     */
    @java.lang.Override
    public java.lang.String getNodeName() {
      java.lang.Object ref = nodeName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        nodeName_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
     * the scheduler simply schedules this pod onto that node, assuming that it fits resource
     * requirements.
     * +optional
     * </pre>
     *
     * <code>optional string node_name = 10 [json_name = "nodeName"];</code>
     * @return The bytes for nodeName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNodeNameBytes() {
      java.lang.Object ref = nodeName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        nodeName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int HOST_NETWORK_FIELD_NUMBER = 11;
    private boolean hostNetwork_ = false;
    /**
     * <pre>
     * Host networking requested for this pod. Use the host's network namespace.
     * If this option is set, the ports that will be used must be specified.
     * Default to false.
     * +k8s:conversion-gen=false
     * +optional
     * </pre>
     *
     * <code>bool host_network = 11 [json_name = "hostNetwork"];</code>
     * @return The hostNetwork.
     */
    @java.lang.Override
    public boolean getHostNetwork() {
      return hostNetwork_;
    }

    public static final int HOST_PID_FIELD_NUMBER = 12;
    private boolean hostPid_ = false;
    /**
     * <pre>
     * Use the host's pid namespace.
     * Optional: Default to false.
     * +k8s:conversion-gen=false
     * +optional
     * </pre>
     *
     * <code>bool host_pid = 12 [json_name = "hostPid"];</code>
     * @return The hostPid.
     */
    @java.lang.Override
    public boolean getHostPid() {
      return hostPid_;
    }

    public static final int HOST_IPC_FIELD_NUMBER = 13;
    private boolean hostIpc_ = false;
    /**
     * <pre>
     * Use the host's ipc namespace.
     * Optional: Default to false.
     * +k8s:conversion-gen=false
     * +optional
     * </pre>
     *
     * <code>bool host_ipc = 13 [json_name = "hostIpc"];</code>
     * @return The hostIpc.
     */
    @java.lang.Override
    public boolean getHostIpc() {
      return hostIpc_;
    }

    public static final int SHARE_PROCESS_NAMESPACE_FIELD_NUMBER = 27;
    private boolean shareProcessNamespace_ = false;
    /**
     * <pre>
     * Share a single process namespace between all of the containers in a pod.
     * When this is set containers will be able to view and signal processes from other containers
     * in the same pod, and the first process in each container will not be assigned PID 1.
     * HostPID and ShareProcessNamespace cannot both be set.
     * Optional: Default to false.
     * +k8s:conversion-gen=false
     * +optional
     * </pre>
     *
     * <code>bool share_process_namespace = 27 [json_name = "shareProcessNamespace"];</code>
     * @return The shareProcessNamespace.
     */
    @java.lang.Override
    public boolean getShareProcessNamespace() {
      return shareProcessNamespace_;
    }

    public static final int HOSTNAME_FIELD_NUMBER = 16;
    @SuppressWarnings("serial")
    private volatile java.lang.Object hostname_ = "";
    /**
     * <pre>
     * Specifies the hostname of the Pod
     * If not specified, the pod's hostname will be set to a system-defined value.
     * +optional
     * </pre>
     *
     * <code>optional string hostname = 16 [json_name = "hostname"];</code>
     * @return Whether the hostname field is set.
     */
    @java.lang.Override
    public boolean hasHostname() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Specifies the hostname of the Pod
     * If not specified, the pod's hostname will be set to a system-defined value.
     * +optional
     * </pre>
     *
     * <code>optional string hostname = 16 [json_name = "hostname"];</code>
     * @return The hostname.
     */
    @java.lang.Override
    public java.lang.String getHostname() {
      java.lang.Object ref = hostname_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        hostname_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Specifies the hostname of the Pod
     * If not specified, the pod's hostname will be set to a system-defined value.
     * +optional
     * </pre>
     *
     * <code>optional string hostname = 16 [json_name = "hostname"];</code>
     * @return The bytes for hostname.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getHostnameBytes() {
      java.lang.Object ref = hostname_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        hostname_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SUBDOMAIN_FIELD_NUMBER = 17;
    @SuppressWarnings("serial")
    private volatile java.lang.Object subdomain_ = "";
    /**
     * <pre>
     * If specified, the fully qualified Pod hostname will be "&lt;hostname&gt;.&lt;subdomain&gt;.&lt;pod namespace&gt;.svc.&lt;cluster domain&gt;".
     * If not specified, the pod will not have a domainname at all.
     * +optional
     * </pre>
     *
     * <code>optional string subdomain = 17 [json_name = "subdomain"];</code>
     * @return Whether the subdomain field is set.
     */
    @java.lang.Override
    public boolean hasSubdomain() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * If specified, the fully qualified Pod hostname will be "&lt;hostname&gt;.&lt;subdomain&gt;.&lt;pod namespace&gt;.svc.&lt;cluster domain&gt;".
     * If not specified, the pod will not have a domainname at all.
     * +optional
     * </pre>
     *
     * <code>optional string subdomain = 17 [json_name = "subdomain"];</code>
     * @return The subdomain.
     */
    @java.lang.Override
    public java.lang.String getSubdomain() {
      java.lang.Object ref = subdomain_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        subdomain_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * If specified, the fully qualified Pod hostname will be "&lt;hostname&gt;.&lt;subdomain&gt;.&lt;pod namespace&gt;.svc.&lt;cluster domain&gt;".
     * If not specified, the pod will not have a domainname at all.
     * +optional
     * </pre>
     *
     * <code>optional string subdomain = 17 [json_name = "subdomain"];</code>
     * @return The bytes for subdomain.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSubdomainBytes() {
      java.lang.Object ref = subdomain_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        subdomain_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SCHEDULER_NAME_FIELD_NUMBER = 19;
    @SuppressWarnings("serial")
    private volatile java.lang.Object schedulerName_ = "";
    /**
     * <pre>
     * If specified, the pod will be dispatched by specified scheduler.
     * If not specified, the pod will be dispatched by default scheduler.
     * +optional
     * </pre>
     *
     * <code>optional string scheduler_name = 19 [json_name = "schedulerName"];</code>
     * @return Whether the schedulerName field is set.
     */
    @java.lang.Override
    public boolean hasSchedulerName() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * If specified, the pod will be dispatched by specified scheduler.
     * If not specified, the pod will be dispatched by default scheduler.
     * +optional
     * </pre>
     *
     * <code>optional string scheduler_name = 19 [json_name = "schedulerName"];</code>
     * @return The schedulerName.
     */
    @java.lang.Override
    public java.lang.String getSchedulerName() {
      java.lang.Object ref = schedulerName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        schedulerName_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * If specified, the pod will be dispatched by specified scheduler.
     * If not specified, the pod will be dispatched by default scheduler.
     * +optional
     * </pre>
     *
     * <code>optional string scheduler_name = 19 [json_name = "schedulerName"];</code>
     * @return The bytes for schedulerName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSchedulerNameBytes() {
      java.lang.Object ref = schedulerName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        schedulerName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PRIORITY_CLASS_NAME_FIELD_NUMBER = 24;
    @SuppressWarnings("serial")
    private volatile java.lang.Object priorityClassName_ = "";
    /**
     * <pre>
     * If specified, indicates the pod's priority. "system-node-critical" and
     * "system-cluster-critical" are two special keywords which indicate the
     * highest priorities with the former being the highest priority. Any other
     * name must be defined by creating a PriorityClass object with that name.
     * If not specified, the pod priority will be default or zero if there is no
     * default.
     * +optional
     * </pre>
     *
     * <code>optional string priority_class_name = 24 [json_name = "priorityClassName"];</code>
     * @return Whether the priorityClassName field is set.
     */
    @java.lang.Override
    public boolean hasPriorityClassName() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * If specified, indicates the pod's priority. "system-node-critical" and
     * "system-cluster-critical" are two special keywords which indicate the
     * highest priorities with the former being the highest priority. Any other
     * name must be defined by creating a PriorityClass object with that name.
     * If not specified, the pod priority will be default or zero if there is no
     * default.
     * +optional
     * </pre>
     *
     * <code>optional string priority_class_name = 24 [json_name = "priorityClassName"];</code>
     * @return The priorityClassName.
     */
    @java.lang.Override
    public java.lang.String getPriorityClassName() {
      java.lang.Object ref = priorityClassName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        priorityClassName_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * If specified, indicates the pod's priority. "system-node-critical" and
     * "system-cluster-critical" are two special keywords which indicate the
     * highest priorities with the former being the highest priority. Any other
     * name must be defined by creating a PriorityClass object with that name.
     * If not specified, the pod priority will be default or zero if there is no
     * default.
     * +optional
     * </pre>
     *
     * <code>optional string priority_class_name = 24 [json_name = "priorityClassName"];</code>
     * @return The bytes for priorityClassName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPriorityClassNameBytes() {
      java.lang.Object ref = priorityClassName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        priorityClassName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PRIORITY_FIELD_NUMBER = 25;
    private int priority_ = 0;
    /**
     * <pre>
     * The priority value. Various system components use this field to find the
     * priority of the pod. When Priority Admission Controller is enabled, it
     * prevents users from setting this field. The admission controller populates
     * this field from priority_class_name.
     * The higher the value, the higher the priority.
     * +optional
     * </pre>
     *
     * <code>optional int32 priority = 25 [json_name = "priority"];</code>
     * @return Whether the priority field is set.
     */
    @java.lang.Override
    public boolean hasPriority() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * The priority value. Various system components use this field to find the
     * priority of the pod. When Priority Admission Controller is enabled, it
     * prevents users from setting this field. The admission controller populates
     * this field from priority_class_name.
     * The higher the value, the higher the priority.
     * +optional
     * </pre>
     *
     * <code>optional int32 priority = 25 [json_name = "priority"];</code>
     * @return The priority.
     */
    @java.lang.Override
    public int getPriority() {
      return priority_;
    }

    public static final int RUNTIME_CLASS_NAME_FIELD_NUMBER = 29;
    @SuppressWarnings("serial")
    private volatile java.lang.Object runtimeClassName_ = "";
    /**
     * <pre>
     * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
     * to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
     * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
     * empty definition that uses the default runtime handler.
     * More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
     * +optional
     * </pre>
     *
     * <code>optional string runtime_class_name = 29 [json_name = "runtimeClassName"];</code>
     * @return Whether the runtimeClassName field is set.
     */
    @java.lang.Override
    public boolean hasRuntimeClassName() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <pre>
     * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
     * to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
     * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
     * empty definition that uses the default runtime handler.
     * More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
     * +optional
     * </pre>
     *
     * <code>optional string runtime_class_name = 29 [json_name = "runtimeClassName"];</code>
     * @return The runtimeClassName.
     */
    @java.lang.Override
    public java.lang.String getRuntimeClassName() {
      java.lang.Object ref = runtimeClassName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        runtimeClassName_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
     * to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
     * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
     * empty definition that uses the default runtime handler.
     * More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
     * +optional
     * </pre>
     *
     * <code>optional string runtime_class_name = 29 [json_name = "runtimeClassName"];</code>
     * @return The bytes for runtimeClassName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getRuntimeClassNameBytes() {
      java.lang.Object ref = runtimeClassName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        runtimeClassName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ENABLE_SERVICE_LINKS_FIELD_NUMBER = 30;
    private boolean enableServiceLinks_ = false;
    /**
     * <pre>
     * EnableServiceLinks indicates whether information about services should be injected into pod's
     * environment variables, matching the syntax of Docker links.
     * Optional: Defaults to true.
     * +optional
     * </pre>
     *
     * <code>optional bool enable_service_links = 30 [json_name = "enableServiceLinks"];</code>
     * @return Whether the enableServiceLinks field is set.
     */
    @java.lang.Override
    public boolean hasEnableServiceLinks() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <pre>
     * EnableServiceLinks indicates whether information about services should be injected into pod's
     * environment variables, matching the syntax of Docker links.
     * Optional: Defaults to true.
     * +optional
     * </pre>
     *
     * <code>optional bool enable_service_links = 30 [json_name = "enableServiceLinks"];</code>
     * @return The enableServiceLinks.
     */
    @java.lang.Override
    public boolean getEnableServiceLinks() {
      return enableServiceLinks_;
    }

    public static final int PREEMPTION_POLICY_FIELD_NUMBER = 31;
    @SuppressWarnings("serial")
    private volatile java.lang.Object preemptionPolicy_ = "";
    /**
     * <pre>
     * PreemptionPolicy is the Policy for preempting pods with lower priority.
     * One of Never, PreemptLowerPriority.
     * Defaults to PreemptLowerPriority if unset.
     * +optional
     * </pre>
     *
     * <code>optional string preemption_policy = 31 [json_name = "preemptionPolicy"];</code>
     * @return Whether the preemptionPolicy field is set.
     */
    @java.lang.Override
    public boolean hasPreemptionPolicy() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     * <pre>
     * PreemptionPolicy is the Policy for preempting pods with lower priority.
     * One of Never, PreemptLowerPriority.
     * Defaults to PreemptLowerPriority if unset.
     * +optional
     * </pre>
     *
     * <code>optional string preemption_policy = 31 [json_name = "preemptionPolicy"];</code>
     * @return The preemptionPolicy.
     */
    @java.lang.Override
    public java.lang.String getPreemptionPolicy() {
      java.lang.Object ref = preemptionPolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        preemptionPolicy_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * PreemptionPolicy is the Policy for preempting pods with lower priority.
     * One of Never, PreemptLowerPriority.
     * Defaults to PreemptLowerPriority if unset.
     * +optional
     * </pre>
     *
     * <code>optional string preemption_policy = 31 [json_name = "preemptionPolicy"];</code>
     * @return The bytes for preemptionPolicy.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPreemptionPolicyBytes() {
      java.lang.Object ref = preemptionPolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        preemptionPolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int HOST_USERS_FIELD_NUMBER = 37;
    private boolean hostUsers_ = false;
    /**
     * <pre>
     * Use the host's user namespace.
     * Optional: Default to true.
     * If set to true or not present, the pod will be run in the host user namespace, useful
     * for when the pod needs a feature only available to the host user namespace, such as
     * loading a kernel module with CAP_SYS_MODULE.
     * When set to false, a new userns is created for the pod. Setting false is useful for
     * mitigating container breakout vulnerabilities even allowing users to run their
     * containers as root without actually having root privileges on the host.
     * This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.
     * +k8s:conversion-gen=false
     * +optional
     * </pre>
     *
     * <code>optional bool host_users = 37 [json_name = "hostUsers"];</code>
     * @return Whether the hostUsers field is set.
     */
    @java.lang.Override
    public boolean hasHostUsers() {
      return ((bitField0_ & 0x00008000) != 0);
    }
    /**
     * <pre>
     * Use the host's user namespace.
     * Optional: Default to true.
     * If set to true or not present, the pod will be run in the host user namespace, useful
     * for when the pod needs a feature only available to the host user namespace, such as
     * loading a kernel module with CAP_SYS_MODULE.
     * When set to false, a new userns is created for the pod. Setting false is useful for
     * mitigating container breakout vulnerabilities even allowing users to run their
     * containers as root without actually having root privileges on the host.
     * This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.
     * +k8s:conversion-gen=false
     * +optional
     * </pre>
     *
     * <code>optional bool host_users = 37 [json_name = "hostUsers"];</code>
     * @return The hostUsers.
     */
    @java.lang.Override
    public boolean getHostUsers() {
      return hostUsers_;
    }

    public static final int RESOURCE_CLAIMS_FIELD_NUMBER = 39;
    @SuppressWarnings("serial")
    private java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim> resourceClaims_;
    /**
     * <pre>
     * ResourceClaims defines which ResourceClaims must be allocated
     * and reserved before the Pod is allowed to start. The resources
     * will be made available to those containers which consume them
     * by name.
     *
     * This is an alpha field and requires enabling the
     * DynamicResourceAllocation feature gate.
     *
     * This field is immutable.
     *
     * +patchMergeKey=name
     * +patchStrategy=merge,retainKeys
     * +listType=map
     * +listMapKey=name
     * +featureGate=DynamicResourceAllocation
     * +optional
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
     */
    @java.lang.Override
    public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim> getResourceClaimsList() {
      return resourceClaims_;
    }
    /**
     * <pre>
     * ResourceClaims defines which ResourceClaims must be allocated
     * and reserved before the Pod is allowed to start. The resources
     * will be made available to those containers which consume them
     * by name.
     *
     * This is an alpha field and requires enabling the
     * DynamicResourceAllocation feature gate.
     *
     * This field is immutable.
     *
     * +patchMergeKey=name
     * +patchStrategy=merge,retainKeys
     * +listType=map
     * +listMapKey=name
     * +featureGate=DynamicResourceAllocation
     * +optional
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
     */
    @java.lang.Override
    public java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaimOrBuilder> 
        getResourceClaimsOrBuilderList() {
      return resourceClaims_;
    }
    /**
     * <pre>
     * ResourceClaims defines which ResourceClaims must be allocated
     * and reserved before the Pod is allowed to start. The resources
     * will be made available to those containers which consume them
     * by name.
     *
     * This is an alpha field and requires enabling the
     * DynamicResourceAllocation feature gate.
     *
     * This field is immutable.
     *
     * +patchMergeKey=name
     * +patchStrategy=merge,retainKeys
     * +listType=map
     * +listMapKey=name
     * +featureGate=DynamicResourceAllocation
     * +optional
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
     */
    @java.lang.Override
    public int getResourceClaimsCount() {
      return resourceClaims_.size();
    }
    /**
     * <pre>
     * ResourceClaims defines which ResourceClaims must be allocated
     * and reserved before the Pod is allowed to start. The resources
     * will be made available to those containers which consume them
     * by name.
     *
     * This is an alpha field and requires enabling the
     * DynamicResourceAllocation feature gate.
     *
     * This field is immutable.
     *
     * +patchMergeKey=name
     * +patchStrategy=merge,retainKeys
     * +listType=map
     * +listMapKey=name
     * +featureGate=DynamicResourceAllocation
     * +optional
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim getResourceClaims(int index) {
      return resourceClaims_.get(index);
    }
    /**
     * <pre>
     * ResourceClaims defines which ResourceClaims must be allocated
     * and reserved before the Pod is allowed to start. The resources
     * will be made available to those containers which consume them
     * by name.
     *
     * This is an alpha field and requires enabling the
     * DynamicResourceAllocation feature gate.
     *
     * This field is immutable.
     *
     * +patchMergeKey=name
     * +patchStrategy=merge,retainKeys
     * +listType=map
     * +listMapKey=name
     * +featureGate=DynamicResourceAllocation
     * +optional
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaimOrBuilder getResourceClaimsOrBuilder(
        int index) {
      return resourceClaims_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < volumes_.size(); i++) {
        output.writeMessage(1, volumes_.get(i));
      }
      for (int i = 0; i < containers_.size(); i++) {
        output.writeMessage(2, containers_.get(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, restartPolicy_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt64(4, terminationGracePeriodSeconds_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeInt64(5, activeDeadlineSeconds_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 6, dnsPolicy_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetNodeSelector(),
          NodeSelectorDefaultEntryHolder.defaultEntry,
          7);
      if (((bitField0_ & 0x00000010) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 8, serviceAccountName_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 10, nodeName_);
      }
      if (hostNetwork_ != false) {
        output.writeBool(11, hostNetwork_);
      }
      if (hostPid_ != false) {
        output.writeBool(12, hostPid_);
      }
      if (hostIpc_ != false) {
        output.writeBool(13, hostIpc_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 16, hostname_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 17, subdomain_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 19, schedulerName_);
      }
      for (int i = 0; i < initContainers_.size(); i++) {
        output.writeMessage(20, initContainers_.get(i));
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeBool(21, automountServiceAccountToken_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 24, priorityClassName_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        output.writeInt32(25, priority_);
      }
      if (shareProcessNamespace_ != false) {
        output.writeBool(27, shareProcessNamespace_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 29, runtimeClassName_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        output.writeBool(30, enableServiceLinks_);
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 31, preemptionPolicy_);
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        output.writeBool(37, hostUsers_);
      }
      for (int i = 0; i < resourceClaims_.size(); i++) {
        output.writeMessage(39, resourceClaims_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < volumes_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, volumes_.get(i));
      }
      for (int i = 0; i < containers_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, containers_.get(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, restartPolicy_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(4, terminationGracePeriodSeconds_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(5, activeDeadlineSeconds_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, dnsPolicy_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetNodeSelector().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        nodeSelector__ = NodeSelectorDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(7, nodeSelector__);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(8, serviceAccountName_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(10, nodeName_);
      }
      if (hostNetwork_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(11, hostNetwork_);
      }
      if (hostPid_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(12, hostPid_);
      }
      if (hostIpc_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(13, hostIpc_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(16, hostname_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(17, subdomain_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(19, schedulerName_);
      }
      for (int i = 0; i < initContainers_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(20, initContainers_.get(i));
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(21, automountServiceAccountToken_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(24, priorityClassName_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(25, priority_);
      }
      if (shareProcessNamespace_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(27, shareProcessNamespace_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(29, runtimeClassName_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(30, enableServiceLinks_);
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(31, preemptionPolicy_);
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(37, hostUsers_);
      }
      for (int i = 0; i < resourceClaims_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(39, resourceClaims_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec)) {
        return super.equals(obj);
      }
      ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec other = (ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec) obj;

      if (!getVolumesList()
          .equals(other.getVolumesList())) return false;
      if (!getInitContainersList()
          .equals(other.getInitContainersList())) return false;
      if (!getContainersList()
          .equals(other.getContainersList())) return false;
      if (hasRestartPolicy() != other.hasRestartPolicy()) return false;
      if (hasRestartPolicy()) {
        if (!getRestartPolicy()
            .equals(other.getRestartPolicy())) return false;
      }
      if (hasTerminationGracePeriodSeconds() != other.hasTerminationGracePeriodSeconds()) return false;
      if (hasTerminationGracePeriodSeconds()) {
        if (getTerminationGracePeriodSeconds()
            != other.getTerminationGracePeriodSeconds()) return false;
      }
      if (hasActiveDeadlineSeconds() != other.hasActiveDeadlineSeconds()) return false;
      if (hasActiveDeadlineSeconds()) {
        if (getActiveDeadlineSeconds()
            != other.getActiveDeadlineSeconds()) return false;
      }
      if (hasDnsPolicy() != other.hasDnsPolicy()) return false;
      if (hasDnsPolicy()) {
        if (!getDnsPolicy()
            .equals(other.getDnsPolicy())) return false;
      }
      if (!internalGetNodeSelector().equals(
          other.internalGetNodeSelector())) return false;
      if (hasServiceAccountName() != other.hasServiceAccountName()) return false;
      if (hasServiceAccountName()) {
        if (!getServiceAccountName()
            .equals(other.getServiceAccountName())) return false;
      }
      if (hasAutomountServiceAccountToken() != other.hasAutomountServiceAccountToken()) return false;
      if (hasAutomountServiceAccountToken()) {
        if (getAutomountServiceAccountToken()
            != other.getAutomountServiceAccountToken()) return false;
      }
      if (hasNodeName() != other.hasNodeName()) return false;
      if (hasNodeName()) {
        if (!getNodeName()
            .equals(other.getNodeName())) return false;
      }
      if (getHostNetwork()
          != other.getHostNetwork()) return false;
      if (getHostPid()
          != other.getHostPid()) return false;
      if (getHostIpc()
          != other.getHostIpc()) return false;
      if (getShareProcessNamespace()
          != other.getShareProcessNamespace()) return false;
      if (hasHostname() != other.hasHostname()) return false;
      if (hasHostname()) {
        if (!getHostname()
            .equals(other.getHostname())) return false;
      }
      if (hasSubdomain() != other.hasSubdomain()) return false;
      if (hasSubdomain()) {
        if (!getSubdomain()
            .equals(other.getSubdomain())) return false;
      }
      if (hasSchedulerName() != other.hasSchedulerName()) return false;
      if (hasSchedulerName()) {
        if (!getSchedulerName()
            .equals(other.getSchedulerName())) return false;
      }
      if (hasPriorityClassName() != other.hasPriorityClassName()) return false;
      if (hasPriorityClassName()) {
        if (!getPriorityClassName()
            .equals(other.getPriorityClassName())) return false;
      }
      if (hasPriority() != other.hasPriority()) return false;
      if (hasPriority()) {
        if (getPriority()
            != other.getPriority()) return false;
      }
      if (hasRuntimeClassName() != other.hasRuntimeClassName()) return false;
      if (hasRuntimeClassName()) {
        if (!getRuntimeClassName()
            .equals(other.getRuntimeClassName())) return false;
      }
      if (hasEnableServiceLinks() != other.hasEnableServiceLinks()) return false;
      if (hasEnableServiceLinks()) {
        if (getEnableServiceLinks()
            != other.getEnableServiceLinks()) return false;
      }
      if (hasPreemptionPolicy() != other.hasPreemptionPolicy()) return false;
      if (hasPreemptionPolicy()) {
        if (!getPreemptionPolicy()
            .equals(other.getPreemptionPolicy())) return false;
      }
      if (hasHostUsers() != other.hasHostUsers()) return false;
      if (hasHostUsers()) {
        if (getHostUsers()
            != other.getHostUsers()) return false;
      }
      if (!getResourceClaimsList()
          .equals(other.getResourceClaimsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getVolumesCount() > 0) {
        hash = (37 * hash) + VOLUMES_FIELD_NUMBER;
        hash = (53 * hash) + getVolumesList().hashCode();
      }
      if (getInitContainersCount() > 0) {
        hash = (37 * hash) + INIT_CONTAINERS_FIELD_NUMBER;
        hash = (53 * hash) + getInitContainersList().hashCode();
      }
      if (getContainersCount() > 0) {
        hash = (37 * hash) + CONTAINERS_FIELD_NUMBER;
        hash = (53 * hash) + getContainersList().hashCode();
      }
      if (hasRestartPolicy()) {
        hash = (37 * hash) + RESTART_POLICY_FIELD_NUMBER;
        hash = (53 * hash) + getRestartPolicy().hashCode();
      }
      if (hasTerminationGracePeriodSeconds()) {
        hash = (37 * hash) + TERMINATION_GRACE_PERIOD_SECONDS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getTerminationGracePeriodSeconds());
      }
      if (hasActiveDeadlineSeconds()) {
        hash = (37 * hash) + ACTIVE_DEADLINE_SECONDS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getActiveDeadlineSeconds());
      }
      if (hasDnsPolicy()) {
        hash = (37 * hash) + DNS_POLICY_FIELD_NUMBER;
        hash = (53 * hash) + getDnsPolicy().hashCode();
      }
      if (!internalGetNodeSelector().getMap().isEmpty()) {
        hash = (37 * hash) + NODE_SELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + internalGetNodeSelector().hashCode();
      }
      if (hasServiceAccountName()) {
        hash = (37 * hash) + SERVICE_ACCOUNT_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getServiceAccountName().hashCode();
      }
      if (hasAutomountServiceAccountToken()) {
        hash = (37 * hash) + AUTOMOUNT_SERVICE_ACCOUNT_TOKEN_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getAutomountServiceAccountToken());
      }
      if (hasNodeName()) {
        hash = (37 * hash) + NODE_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getNodeName().hashCode();
      }
      hash = (37 * hash) + HOST_NETWORK_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getHostNetwork());
      hash = (37 * hash) + HOST_PID_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getHostPid());
      hash = (37 * hash) + HOST_IPC_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getHostIpc());
      hash = (37 * hash) + SHARE_PROCESS_NAMESPACE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getShareProcessNamespace());
      if (hasHostname()) {
        hash = (37 * hash) + HOSTNAME_FIELD_NUMBER;
        hash = (53 * hash) + getHostname().hashCode();
      }
      if (hasSubdomain()) {
        hash = (37 * hash) + SUBDOMAIN_FIELD_NUMBER;
        hash = (53 * hash) + getSubdomain().hashCode();
      }
      if (hasSchedulerName()) {
        hash = (37 * hash) + SCHEDULER_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getSchedulerName().hashCode();
      }
      if (hasPriorityClassName()) {
        hash = (37 * hash) + PRIORITY_CLASS_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getPriorityClassName().hashCode();
      }
      if (hasPriority()) {
        hash = (37 * hash) + PRIORITY_FIELD_NUMBER;
        hash = (53 * hash) + getPriority();
      }
      if (hasRuntimeClassName()) {
        hash = (37 * hash) + RUNTIME_CLASS_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getRuntimeClassName().hashCode();
      }
      if (hasEnableServiceLinks()) {
        hash = (37 * hash) + ENABLE_SERVICE_LINKS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getEnableServiceLinks());
      }
      if (hasPreemptionPolicy()) {
        hash = (37 * hash) + PREEMPTION_POLICY_FIELD_NUMBER;
        hash = (53 * hash) + getPreemptionPolicy().hashCode();
      }
      if (hasHostUsers()) {
        hash = (37 * hash) + HOST_USERS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getHostUsers());
      }
      if (getResourceClaimsCount() > 0) {
        hash = (37 * hash) + RESOURCE_CLAIMS_FIELD_NUMBER;
        hash = (53 * hash) + getResourceClaimsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * PodSpec is a description of a pod.
     * </pre>
     *
     * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.PodSpec}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chalk.pubsub.v1.PodStatusPubSub.PodSpec)
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_PodSpec_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
          int number) {
        switch (number) {
          case 7:
            return internalGetNodeSelector();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMutableMapFieldReflection(
          int number) {
        switch (number) {
          case 7:
            return internalGetMutableNodeSelector();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_PodSpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec.Builder.class);
      }

      // Construct using ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (volumesBuilder_ == null) {
          volumes_ = java.util.Collections.emptyList();
        } else {
          volumes_ = null;
          volumesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (initContainersBuilder_ == null) {
          initContainers_ = java.util.Collections.emptyList();
        } else {
          initContainers_ = null;
          initContainersBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (containersBuilder_ == null) {
          containers_ = java.util.Collections.emptyList();
        } else {
          containers_ = null;
          containersBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        restartPolicy_ = "";
        terminationGracePeriodSeconds_ = 0L;
        activeDeadlineSeconds_ = 0L;
        dnsPolicy_ = "";
        internalGetMutableNodeSelector().clear();
        serviceAccountName_ = "";
        automountServiceAccountToken_ = false;
        nodeName_ = "";
        hostNetwork_ = false;
        hostPid_ = false;
        hostIpc_ = false;
        shareProcessNamespace_ = false;
        hostname_ = "";
        subdomain_ = "";
        schedulerName_ = "";
        priorityClassName_ = "";
        priority_ = 0;
        runtimeClassName_ = "";
        enableServiceLinks_ = false;
        preemptionPolicy_ = "";
        hostUsers_ = false;
        if (resourceClaimsBuilder_ == null) {
          resourceClaims_ = java.util.Collections.emptyList();
        } else {
          resourceClaims_ = null;
          resourceClaimsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x01000000);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_PodSpec_descriptor;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec getDefaultInstanceForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec.getDefaultInstance();
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec build() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec buildPartial() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec result = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec result) {
        if (volumesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            volumes_ = java.util.Collections.unmodifiableList(volumes_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.volumes_ = volumes_;
        } else {
          result.volumes_ = volumesBuilder_.build();
        }
        if (initContainersBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            initContainers_ = java.util.Collections.unmodifiableList(initContainers_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.initContainers_ = initContainers_;
        } else {
          result.initContainers_ = initContainersBuilder_.build();
        }
        if (containersBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0)) {
            containers_ = java.util.Collections.unmodifiableList(containers_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.containers_ = containers_;
        } else {
          result.containers_ = containersBuilder_.build();
        }
        if (resourceClaimsBuilder_ == null) {
          if (((bitField0_ & 0x01000000) != 0)) {
            resourceClaims_ = java.util.Collections.unmodifiableList(resourceClaims_);
            bitField0_ = (bitField0_ & ~0x01000000);
          }
          result.resourceClaims_ = resourceClaims_;
        } else {
          result.resourceClaims_ = resourceClaimsBuilder_.build();
        }
      }

      private void buildPartial0(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.restartPolicy_ = restartPolicy_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.terminationGracePeriodSeconds_ = terminationGracePeriodSeconds_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.activeDeadlineSeconds_ = activeDeadlineSeconds_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.dnsPolicy_ = dnsPolicy_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.nodeSelector_ = internalGetNodeSelector();
          result.nodeSelector_.makeImmutable();
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.serviceAccountName_ = serviceAccountName_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.automountServiceAccountToken_ = automountServiceAccountToken_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.nodeName_ = nodeName_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.hostNetwork_ = hostNetwork_;
        }
        if (((from_bitField0_ & 0x00001000) != 0)) {
          result.hostPid_ = hostPid_;
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          result.hostIpc_ = hostIpc_;
        }
        if (((from_bitField0_ & 0x00004000) != 0)) {
          result.shareProcessNamespace_ = shareProcessNamespace_;
        }
        if (((from_bitField0_ & 0x00008000) != 0)) {
          result.hostname_ = hostname_;
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00010000) != 0)) {
          result.subdomain_ = subdomain_;
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00020000) != 0)) {
          result.schedulerName_ = schedulerName_;
          to_bitField0_ |= 0x00000200;
        }
        if (((from_bitField0_ & 0x00040000) != 0)) {
          result.priorityClassName_ = priorityClassName_;
          to_bitField0_ |= 0x00000400;
        }
        if (((from_bitField0_ & 0x00080000) != 0)) {
          result.priority_ = priority_;
          to_bitField0_ |= 0x00000800;
        }
        if (((from_bitField0_ & 0x00100000) != 0)) {
          result.runtimeClassName_ = runtimeClassName_;
          to_bitField0_ |= 0x00001000;
        }
        if (((from_bitField0_ & 0x00200000) != 0)) {
          result.enableServiceLinks_ = enableServiceLinks_;
          to_bitField0_ |= 0x00002000;
        }
        if (((from_bitField0_ & 0x00400000) != 0)) {
          result.preemptionPolicy_ = preemptionPolicy_;
          to_bitField0_ |= 0x00004000;
        }
        if (((from_bitField0_ & 0x00800000) != 0)) {
          result.hostUsers_ = hostUsers_;
          to_bitField0_ |= 0x00008000;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec) {
          return mergeFrom((ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec other) {
        if (other == ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec.getDefaultInstance()) return this;
        if (volumesBuilder_ == null) {
          if (!other.volumes_.isEmpty()) {
            if (volumes_.isEmpty()) {
              volumes_ = other.volumes_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureVolumesIsMutable();
              volumes_.addAll(other.volumes_);
            }
            onChanged();
          }
        } else {
          if (!other.volumes_.isEmpty()) {
            if (volumesBuilder_.isEmpty()) {
              volumesBuilder_.dispose();
              volumesBuilder_ = null;
              volumes_ = other.volumes_;
              bitField0_ = (bitField0_ & ~0x00000001);
              volumesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getVolumesFieldBuilder() : null;
            } else {
              volumesBuilder_.addAllMessages(other.volumes_);
            }
          }
        }
        if (initContainersBuilder_ == null) {
          if (!other.initContainers_.isEmpty()) {
            if (initContainers_.isEmpty()) {
              initContainers_ = other.initContainers_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureInitContainersIsMutable();
              initContainers_.addAll(other.initContainers_);
            }
            onChanged();
          }
        } else {
          if (!other.initContainers_.isEmpty()) {
            if (initContainersBuilder_.isEmpty()) {
              initContainersBuilder_.dispose();
              initContainersBuilder_ = null;
              initContainers_ = other.initContainers_;
              bitField0_ = (bitField0_ & ~0x00000002);
              initContainersBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getInitContainersFieldBuilder() : null;
            } else {
              initContainersBuilder_.addAllMessages(other.initContainers_);
            }
          }
        }
        if (containersBuilder_ == null) {
          if (!other.containers_.isEmpty()) {
            if (containers_.isEmpty()) {
              containers_ = other.containers_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureContainersIsMutable();
              containers_.addAll(other.containers_);
            }
            onChanged();
          }
        } else {
          if (!other.containers_.isEmpty()) {
            if (containersBuilder_.isEmpty()) {
              containersBuilder_.dispose();
              containersBuilder_ = null;
              containers_ = other.containers_;
              bitField0_ = (bitField0_ & ~0x00000004);
              containersBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getContainersFieldBuilder() : null;
            } else {
              containersBuilder_.addAllMessages(other.containers_);
            }
          }
        }
        if (other.hasRestartPolicy()) {
          restartPolicy_ = other.restartPolicy_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (other.hasTerminationGracePeriodSeconds()) {
          setTerminationGracePeriodSeconds(other.getTerminationGracePeriodSeconds());
        }
        if (other.hasActiveDeadlineSeconds()) {
          setActiveDeadlineSeconds(other.getActiveDeadlineSeconds());
        }
        if (other.hasDnsPolicy()) {
          dnsPolicy_ = other.dnsPolicy_;
          bitField0_ |= 0x00000040;
          onChanged();
        }
        internalGetMutableNodeSelector().mergeFrom(
            other.internalGetNodeSelector());
        bitField0_ |= 0x00000080;
        if (other.hasServiceAccountName()) {
          serviceAccountName_ = other.serviceAccountName_;
          bitField0_ |= 0x00000100;
          onChanged();
        }
        if (other.hasAutomountServiceAccountToken()) {
          setAutomountServiceAccountToken(other.getAutomountServiceAccountToken());
        }
        if (other.hasNodeName()) {
          nodeName_ = other.nodeName_;
          bitField0_ |= 0x00000400;
          onChanged();
        }
        if (other.getHostNetwork() != false) {
          setHostNetwork(other.getHostNetwork());
        }
        if (other.getHostPid() != false) {
          setHostPid(other.getHostPid());
        }
        if (other.getHostIpc() != false) {
          setHostIpc(other.getHostIpc());
        }
        if (other.getShareProcessNamespace() != false) {
          setShareProcessNamespace(other.getShareProcessNamespace());
        }
        if (other.hasHostname()) {
          hostname_ = other.hostname_;
          bitField0_ |= 0x00008000;
          onChanged();
        }
        if (other.hasSubdomain()) {
          subdomain_ = other.subdomain_;
          bitField0_ |= 0x00010000;
          onChanged();
        }
        if (other.hasSchedulerName()) {
          schedulerName_ = other.schedulerName_;
          bitField0_ |= 0x00020000;
          onChanged();
        }
        if (other.hasPriorityClassName()) {
          priorityClassName_ = other.priorityClassName_;
          bitField0_ |= 0x00040000;
          onChanged();
        }
        if (other.hasPriority()) {
          setPriority(other.getPriority());
        }
        if (other.hasRuntimeClassName()) {
          runtimeClassName_ = other.runtimeClassName_;
          bitField0_ |= 0x00100000;
          onChanged();
        }
        if (other.hasEnableServiceLinks()) {
          setEnableServiceLinks(other.getEnableServiceLinks());
        }
        if (other.hasPreemptionPolicy()) {
          preemptionPolicy_ = other.preemptionPolicy_;
          bitField0_ |= 0x00400000;
          onChanged();
        }
        if (other.hasHostUsers()) {
          setHostUsers(other.getHostUsers());
        }
        if (resourceClaimsBuilder_ == null) {
          if (!other.resourceClaims_.isEmpty()) {
            if (resourceClaims_.isEmpty()) {
              resourceClaims_ = other.resourceClaims_;
              bitField0_ = (bitField0_ & ~0x01000000);
            } else {
              ensureResourceClaimsIsMutable();
              resourceClaims_.addAll(other.resourceClaims_);
            }
            onChanged();
          }
        } else {
          if (!other.resourceClaims_.isEmpty()) {
            if (resourceClaimsBuilder_.isEmpty()) {
              resourceClaimsBuilder_.dispose();
              resourceClaimsBuilder_ = null;
              resourceClaims_ = other.resourceClaims_;
              bitField0_ = (bitField0_ & ~0x01000000);
              resourceClaimsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getResourceClaimsFieldBuilder() : null;
            } else {
              resourceClaimsBuilder_.addAllMessages(other.resourceClaims_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume m =
                    input.readMessage(
                        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume.parser(),
                        extensionRegistry);
                if (volumesBuilder_ == null) {
                  ensureVolumesIsMutable();
                  volumes_.add(m);
                } else {
                  volumesBuilder_.addMessage(m);
                }
                break;
              } // case 10
              case 18: {
                ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container m =
                    input.readMessage(
                        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.parser(),
                        extensionRegistry);
                if (containersBuilder_ == null) {
                  ensureContainersIsMutable();
                  containers_.add(m);
                } else {
                  containersBuilder_.addMessage(m);
                }
                break;
              } // case 18
              case 26: {
                restartPolicy_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000008;
                break;
              } // case 26
              case 32: {
                terminationGracePeriodSeconds_ = input.readInt64();
                bitField0_ |= 0x00000010;
                break;
              } // case 32
              case 40: {
                activeDeadlineSeconds_ = input.readInt64();
                bitField0_ |= 0x00000020;
                break;
              } // case 40
              case 50: {
                dnsPolicy_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000040;
                break;
              } // case 50
              case 58: {
                com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
                nodeSelector__ = input.readMessage(
                    NodeSelectorDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
                internalGetMutableNodeSelector().getMutableMap().put(
                    nodeSelector__.getKey(), nodeSelector__.getValue());
                bitField0_ |= 0x00000080;
                break;
              } // case 58
              case 66: {
                serviceAccountName_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000100;
                break;
              } // case 66
              case 82: {
                nodeName_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000400;
                break;
              } // case 82
              case 88: {
                hostNetwork_ = input.readBool();
                bitField0_ |= 0x00000800;
                break;
              } // case 88
              case 96: {
                hostPid_ = input.readBool();
                bitField0_ |= 0x00001000;
                break;
              } // case 96
              case 104: {
                hostIpc_ = input.readBool();
                bitField0_ |= 0x00002000;
                break;
              } // case 104
              case 130: {
                hostname_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00008000;
                break;
              } // case 130
              case 138: {
                subdomain_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00010000;
                break;
              } // case 138
              case 154: {
                schedulerName_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00020000;
                break;
              } // case 154
              case 162: {
                ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container m =
                    input.readMessage(
                        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.parser(),
                        extensionRegistry);
                if (initContainersBuilder_ == null) {
                  ensureInitContainersIsMutable();
                  initContainers_.add(m);
                } else {
                  initContainersBuilder_.addMessage(m);
                }
                break;
              } // case 162
              case 168: {
                automountServiceAccountToken_ = input.readBool();
                bitField0_ |= 0x00000200;
                break;
              } // case 168
              case 194: {
                priorityClassName_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00040000;
                break;
              } // case 194
              case 200: {
                priority_ = input.readInt32();
                bitField0_ |= 0x00080000;
                break;
              } // case 200
              case 216: {
                shareProcessNamespace_ = input.readBool();
                bitField0_ |= 0x00004000;
                break;
              } // case 216
              case 234: {
                runtimeClassName_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00100000;
                break;
              } // case 234
              case 240: {
                enableServiceLinks_ = input.readBool();
                bitField0_ |= 0x00200000;
                break;
              } // case 240
              case 250: {
                preemptionPolicy_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00400000;
                break;
              } // case 250
              case 296: {
                hostUsers_ = input.readBool();
                bitField0_ |= 0x00800000;
                break;
              } // case 296
              case 314: {
                ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim m =
                    input.readMessage(
                        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim.parser(),
                        extensionRegistry);
                if (resourceClaimsBuilder_ == null) {
                  ensureResourceClaimsIsMutable();
                  resourceClaims_.add(m);
                } else {
                  resourceClaimsBuilder_.addMessage(m);
                }
                break;
              } // case 314
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume> volumes_ =
        java.util.Collections.emptyList();
      private void ensureVolumesIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          volumes_ = new java.util.ArrayList<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume>(volumes_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.VolumeOrBuilder> volumesBuilder_;

      /**
       * <pre>
       * List of volumes that can be mounted by containers belonging to the pod.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
       */
      public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume> getVolumesList() {
        if (volumesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(volumes_);
        } else {
          return volumesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * List of volumes that can be mounted by containers belonging to the pod.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
       */
      public int getVolumesCount() {
        if (volumesBuilder_ == null) {
          return volumes_.size();
        } else {
          return volumesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * List of volumes that can be mounted by containers belonging to the pod.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume getVolumes(int index) {
        if (volumesBuilder_ == null) {
          return volumes_.get(index);
        } else {
          return volumesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * List of volumes that can be mounted by containers belonging to the pod.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
       */
      public Builder setVolumes(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume value) {
        if (volumesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVolumesIsMutable();
          volumes_.set(index, value);
          onChanged();
        } else {
          volumesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of volumes that can be mounted by containers belonging to the pod.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
       */
      public Builder setVolumes(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume.Builder builderForValue) {
        if (volumesBuilder_ == null) {
          ensureVolumesIsMutable();
          volumes_.set(index, builderForValue.build());
          onChanged();
        } else {
          volumesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of volumes that can be mounted by containers belonging to the pod.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
       */
      public Builder addVolumes(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume value) {
        if (volumesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVolumesIsMutable();
          volumes_.add(value);
          onChanged();
        } else {
          volumesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * List of volumes that can be mounted by containers belonging to the pod.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
       */
      public Builder addVolumes(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume value) {
        if (volumesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVolumesIsMutable();
          volumes_.add(index, value);
          onChanged();
        } else {
          volumesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of volumes that can be mounted by containers belonging to the pod.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
       */
      public Builder addVolumes(
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume.Builder builderForValue) {
        if (volumesBuilder_ == null) {
          ensureVolumesIsMutable();
          volumes_.add(builderForValue.build());
          onChanged();
        } else {
          volumesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of volumes that can be mounted by containers belonging to the pod.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
       */
      public Builder addVolumes(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume.Builder builderForValue) {
        if (volumesBuilder_ == null) {
          ensureVolumesIsMutable();
          volumes_.add(index, builderForValue.build());
          onChanged();
        } else {
          volumesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of volumes that can be mounted by containers belonging to the pod.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
       */
      public Builder addAllVolumes(
          java.lang.Iterable<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume> values) {
        if (volumesBuilder_ == null) {
          ensureVolumesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, volumes_);
          onChanged();
        } else {
          volumesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * List of volumes that can be mounted by containers belonging to the pod.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
       */
      public Builder clearVolumes() {
        if (volumesBuilder_ == null) {
          volumes_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          volumesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * List of volumes that can be mounted by containers belonging to the pod.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
       */
      public Builder removeVolumes(int index) {
        if (volumesBuilder_ == null) {
          ensureVolumesIsMutable();
          volumes_.remove(index);
          onChanged();
        } else {
          volumesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * List of volumes that can be mounted by containers belonging to the pod.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume.Builder getVolumesBuilder(
          int index) {
        return getVolumesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * List of volumes that can be mounted by containers belonging to the pod.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.VolumeOrBuilder getVolumesOrBuilder(
          int index) {
        if (volumesBuilder_ == null) {
          return volumes_.get(index);  } else {
          return volumesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * List of volumes that can be mounted by containers belonging to the pod.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
       */
      public java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.VolumeOrBuilder> 
           getVolumesOrBuilderList() {
        if (volumesBuilder_ != null) {
          return volumesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(volumes_);
        }
      }
      /**
       * <pre>
       * List of volumes that can be mounted by containers belonging to the pod.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume.Builder addVolumesBuilder() {
        return getVolumesFieldBuilder().addBuilder(
            ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume.getDefaultInstance());
      }
      /**
       * <pre>
       * List of volumes that can be mounted by containers belonging to the pod.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume.Builder addVolumesBuilder(
          int index) {
        return getVolumesFieldBuilder().addBuilder(
            index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume.getDefaultInstance());
      }
      /**
       * <pre>
       * List of volumes that can be mounted by containers belonging to the pod.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Volume volumes = 1 [json_name = "volumes"];</code>
       */
      public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume.Builder> 
           getVolumesBuilderList() {
        return getVolumesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.VolumeOrBuilder> 
          getVolumesFieldBuilder() {
        if (volumesBuilder_ == null) {
          volumesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Volume.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.VolumeOrBuilder>(
                  volumes_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          volumes_ = null;
        }
        return volumesBuilder_;
      }

      private java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container> initContainers_ =
        java.util.Collections.emptyList();
      private void ensureInitContainersIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          initContainers_ = new java.util.ArrayList<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container>(initContainers_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerOrBuilder> initContainersBuilder_;

      /**
       * <pre>
       * List of initialization containers belonging to the pod.
       * Init containers are executed in order prior to containers being started. If any
       * init container fails, the pod is considered to have failed and is handled according
       * to its restartPolicy. The name for an init container or normal container must be
       * unique among all containers.
       * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
       * The resourceRequirements of an init container are taken into account during scheduling
       * by finding the highest request/limit for each resource type, and then using the max of
       * of that value or the sum of the normal containers. Limits are applied to init containers
       * in a similar fashion.
       * Init containers cannot currently be added or removed.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
       */
      public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container> getInitContainersList() {
        if (initContainersBuilder_ == null) {
          return java.util.Collections.unmodifiableList(initContainers_);
        } else {
          return initContainersBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * List of initialization containers belonging to the pod.
       * Init containers are executed in order prior to containers being started. If any
       * init container fails, the pod is considered to have failed and is handled according
       * to its restartPolicy. The name for an init container or normal container must be
       * unique among all containers.
       * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
       * The resourceRequirements of an init container are taken into account during scheduling
       * by finding the highest request/limit for each resource type, and then using the max of
       * of that value or the sum of the normal containers. Limits are applied to init containers
       * in a similar fashion.
       * Init containers cannot currently be added or removed.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
       */
      public int getInitContainersCount() {
        if (initContainersBuilder_ == null) {
          return initContainers_.size();
        } else {
          return initContainersBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * List of initialization containers belonging to the pod.
       * Init containers are executed in order prior to containers being started. If any
       * init container fails, the pod is considered to have failed and is handled according
       * to its restartPolicy. The name for an init container or normal container must be
       * unique among all containers.
       * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
       * The resourceRequirements of an init container are taken into account during scheduling
       * by finding the highest request/limit for each resource type, and then using the max of
       * of that value or the sum of the normal containers. Limits are applied to init containers
       * in a similar fashion.
       * Init containers cannot currently be added or removed.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container getInitContainers(int index) {
        if (initContainersBuilder_ == null) {
          return initContainers_.get(index);
        } else {
          return initContainersBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * List of initialization containers belonging to the pod.
       * Init containers are executed in order prior to containers being started. If any
       * init container fails, the pod is considered to have failed and is handled according
       * to its restartPolicy. The name for an init container or normal container must be
       * unique among all containers.
       * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
       * The resourceRequirements of an init container are taken into account during scheduling
       * by finding the highest request/limit for each resource type, and then using the max of
       * of that value or the sum of the normal containers. Limits are applied to init containers
       * in a similar fashion.
       * Init containers cannot currently be added or removed.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
       */
      public Builder setInitContainers(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container value) {
        if (initContainersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInitContainersIsMutable();
          initContainers_.set(index, value);
          onChanged();
        } else {
          initContainersBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of initialization containers belonging to the pod.
       * Init containers are executed in order prior to containers being started. If any
       * init container fails, the pod is considered to have failed and is handled according
       * to its restartPolicy. The name for an init container or normal container must be
       * unique among all containers.
       * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
       * The resourceRequirements of an init container are taken into account during scheduling
       * by finding the highest request/limit for each resource type, and then using the max of
       * of that value or the sum of the normal containers. Limits are applied to init containers
       * in a similar fashion.
       * Init containers cannot currently be added or removed.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
       */
      public Builder setInitContainers(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.Builder builderForValue) {
        if (initContainersBuilder_ == null) {
          ensureInitContainersIsMutable();
          initContainers_.set(index, builderForValue.build());
          onChanged();
        } else {
          initContainersBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of initialization containers belonging to the pod.
       * Init containers are executed in order prior to containers being started. If any
       * init container fails, the pod is considered to have failed and is handled according
       * to its restartPolicy. The name for an init container or normal container must be
       * unique among all containers.
       * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
       * The resourceRequirements of an init container are taken into account during scheduling
       * by finding the highest request/limit for each resource type, and then using the max of
       * of that value or the sum of the normal containers. Limits are applied to init containers
       * in a similar fashion.
       * Init containers cannot currently be added or removed.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
       */
      public Builder addInitContainers(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container value) {
        if (initContainersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInitContainersIsMutable();
          initContainers_.add(value);
          onChanged();
        } else {
          initContainersBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * List of initialization containers belonging to the pod.
       * Init containers are executed in order prior to containers being started. If any
       * init container fails, the pod is considered to have failed and is handled according
       * to its restartPolicy. The name for an init container or normal container must be
       * unique among all containers.
       * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
       * The resourceRequirements of an init container are taken into account during scheduling
       * by finding the highest request/limit for each resource type, and then using the max of
       * of that value or the sum of the normal containers. Limits are applied to init containers
       * in a similar fashion.
       * Init containers cannot currently be added or removed.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
       */
      public Builder addInitContainers(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container value) {
        if (initContainersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInitContainersIsMutable();
          initContainers_.add(index, value);
          onChanged();
        } else {
          initContainersBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of initialization containers belonging to the pod.
       * Init containers are executed in order prior to containers being started. If any
       * init container fails, the pod is considered to have failed and is handled according
       * to its restartPolicy. The name for an init container or normal container must be
       * unique among all containers.
       * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
       * The resourceRequirements of an init container are taken into account during scheduling
       * by finding the highest request/limit for each resource type, and then using the max of
       * of that value or the sum of the normal containers. Limits are applied to init containers
       * in a similar fashion.
       * Init containers cannot currently be added or removed.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
       */
      public Builder addInitContainers(
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.Builder builderForValue) {
        if (initContainersBuilder_ == null) {
          ensureInitContainersIsMutable();
          initContainers_.add(builderForValue.build());
          onChanged();
        } else {
          initContainersBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of initialization containers belonging to the pod.
       * Init containers are executed in order prior to containers being started. If any
       * init container fails, the pod is considered to have failed and is handled according
       * to its restartPolicy. The name for an init container or normal container must be
       * unique among all containers.
       * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
       * The resourceRequirements of an init container are taken into account during scheduling
       * by finding the highest request/limit for each resource type, and then using the max of
       * of that value or the sum of the normal containers. Limits are applied to init containers
       * in a similar fashion.
       * Init containers cannot currently be added or removed.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
       */
      public Builder addInitContainers(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.Builder builderForValue) {
        if (initContainersBuilder_ == null) {
          ensureInitContainersIsMutable();
          initContainers_.add(index, builderForValue.build());
          onChanged();
        } else {
          initContainersBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of initialization containers belonging to the pod.
       * Init containers are executed in order prior to containers being started. If any
       * init container fails, the pod is considered to have failed and is handled according
       * to its restartPolicy. The name for an init container or normal container must be
       * unique among all containers.
       * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
       * The resourceRequirements of an init container are taken into account during scheduling
       * by finding the highest request/limit for each resource type, and then using the max of
       * of that value or the sum of the normal containers. Limits are applied to init containers
       * in a similar fashion.
       * Init containers cannot currently be added or removed.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
       */
      public Builder addAllInitContainers(
          java.lang.Iterable<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container> values) {
        if (initContainersBuilder_ == null) {
          ensureInitContainersIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, initContainers_);
          onChanged();
        } else {
          initContainersBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * List of initialization containers belonging to the pod.
       * Init containers are executed in order prior to containers being started. If any
       * init container fails, the pod is considered to have failed and is handled according
       * to its restartPolicy. The name for an init container or normal container must be
       * unique among all containers.
       * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
       * The resourceRequirements of an init container are taken into account during scheduling
       * by finding the highest request/limit for each resource type, and then using the max of
       * of that value or the sum of the normal containers. Limits are applied to init containers
       * in a similar fashion.
       * Init containers cannot currently be added or removed.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
       */
      public Builder clearInitContainers() {
        if (initContainersBuilder_ == null) {
          initContainers_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          initContainersBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * List of initialization containers belonging to the pod.
       * Init containers are executed in order prior to containers being started. If any
       * init container fails, the pod is considered to have failed and is handled according
       * to its restartPolicy. The name for an init container or normal container must be
       * unique among all containers.
       * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
       * The resourceRequirements of an init container are taken into account during scheduling
       * by finding the highest request/limit for each resource type, and then using the max of
       * of that value or the sum of the normal containers. Limits are applied to init containers
       * in a similar fashion.
       * Init containers cannot currently be added or removed.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
       */
      public Builder removeInitContainers(int index) {
        if (initContainersBuilder_ == null) {
          ensureInitContainersIsMutable();
          initContainers_.remove(index);
          onChanged();
        } else {
          initContainersBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * List of initialization containers belonging to the pod.
       * Init containers are executed in order prior to containers being started. If any
       * init container fails, the pod is considered to have failed and is handled according
       * to its restartPolicy. The name for an init container or normal container must be
       * unique among all containers.
       * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
       * The resourceRequirements of an init container are taken into account during scheduling
       * by finding the highest request/limit for each resource type, and then using the max of
       * of that value or the sum of the normal containers. Limits are applied to init containers
       * in a similar fashion.
       * Init containers cannot currently be added or removed.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.Builder getInitContainersBuilder(
          int index) {
        return getInitContainersFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * List of initialization containers belonging to the pod.
       * Init containers are executed in order prior to containers being started. If any
       * init container fails, the pod is considered to have failed and is handled according
       * to its restartPolicy. The name for an init container or normal container must be
       * unique among all containers.
       * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
       * The resourceRequirements of an init container are taken into account during scheduling
       * by finding the highest request/limit for each resource type, and then using the max of
       * of that value or the sum of the normal containers. Limits are applied to init containers
       * in a similar fashion.
       * Init containers cannot currently be added or removed.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerOrBuilder getInitContainersOrBuilder(
          int index) {
        if (initContainersBuilder_ == null) {
          return initContainers_.get(index);  } else {
          return initContainersBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * List of initialization containers belonging to the pod.
       * Init containers are executed in order prior to containers being started. If any
       * init container fails, the pod is considered to have failed and is handled according
       * to its restartPolicy. The name for an init container or normal container must be
       * unique among all containers.
       * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
       * The resourceRequirements of an init container are taken into account during scheduling
       * by finding the highest request/limit for each resource type, and then using the max of
       * of that value or the sum of the normal containers. Limits are applied to init containers
       * in a similar fashion.
       * Init containers cannot currently be added or removed.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
       */
      public java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerOrBuilder> 
           getInitContainersOrBuilderList() {
        if (initContainersBuilder_ != null) {
          return initContainersBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(initContainers_);
        }
      }
      /**
       * <pre>
       * List of initialization containers belonging to the pod.
       * Init containers are executed in order prior to containers being started. If any
       * init container fails, the pod is considered to have failed and is handled according
       * to its restartPolicy. The name for an init container or normal container must be
       * unique among all containers.
       * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
       * The resourceRequirements of an init container are taken into account during scheduling
       * by finding the highest request/limit for each resource type, and then using the max of
       * of that value or the sum of the normal containers. Limits are applied to init containers
       * in a similar fashion.
       * Init containers cannot currently be added or removed.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.Builder addInitContainersBuilder() {
        return getInitContainersFieldBuilder().addBuilder(
            ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.getDefaultInstance());
      }
      /**
       * <pre>
       * List of initialization containers belonging to the pod.
       * Init containers are executed in order prior to containers being started. If any
       * init container fails, the pod is considered to have failed and is handled according
       * to its restartPolicy. The name for an init container or normal container must be
       * unique among all containers.
       * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
       * The resourceRequirements of an init container are taken into account during scheduling
       * by finding the highest request/limit for each resource type, and then using the max of
       * of that value or the sum of the normal containers. Limits are applied to init containers
       * in a similar fashion.
       * Init containers cannot currently be added or removed.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.Builder addInitContainersBuilder(
          int index) {
        return getInitContainersFieldBuilder().addBuilder(
            index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.getDefaultInstance());
      }
      /**
       * <pre>
       * List of initialization containers belonging to the pod.
       * Init containers are executed in order prior to containers being started. If any
       * init container fails, the pod is considered to have failed and is handled according
       * to its restartPolicy. The name for an init container or normal container must be
       * unique among all containers.
       * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
       * The resourceRequirements of an init container are taken into account during scheduling
       * by finding the highest request/limit for each resource type, and then using the max of
       * of that value or the sum of the normal containers. Limits are applied to init containers
       * in a similar fashion.
       * Init containers cannot currently be added or removed.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container init_containers = 20 [json_name = "initContainers"];</code>
       */
      public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.Builder> 
           getInitContainersBuilderList() {
        return getInitContainersFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerOrBuilder> 
          getInitContainersFieldBuilder() {
        if (initContainersBuilder_ == null) {
          initContainersBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerOrBuilder>(
                  initContainers_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          initContainers_ = null;
        }
        return initContainersBuilder_;
      }

      private java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container> containers_ =
        java.util.Collections.emptyList();
      private void ensureContainersIsMutable() {
        if (!((bitField0_ & 0x00000004) != 0)) {
          containers_ = new java.util.ArrayList<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container>(containers_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerOrBuilder> containersBuilder_;

      /**
       * <pre>
       * List of containers belonging to the pod.
       * Containers cannot currently be added or removed.
       * There must be at least one container in a Pod.
       * Cannot be updated.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
       */
      public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container> getContainersList() {
        if (containersBuilder_ == null) {
          return java.util.Collections.unmodifiableList(containers_);
        } else {
          return containersBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * List of containers belonging to the pod.
       * Containers cannot currently be added or removed.
       * There must be at least one container in a Pod.
       * Cannot be updated.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
       */
      public int getContainersCount() {
        if (containersBuilder_ == null) {
          return containers_.size();
        } else {
          return containersBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * List of containers belonging to the pod.
       * Containers cannot currently be added or removed.
       * There must be at least one container in a Pod.
       * Cannot be updated.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container getContainers(int index) {
        if (containersBuilder_ == null) {
          return containers_.get(index);
        } else {
          return containersBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * List of containers belonging to the pod.
       * Containers cannot currently be added or removed.
       * There must be at least one container in a Pod.
       * Cannot be updated.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
       */
      public Builder setContainers(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container value) {
        if (containersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureContainersIsMutable();
          containers_.set(index, value);
          onChanged();
        } else {
          containersBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of containers belonging to the pod.
       * Containers cannot currently be added or removed.
       * There must be at least one container in a Pod.
       * Cannot be updated.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
       */
      public Builder setContainers(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.Builder builderForValue) {
        if (containersBuilder_ == null) {
          ensureContainersIsMutable();
          containers_.set(index, builderForValue.build());
          onChanged();
        } else {
          containersBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of containers belonging to the pod.
       * Containers cannot currently be added or removed.
       * There must be at least one container in a Pod.
       * Cannot be updated.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
       */
      public Builder addContainers(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container value) {
        if (containersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureContainersIsMutable();
          containers_.add(value);
          onChanged();
        } else {
          containersBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * List of containers belonging to the pod.
       * Containers cannot currently be added or removed.
       * There must be at least one container in a Pod.
       * Cannot be updated.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
       */
      public Builder addContainers(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container value) {
        if (containersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureContainersIsMutable();
          containers_.add(index, value);
          onChanged();
        } else {
          containersBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of containers belonging to the pod.
       * Containers cannot currently be added or removed.
       * There must be at least one container in a Pod.
       * Cannot be updated.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
       */
      public Builder addContainers(
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.Builder builderForValue) {
        if (containersBuilder_ == null) {
          ensureContainersIsMutable();
          containers_.add(builderForValue.build());
          onChanged();
        } else {
          containersBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of containers belonging to the pod.
       * Containers cannot currently be added or removed.
       * There must be at least one container in a Pod.
       * Cannot be updated.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
       */
      public Builder addContainers(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.Builder builderForValue) {
        if (containersBuilder_ == null) {
          ensureContainersIsMutable();
          containers_.add(index, builderForValue.build());
          onChanged();
        } else {
          containersBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of containers belonging to the pod.
       * Containers cannot currently be added or removed.
       * There must be at least one container in a Pod.
       * Cannot be updated.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
       */
      public Builder addAllContainers(
          java.lang.Iterable<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container> values) {
        if (containersBuilder_ == null) {
          ensureContainersIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, containers_);
          onChanged();
        } else {
          containersBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * List of containers belonging to the pod.
       * Containers cannot currently be added or removed.
       * There must be at least one container in a Pod.
       * Cannot be updated.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
       */
      public Builder clearContainers() {
        if (containersBuilder_ == null) {
          containers_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          containersBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * List of containers belonging to the pod.
       * Containers cannot currently be added or removed.
       * There must be at least one container in a Pod.
       * Cannot be updated.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
       */
      public Builder removeContainers(int index) {
        if (containersBuilder_ == null) {
          ensureContainersIsMutable();
          containers_.remove(index);
          onChanged();
        } else {
          containersBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * List of containers belonging to the pod.
       * Containers cannot currently be added or removed.
       * There must be at least one container in a Pod.
       * Cannot be updated.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.Builder getContainersBuilder(
          int index) {
        return getContainersFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * List of containers belonging to the pod.
       * Containers cannot currently be added or removed.
       * There must be at least one container in a Pod.
       * Cannot be updated.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerOrBuilder getContainersOrBuilder(
          int index) {
        if (containersBuilder_ == null) {
          return containers_.get(index);  } else {
          return containersBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * List of containers belonging to the pod.
       * Containers cannot currently be added or removed.
       * There must be at least one container in a Pod.
       * Cannot be updated.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
       */
      public java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerOrBuilder> 
           getContainersOrBuilderList() {
        if (containersBuilder_ != null) {
          return containersBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(containers_);
        }
      }
      /**
       * <pre>
       * List of containers belonging to the pod.
       * Containers cannot currently be added or removed.
       * There must be at least one container in a Pod.
       * Cannot be updated.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.Builder addContainersBuilder() {
        return getContainersFieldBuilder().addBuilder(
            ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.getDefaultInstance());
      }
      /**
       * <pre>
       * List of containers belonging to the pod.
       * Containers cannot currently be added or removed.
       * There must be at least one container in a Pod.
       * Cannot be updated.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.Builder addContainersBuilder(
          int index) {
        return getContainersFieldBuilder().addBuilder(
            index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.getDefaultInstance());
      }
      /**
       * <pre>
       * List of containers belonging to the pod.
       * Containers cannot currently be added or removed.
       * There must be at least one container in a Pod.
       * Cannot be updated.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.Container containers = 2 [json_name = "containers"];</code>
       */
      public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.Builder> 
           getContainersBuilderList() {
        return getContainersFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerOrBuilder> 
          getContainersFieldBuilder() {
        if (containersBuilder_ == null) {
          containersBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerOrBuilder>(
                  containers_,
                  ((bitField0_ & 0x00000004) != 0),
                  getParentForChildren(),
                  isClean());
          containers_ = null;
        }
        return containersBuilder_;
      }

      private java.lang.Object restartPolicy_ = "";
      /**
       * <pre>
       * Restart policy for all containers within the pod.
       * One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted.
       * Default to Always.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
       * +optional
       * </pre>
       *
       * <code>optional string restart_policy = 3 [json_name = "restartPolicy"];</code>
       * @return Whether the restartPolicy field is set.
       */
      public boolean hasRestartPolicy() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Restart policy for all containers within the pod.
       * One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted.
       * Default to Always.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
       * +optional
       * </pre>
       *
       * <code>optional string restart_policy = 3 [json_name = "restartPolicy"];</code>
       * @return The restartPolicy.
       */
      public java.lang.String getRestartPolicy() {
        java.lang.Object ref = restartPolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          restartPolicy_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Restart policy for all containers within the pod.
       * One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted.
       * Default to Always.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
       * +optional
       * </pre>
       *
       * <code>optional string restart_policy = 3 [json_name = "restartPolicy"];</code>
       * @return The bytes for restartPolicy.
       */
      public com.google.protobuf.ByteString
          getRestartPolicyBytes() {
        java.lang.Object ref = restartPolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          restartPolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Restart policy for all containers within the pod.
       * One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted.
       * Default to Always.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
       * +optional
       * </pre>
       *
       * <code>optional string restart_policy = 3 [json_name = "restartPolicy"];</code>
       * @param value The restartPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setRestartPolicy(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        restartPolicy_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Restart policy for all containers within the pod.
       * One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted.
       * Default to Always.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
       * +optional
       * </pre>
       *
       * <code>optional string restart_policy = 3 [json_name = "restartPolicy"];</code>
       * @return This builder for chaining.
       */
      public Builder clearRestartPolicy() {
        restartPolicy_ = getDefaultInstance().getRestartPolicy();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Restart policy for all containers within the pod.
       * One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted.
       * Default to Always.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
       * +optional
       * </pre>
       *
       * <code>optional string restart_policy = 3 [json_name = "restartPolicy"];</code>
       * @param value The bytes for restartPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setRestartPolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        restartPolicy_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private long terminationGracePeriodSeconds_ ;
      /**
       * <pre>
       * Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
       * Value must be non-negative integer. The value zero indicates stop immediately via
       * the kill signal (no opportunity to shut down).
       * If this value is nil, the default grace period will be used instead.
       * The grace period is the duration in seconds after the processes running in the pod are sent
       * a termination signal and the time when the processes are forcibly halted with a kill signal.
       * Set this value longer than the expected cleanup time for your process.
       * Defaults to 30 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int64 termination_grace_period_seconds = 4 [json_name = "terminationGracePeriodSeconds"];</code>
       * @return Whether the terminationGracePeriodSeconds field is set.
       */
      @java.lang.Override
      public boolean hasTerminationGracePeriodSeconds() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
       * Value must be non-negative integer. The value zero indicates stop immediately via
       * the kill signal (no opportunity to shut down).
       * If this value is nil, the default grace period will be used instead.
       * The grace period is the duration in seconds after the processes running in the pod are sent
       * a termination signal and the time when the processes are forcibly halted with a kill signal.
       * Set this value longer than the expected cleanup time for your process.
       * Defaults to 30 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int64 termination_grace_period_seconds = 4 [json_name = "terminationGracePeriodSeconds"];</code>
       * @return The terminationGracePeriodSeconds.
       */
      @java.lang.Override
      public long getTerminationGracePeriodSeconds() {
        return terminationGracePeriodSeconds_;
      }
      /**
       * <pre>
       * Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
       * Value must be non-negative integer. The value zero indicates stop immediately via
       * the kill signal (no opportunity to shut down).
       * If this value is nil, the default grace period will be used instead.
       * The grace period is the duration in seconds after the processes running in the pod are sent
       * a termination signal and the time when the processes are forcibly halted with a kill signal.
       * Set this value longer than the expected cleanup time for your process.
       * Defaults to 30 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int64 termination_grace_period_seconds = 4 [json_name = "terminationGracePeriodSeconds"];</code>
       * @param value The terminationGracePeriodSeconds to set.
       * @return This builder for chaining.
       */
      public Builder setTerminationGracePeriodSeconds(long value) {

        terminationGracePeriodSeconds_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
       * Value must be non-negative integer. The value zero indicates stop immediately via
       * the kill signal (no opportunity to shut down).
       * If this value is nil, the default grace period will be used instead.
       * The grace period is the duration in seconds after the processes running in the pod are sent
       * a termination signal and the time when the processes are forcibly halted with a kill signal.
       * Set this value longer than the expected cleanup time for your process.
       * Defaults to 30 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int64 termination_grace_period_seconds = 4 [json_name = "terminationGracePeriodSeconds"];</code>
       * @return This builder for chaining.
       */
      public Builder clearTerminationGracePeriodSeconds() {
        bitField0_ = (bitField0_ & ~0x00000010);
        terminationGracePeriodSeconds_ = 0L;
        onChanged();
        return this;
      }

      private long activeDeadlineSeconds_ ;
      /**
       * <pre>
       * Optional duration in seconds the pod may be active on the node relative to
       * start_time before the system will actively try to mark it failed and kill associated containers.
       * Value must be a positive integer.
       * +optional
       * </pre>
       *
       * <code>optional int64 active_deadline_seconds = 5 [json_name = "activeDeadlineSeconds"];</code>
       * @return Whether the activeDeadlineSeconds field is set.
       */
      @java.lang.Override
      public boolean hasActiveDeadlineSeconds() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Optional duration in seconds the pod may be active on the node relative to
       * start_time before the system will actively try to mark it failed and kill associated containers.
       * Value must be a positive integer.
       * +optional
       * </pre>
       *
       * <code>optional int64 active_deadline_seconds = 5 [json_name = "activeDeadlineSeconds"];</code>
       * @return The activeDeadlineSeconds.
       */
      @java.lang.Override
      public long getActiveDeadlineSeconds() {
        return activeDeadlineSeconds_;
      }
      /**
       * <pre>
       * Optional duration in seconds the pod may be active on the node relative to
       * start_time before the system will actively try to mark it failed and kill associated containers.
       * Value must be a positive integer.
       * +optional
       * </pre>
       *
       * <code>optional int64 active_deadline_seconds = 5 [json_name = "activeDeadlineSeconds"];</code>
       * @param value The activeDeadlineSeconds to set.
       * @return This builder for chaining.
       */
      public Builder setActiveDeadlineSeconds(long value) {

        activeDeadlineSeconds_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optional duration in seconds the pod may be active on the node relative to
       * start_time before the system will actively try to mark it failed and kill associated containers.
       * Value must be a positive integer.
       * +optional
       * </pre>
       *
       * <code>optional int64 active_deadline_seconds = 5 [json_name = "activeDeadlineSeconds"];</code>
       * @return This builder for chaining.
       */
      public Builder clearActiveDeadlineSeconds() {
        bitField0_ = (bitField0_ & ~0x00000020);
        activeDeadlineSeconds_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object dnsPolicy_ = "";
      /**
       * <pre>
       * Set DNS policy for the pod.
       * Defaults to "ClusterFirst".
       * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
       * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
       * To have DNS options set along with hostNetwork, you have to specify DNS policy
       * explicitly to 'ClusterFirstWithHostNet'.
       * +optional
       * </pre>
       *
       * <code>optional string dns_policy = 6 [json_name = "dnsPolicy"];</code>
       * @return Whether the dnsPolicy field is set.
       */
      public boolean hasDnsPolicy() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Set DNS policy for the pod.
       * Defaults to "ClusterFirst".
       * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
       * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
       * To have DNS options set along with hostNetwork, you have to specify DNS policy
       * explicitly to 'ClusterFirstWithHostNet'.
       * +optional
       * </pre>
       *
       * <code>optional string dns_policy = 6 [json_name = "dnsPolicy"];</code>
       * @return The dnsPolicy.
       */
      public java.lang.String getDnsPolicy() {
        java.lang.Object ref = dnsPolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          dnsPolicy_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Set DNS policy for the pod.
       * Defaults to "ClusterFirst".
       * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
       * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
       * To have DNS options set along with hostNetwork, you have to specify DNS policy
       * explicitly to 'ClusterFirstWithHostNet'.
       * +optional
       * </pre>
       *
       * <code>optional string dns_policy = 6 [json_name = "dnsPolicy"];</code>
       * @return The bytes for dnsPolicy.
       */
      public com.google.protobuf.ByteString
          getDnsPolicyBytes() {
        java.lang.Object ref = dnsPolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          dnsPolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Set DNS policy for the pod.
       * Defaults to "ClusterFirst".
       * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
       * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
       * To have DNS options set along with hostNetwork, you have to specify DNS policy
       * explicitly to 'ClusterFirstWithHostNet'.
       * +optional
       * </pre>
       *
       * <code>optional string dns_policy = 6 [json_name = "dnsPolicy"];</code>
       * @param value The dnsPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setDnsPolicy(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        dnsPolicy_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Set DNS policy for the pod.
       * Defaults to "ClusterFirst".
       * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
       * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
       * To have DNS options set along with hostNetwork, you have to specify DNS policy
       * explicitly to 'ClusterFirstWithHostNet'.
       * +optional
       * </pre>
       *
       * <code>optional string dns_policy = 6 [json_name = "dnsPolicy"];</code>
       * @return This builder for chaining.
       */
      public Builder clearDnsPolicy() {
        dnsPolicy_ = getDefaultInstance().getDnsPolicy();
        bitField0_ = (bitField0_ & ~0x00000040);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Set DNS policy for the pod.
       * Defaults to "ClusterFirst".
       * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
       * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
       * To have DNS options set along with hostNetwork, you have to specify DNS policy
       * explicitly to 'ClusterFirstWithHostNet'.
       * +optional
       * </pre>
       *
       * <code>optional string dns_policy = 6 [json_name = "dnsPolicy"];</code>
       * @param value The bytes for dnsPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setDnsPolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        dnsPolicy_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> nodeSelector_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
          internalGetNodeSelector() {
        if (nodeSelector_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              NodeSelectorDefaultEntryHolder.defaultEntry);
        }
        return nodeSelector_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
          internalGetMutableNodeSelector() {
        if (nodeSelector_ == null) {
          nodeSelector_ = com.google.protobuf.MapField.newMapField(
              NodeSelectorDefaultEntryHolder.defaultEntry);
        }
        if (!nodeSelector_.isMutable()) {
          nodeSelector_ = nodeSelector_.copy();
        }
        bitField0_ |= 0x00000080;
        onChanged();
        return nodeSelector_;
      }
      public int getNodeSelectorCount() {
        return internalGetNodeSelector().getMap().size();
      }
      /**
       * <pre>
       * NodeSelector is a selector which must be true for the pod to fit on a node.
       * Selector which must match a node's labels for the pod to be scheduled on that node.
       * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
       * +optional
       * +mapType=atomic
       * </pre>
       *
       * <code>map&lt;string, string&gt; node_selector = 7 [json_name = "nodeSelector"];</code>
       */
      @java.lang.Override
      public boolean containsNodeSelector(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        return internalGetNodeSelector().getMap().containsKey(key);
      }
      /**
       * Use {@link #getNodeSelectorMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getNodeSelector() {
        return getNodeSelectorMap();
      }
      /**
       * <pre>
       * NodeSelector is a selector which must be true for the pod to fit on a node.
       * Selector which must match a node's labels for the pod to be scheduled on that node.
       * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
       * +optional
       * +mapType=atomic
       * </pre>
       *
       * <code>map&lt;string, string&gt; node_selector = 7 [json_name = "nodeSelector"];</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, java.lang.String> getNodeSelectorMap() {
        return internalGetNodeSelector().getMap();
      }
      /**
       * <pre>
       * NodeSelector is a selector which must be true for the pod to fit on a node.
       * Selector which must match a node's labels for the pod to be scheduled on that node.
       * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
       * +optional
       * +mapType=atomic
       * </pre>
       *
       * <code>map&lt;string, string&gt; node_selector = 7 [json_name = "nodeSelector"];</code>
       */
      @java.lang.Override
      public /* nullable */
java.lang.String getNodeSelectorOrDefault(
          java.lang.String key,
          /* nullable */
java.lang.String defaultValue) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetNodeSelector().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * NodeSelector is a selector which must be true for the pod to fit on a node.
       * Selector which must match a node's labels for the pod to be scheduled on that node.
       * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
       * +optional
       * +mapType=atomic
       * </pre>
       *
       * <code>map&lt;string, string&gt; node_selector = 7 [json_name = "nodeSelector"];</code>
       */
      @java.lang.Override
      public java.lang.String getNodeSelectorOrThrow(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetNodeSelector().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      public Builder clearNodeSelector() {
        bitField0_ = (bitField0_ & ~0x00000080);
        internalGetMutableNodeSelector().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * NodeSelector is a selector which must be true for the pod to fit on a node.
       * Selector which must match a node's labels for the pod to be scheduled on that node.
       * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
       * +optional
       * +mapType=atomic
       * </pre>
       *
       * <code>map&lt;string, string&gt; node_selector = 7 [json_name = "nodeSelector"];</code>
       */
      public Builder removeNodeSelector(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        internalGetMutableNodeSelector().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
          getMutableNodeSelector() {
        bitField0_ |= 0x00000080;
        return internalGetMutableNodeSelector().getMutableMap();
      }
      /**
       * <pre>
       * NodeSelector is a selector which must be true for the pod to fit on a node.
       * Selector which must match a node's labels for the pod to be scheduled on that node.
       * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
       * +optional
       * +mapType=atomic
       * </pre>
       *
       * <code>map&lt;string, string&gt; node_selector = 7 [json_name = "nodeSelector"];</code>
       */
      public Builder putNodeSelector(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new NullPointerException("map key"); }
        if (value == null) { throw new NullPointerException("map value"); }
        internalGetMutableNodeSelector().getMutableMap()
            .put(key, value);
        bitField0_ |= 0x00000080;
        return this;
      }
      /**
       * <pre>
       * NodeSelector is a selector which must be true for the pod to fit on a node.
       * Selector which must match a node's labels for the pod to be scheduled on that node.
       * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
       * +optional
       * +mapType=atomic
       * </pre>
       *
       * <code>map&lt;string, string&gt; node_selector = 7 [json_name = "nodeSelector"];</code>
       */
      public Builder putAllNodeSelector(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableNodeSelector().getMutableMap()
            .putAll(values);
        bitField0_ |= 0x00000080;
        return this;
      }

      private java.lang.Object serviceAccountName_ = "";
      /**
       * <pre>
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
       * +optional
       * </pre>
       *
       * <code>optional string service_account_name = 8 [json_name = "serviceAccountName"];</code>
       * @return Whether the serviceAccountName field is set.
       */
      public boolean hasServiceAccountName() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
       * +optional
       * </pre>
       *
       * <code>optional string service_account_name = 8 [json_name = "serviceAccountName"];</code>
       * @return The serviceAccountName.
       */
      public java.lang.String getServiceAccountName() {
        java.lang.Object ref = serviceAccountName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          serviceAccountName_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
       * +optional
       * </pre>
       *
       * <code>optional string service_account_name = 8 [json_name = "serviceAccountName"];</code>
       * @return The bytes for serviceAccountName.
       */
      public com.google.protobuf.ByteString
          getServiceAccountNameBytes() {
        java.lang.Object ref = serviceAccountName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          serviceAccountName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
       * +optional
       * </pre>
       *
       * <code>optional string service_account_name = 8 [json_name = "serviceAccountName"];</code>
       * @param value The serviceAccountName to set.
       * @return This builder for chaining.
       */
      public Builder setServiceAccountName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        serviceAccountName_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
       * +optional
       * </pre>
       *
       * <code>optional string service_account_name = 8 [json_name = "serviceAccountName"];</code>
       * @return This builder for chaining.
       */
      public Builder clearServiceAccountName() {
        serviceAccountName_ = getDefaultInstance().getServiceAccountName();
        bitField0_ = (bitField0_ & ~0x00000100);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
       * +optional
       * </pre>
       *
       * <code>optional string service_account_name = 8 [json_name = "serviceAccountName"];</code>
       * @param value The bytes for serviceAccountName to set.
       * @return This builder for chaining.
       */
      public Builder setServiceAccountNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        serviceAccountName_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }

      private boolean automountServiceAccountToken_ ;
      /**
       * <pre>
       * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
       * +optional
       * </pre>
       *
       * <code>optional bool automount_service_account_token = 21 [json_name = "automountServiceAccountToken"];</code>
       * @return Whether the automountServiceAccountToken field is set.
       */
      @java.lang.Override
      public boolean hasAutomountServiceAccountToken() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
       * +optional
       * </pre>
       *
       * <code>optional bool automount_service_account_token = 21 [json_name = "automountServiceAccountToken"];</code>
       * @return The automountServiceAccountToken.
       */
      @java.lang.Override
      public boolean getAutomountServiceAccountToken() {
        return automountServiceAccountToken_;
      }
      /**
       * <pre>
       * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
       * +optional
       * </pre>
       *
       * <code>optional bool automount_service_account_token = 21 [json_name = "automountServiceAccountToken"];</code>
       * @param value The automountServiceAccountToken to set.
       * @return This builder for chaining.
       */
      public Builder setAutomountServiceAccountToken(boolean value) {

        automountServiceAccountToken_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
       * +optional
       * </pre>
       *
       * <code>optional bool automount_service_account_token = 21 [json_name = "automountServiceAccountToken"];</code>
       * @return This builder for chaining.
       */
      public Builder clearAutomountServiceAccountToken() {
        bitField0_ = (bitField0_ & ~0x00000200);
        automountServiceAccountToken_ = false;
        onChanged();
        return this;
      }

      private java.lang.Object nodeName_ = "";
      /**
       * <pre>
       * NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
       * the scheduler simply schedules this pod onto that node, assuming that it fits resource
       * requirements.
       * +optional
       * </pre>
       *
       * <code>optional string node_name = 10 [json_name = "nodeName"];</code>
       * @return Whether the nodeName field is set.
       */
      public boolean hasNodeName() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <pre>
       * NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
       * the scheduler simply schedules this pod onto that node, assuming that it fits resource
       * requirements.
       * +optional
       * </pre>
       *
       * <code>optional string node_name = 10 [json_name = "nodeName"];</code>
       * @return The nodeName.
       */
      public java.lang.String getNodeName() {
        java.lang.Object ref = nodeName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          nodeName_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
       * the scheduler simply schedules this pod onto that node, assuming that it fits resource
       * requirements.
       * +optional
       * </pre>
       *
       * <code>optional string node_name = 10 [json_name = "nodeName"];</code>
       * @return The bytes for nodeName.
       */
      public com.google.protobuf.ByteString
          getNodeNameBytes() {
        java.lang.Object ref = nodeName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          nodeName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
       * the scheduler simply schedules this pod onto that node, assuming that it fits resource
       * requirements.
       * +optional
       * </pre>
       *
       * <code>optional string node_name = 10 [json_name = "nodeName"];</code>
       * @param value The nodeName to set.
       * @return This builder for chaining.
       */
      public Builder setNodeName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        nodeName_ = value;
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
       * the scheduler simply schedules this pod onto that node, assuming that it fits resource
       * requirements.
       * +optional
       * </pre>
       *
       * <code>optional string node_name = 10 [json_name = "nodeName"];</code>
       * @return This builder for chaining.
       */
      public Builder clearNodeName() {
        nodeName_ = getDefaultInstance().getNodeName();
        bitField0_ = (bitField0_ & ~0x00000400);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
       * the scheduler simply schedules this pod onto that node, assuming that it fits resource
       * requirements.
       * +optional
       * </pre>
       *
       * <code>optional string node_name = 10 [json_name = "nodeName"];</code>
       * @param value The bytes for nodeName to set.
       * @return This builder for chaining.
       */
      public Builder setNodeNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        nodeName_ = value;
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }

      private boolean hostNetwork_ ;
      /**
       * <pre>
       * Host networking requested for this pod. Use the host's network namespace.
       * If this option is set, the ports that will be used must be specified.
       * Default to false.
       * +k8s:conversion-gen=false
       * +optional
       * </pre>
       *
       * <code>bool host_network = 11 [json_name = "hostNetwork"];</code>
       * @return The hostNetwork.
       */
      @java.lang.Override
      public boolean getHostNetwork() {
        return hostNetwork_;
      }
      /**
       * <pre>
       * Host networking requested for this pod. Use the host's network namespace.
       * If this option is set, the ports that will be used must be specified.
       * Default to false.
       * +k8s:conversion-gen=false
       * +optional
       * </pre>
       *
       * <code>bool host_network = 11 [json_name = "hostNetwork"];</code>
       * @param value The hostNetwork to set.
       * @return This builder for chaining.
       */
      public Builder setHostNetwork(boolean value) {

        hostNetwork_ = value;
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Host networking requested for this pod. Use the host's network namespace.
       * If this option is set, the ports that will be used must be specified.
       * Default to false.
       * +k8s:conversion-gen=false
       * +optional
       * </pre>
       *
       * <code>bool host_network = 11 [json_name = "hostNetwork"];</code>
       * @return This builder for chaining.
       */
      public Builder clearHostNetwork() {
        bitField0_ = (bitField0_ & ~0x00000800);
        hostNetwork_ = false;
        onChanged();
        return this;
      }

      private boolean hostPid_ ;
      /**
       * <pre>
       * Use the host's pid namespace.
       * Optional: Default to false.
       * +k8s:conversion-gen=false
       * +optional
       * </pre>
       *
       * <code>bool host_pid = 12 [json_name = "hostPid"];</code>
       * @return The hostPid.
       */
      @java.lang.Override
      public boolean getHostPid() {
        return hostPid_;
      }
      /**
       * <pre>
       * Use the host's pid namespace.
       * Optional: Default to false.
       * +k8s:conversion-gen=false
       * +optional
       * </pre>
       *
       * <code>bool host_pid = 12 [json_name = "hostPid"];</code>
       * @param value The hostPid to set.
       * @return This builder for chaining.
       */
      public Builder setHostPid(boolean value) {

        hostPid_ = value;
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Use the host's pid namespace.
       * Optional: Default to false.
       * +k8s:conversion-gen=false
       * +optional
       * </pre>
       *
       * <code>bool host_pid = 12 [json_name = "hostPid"];</code>
       * @return This builder for chaining.
       */
      public Builder clearHostPid() {
        bitField0_ = (bitField0_ & ~0x00001000);
        hostPid_ = false;
        onChanged();
        return this;
      }

      private boolean hostIpc_ ;
      /**
       * <pre>
       * Use the host's ipc namespace.
       * Optional: Default to false.
       * +k8s:conversion-gen=false
       * +optional
       * </pre>
       *
       * <code>bool host_ipc = 13 [json_name = "hostIpc"];</code>
       * @return The hostIpc.
       */
      @java.lang.Override
      public boolean getHostIpc() {
        return hostIpc_;
      }
      /**
       * <pre>
       * Use the host's ipc namespace.
       * Optional: Default to false.
       * +k8s:conversion-gen=false
       * +optional
       * </pre>
       *
       * <code>bool host_ipc = 13 [json_name = "hostIpc"];</code>
       * @param value The hostIpc to set.
       * @return This builder for chaining.
       */
      public Builder setHostIpc(boolean value) {

        hostIpc_ = value;
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Use the host's ipc namespace.
       * Optional: Default to false.
       * +k8s:conversion-gen=false
       * +optional
       * </pre>
       *
       * <code>bool host_ipc = 13 [json_name = "hostIpc"];</code>
       * @return This builder for chaining.
       */
      public Builder clearHostIpc() {
        bitField0_ = (bitField0_ & ~0x00002000);
        hostIpc_ = false;
        onChanged();
        return this;
      }

      private boolean shareProcessNamespace_ ;
      /**
       * <pre>
       * Share a single process namespace between all of the containers in a pod.
       * When this is set containers will be able to view and signal processes from other containers
       * in the same pod, and the first process in each container will not be assigned PID 1.
       * HostPID and ShareProcessNamespace cannot both be set.
       * Optional: Default to false.
       * +k8s:conversion-gen=false
       * +optional
       * </pre>
       *
       * <code>bool share_process_namespace = 27 [json_name = "shareProcessNamespace"];</code>
       * @return The shareProcessNamespace.
       */
      @java.lang.Override
      public boolean getShareProcessNamespace() {
        return shareProcessNamespace_;
      }
      /**
       * <pre>
       * Share a single process namespace between all of the containers in a pod.
       * When this is set containers will be able to view and signal processes from other containers
       * in the same pod, and the first process in each container will not be assigned PID 1.
       * HostPID and ShareProcessNamespace cannot both be set.
       * Optional: Default to false.
       * +k8s:conversion-gen=false
       * +optional
       * </pre>
       *
       * <code>bool share_process_namespace = 27 [json_name = "shareProcessNamespace"];</code>
       * @param value The shareProcessNamespace to set.
       * @return This builder for chaining.
       */
      public Builder setShareProcessNamespace(boolean value) {

        shareProcessNamespace_ = value;
        bitField0_ |= 0x00004000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Share a single process namespace between all of the containers in a pod.
       * When this is set containers will be able to view and signal processes from other containers
       * in the same pod, and the first process in each container will not be assigned PID 1.
       * HostPID and ShareProcessNamespace cannot both be set.
       * Optional: Default to false.
       * +k8s:conversion-gen=false
       * +optional
       * </pre>
       *
       * <code>bool share_process_namespace = 27 [json_name = "shareProcessNamespace"];</code>
       * @return This builder for chaining.
       */
      public Builder clearShareProcessNamespace() {
        bitField0_ = (bitField0_ & ~0x00004000);
        shareProcessNamespace_ = false;
        onChanged();
        return this;
      }

      private java.lang.Object hostname_ = "";
      /**
       * <pre>
       * Specifies the hostname of the Pod
       * If not specified, the pod's hostname will be set to a system-defined value.
       * +optional
       * </pre>
       *
       * <code>optional string hostname = 16 [json_name = "hostname"];</code>
       * @return Whether the hostname field is set.
       */
      public boolean hasHostname() {
        return ((bitField0_ & 0x00008000) != 0);
      }
      /**
       * <pre>
       * Specifies the hostname of the Pod
       * If not specified, the pod's hostname will be set to a system-defined value.
       * +optional
       * </pre>
       *
       * <code>optional string hostname = 16 [json_name = "hostname"];</code>
       * @return The hostname.
       */
      public java.lang.String getHostname() {
        java.lang.Object ref = hostname_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          hostname_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Specifies the hostname of the Pod
       * If not specified, the pod's hostname will be set to a system-defined value.
       * +optional
       * </pre>
       *
       * <code>optional string hostname = 16 [json_name = "hostname"];</code>
       * @return The bytes for hostname.
       */
      public com.google.protobuf.ByteString
          getHostnameBytes() {
        java.lang.Object ref = hostname_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          hostname_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Specifies the hostname of the Pod
       * If not specified, the pod's hostname will be set to a system-defined value.
       * +optional
       * </pre>
       *
       * <code>optional string hostname = 16 [json_name = "hostname"];</code>
       * @param value The hostname to set.
       * @return This builder for chaining.
       */
      public Builder setHostname(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        hostname_ = value;
        bitField0_ |= 0x00008000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the hostname of the Pod
       * If not specified, the pod's hostname will be set to a system-defined value.
       * +optional
       * </pre>
       *
       * <code>optional string hostname = 16 [json_name = "hostname"];</code>
       * @return This builder for chaining.
       */
      public Builder clearHostname() {
        hostname_ = getDefaultInstance().getHostname();
        bitField0_ = (bitField0_ & ~0x00008000);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the hostname of the Pod
       * If not specified, the pod's hostname will be set to a system-defined value.
       * +optional
       * </pre>
       *
       * <code>optional string hostname = 16 [json_name = "hostname"];</code>
       * @param value The bytes for hostname to set.
       * @return This builder for chaining.
       */
      public Builder setHostnameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        hostname_ = value;
        bitField0_ |= 0x00008000;
        onChanged();
        return this;
      }

      private java.lang.Object subdomain_ = "";
      /**
       * <pre>
       * If specified, the fully qualified Pod hostname will be "&lt;hostname&gt;.&lt;subdomain&gt;.&lt;pod namespace&gt;.svc.&lt;cluster domain&gt;".
       * If not specified, the pod will not have a domainname at all.
       * +optional
       * </pre>
       *
       * <code>optional string subdomain = 17 [json_name = "subdomain"];</code>
       * @return Whether the subdomain field is set.
       */
      public boolean hasSubdomain() {
        return ((bitField0_ & 0x00010000) != 0);
      }
      /**
       * <pre>
       * If specified, the fully qualified Pod hostname will be "&lt;hostname&gt;.&lt;subdomain&gt;.&lt;pod namespace&gt;.svc.&lt;cluster domain&gt;".
       * If not specified, the pod will not have a domainname at all.
       * +optional
       * </pre>
       *
       * <code>optional string subdomain = 17 [json_name = "subdomain"];</code>
       * @return The subdomain.
       */
      public java.lang.String getSubdomain() {
        java.lang.Object ref = subdomain_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          subdomain_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * If specified, the fully qualified Pod hostname will be "&lt;hostname&gt;.&lt;subdomain&gt;.&lt;pod namespace&gt;.svc.&lt;cluster domain&gt;".
       * If not specified, the pod will not have a domainname at all.
       * +optional
       * </pre>
       *
       * <code>optional string subdomain = 17 [json_name = "subdomain"];</code>
       * @return The bytes for subdomain.
       */
      public com.google.protobuf.ByteString
          getSubdomainBytes() {
        java.lang.Object ref = subdomain_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          subdomain_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * If specified, the fully qualified Pod hostname will be "&lt;hostname&gt;.&lt;subdomain&gt;.&lt;pod namespace&gt;.svc.&lt;cluster domain&gt;".
       * If not specified, the pod will not have a domainname at all.
       * +optional
       * </pre>
       *
       * <code>optional string subdomain = 17 [json_name = "subdomain"];</code>
       * @param value The subdomain to set.
       * @return This builder for chaining.
       */
      public Builder setSubdomain(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        subdomain_ = value;
        bitField0_ |= 0x00010000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified, the fully qualified Pod hostname will be "&lt;hostname&gt;.&lt;subdomain&gt;.&lt;pod namespace&gt;.svc.&lt;cluster domain&gt;".
       * If not specified, the pod will not have a domainname at all.
       * +optional
       * </pre>
       *
       * <code>optional string subdomain = 17 [json_name = "subdomain"];</code>
       * @return This builder for chaining.
       */
      public Builder clearSubdomain() {
        subdomain_ = getDefaultInstance().getSubdomain();
        bitField0_ = (bitField0_ & ~0x00010000);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified, the fully qualified Pod hostname will be "&lt;hostname&gt;.&lt;subdomain&gt;.&lt;pod namespace&gt;.svc.&lt;cluster domain&gt;".
       * If not specified, the pod will not have a domainname at all.
       * +optional
       * </pre>
       *
       * <code>optional string subdomain = 17 [json_name = "subdomain"];</code>
       * @param value The bytes for subdomain to set.
       * @return This builder for chaining.
       */
      public Builder setSubdomainBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        subdomain_ = value;
        bitField0_ |= 0x00010000;
        onChanged();
        return this;
      }

      private java.lang.Object schedulerName_ = "";
      /**
       * <pre>
       * If specified, the pod will be dispatched by specified scheduler.
       * If not specified, the pod will be dispatched by default scheduler.
       * +optional
       * </pre>
       *
       * <code>optional string scheduler_name = 19 [json_name = "schedulerName"];</code>
       * @return Whether the schedulerName field is set.
       */
      public boolean hasSchedulerName() {
        return ((bitField0_ & 0x00020000) != 0);
      }
      /**
       * <pre>
       * If specified, the pod will be dispatched by specified scheduler.
       * If not specified, the pod will be dispatched by default scheduler.
       * +optional
       * </pre>
       *
       * <code>optional string scheduler_name = 19 [json_name = "schedulerName"];</code>
       * @return The schedulerName.
       */
      public java.lang.String getSchedulerName() {
        java.lang.Object ref = schedulerName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          schedulerName_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * If specified, the pod will be dispatched by specified scheduler.
       * If not specified, the pod will be dispatched by default scheduler.
       * +optional
       * </pre>
       *
       * <code>optional string scheduler_name = 19 [json_name = "schedulerName"];</code>
       * @return The bytes for schedulerName.
       */
      public com.google.protobuf.ByteString
          getSchedulerNameBytes() {
        java.lang.Object ref = schedulerName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          schedulerName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * If specified, the pod will be dispatched by specified scheduler.
       * If not specified, the pod will be dispatched by default scheduler.
       * +optional
       * </pre>
       *
       * <code>optional string scheduler_name = 19 [json_name = "schedulerName"];</code>
       * @param value The schedulerName to set.
       * @return This builder for chaining.
       */
      public Builder setSchedulerName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        schedulerName_ = value;
        bitField0_ |= 0x00020000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified, the pod will be dispatched by specified scheduler.
       * If not specified, the pod will be dispatched by default scheduler.
       * +optional
       * </pre>
       *
       * <code>optional string scheduler_name = 19 [json_name = "schedulerName"];</code>
       * @return This builder for chaining.
       */
      public Builder clearSchedulerName() {
        schedulerName_ = getDefaultInstance().getSchedulerName();
        bitField0_ = (bitField0_ & ~0x00020000);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified, the pod will be dispatched by specified scheduler.
       * If not specified, the pod will be dispatched by default scheduler.
       * +optional
       * </pre>
       *
       * <code>optional string scheduler_name = 19 [json_name = "schedulerName"];</code>
       * @param value The bytes for schedulerName to set.
       * @return This builder for chaining.
       */
      public Builder setSchedulerNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        schedulerName_ = value;
        bitField0_ |= 0x00020000;
        onChanged();
        return this;
      }

      private java.lang.Object priorityClassName_ = "";
      /**
       * <pre>
       * If specified, indicates the pod's priority. "system-node-critical" and
       * "system-cluster-critical" are two special keywords which indicate the
       * highest priorities with the former being the highest priority. Any other
       * name must be defined by creating a PriorityClass object with that name.
       * If not specified, the pod priority will be default or zero if there is no
       * default.
       * +optional
       * </pre>
       *
       * <code>optional string priority_class_name = 24 [json_name = "priorityClassName"];</code>
       * @return Whether the priorityClassName field is set.
       */
      public boolean hasPriorityClassName() {
        return ((bitField0_ & 0x00040000) != 0);
      }
      /**
       * <pre>
       * If specified, indicates the pod's priority. "system-node-critical" and
       * "system-cluster-critical" are two special keywords which indicate the
       * highest priorities with the former being the highest priority. Any other
       * name must be defined by creating a PriorityClass object with that name.
       * If not specified, the pod priority will be default or zero if there is no
       * default.
       * +optional
       * </pre>
       *
       * <code>optional string priority_class_name = 24 [json_name = "priorityClassName"];</code>
       * @return The priorityClassName.
       */
      public java.lang.String getPriorityClassName() {
        java.lang.Object ref = priorityClassName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          priorityClassName_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * If specified, indicates the pod's priority. "system-node-critical" and
       * "system-cluster-critical" are two special keywords which indicate the
       * highest priorities with the former being the highest priority. Any other
       * name must be defined by creating a PriorityClass object with that name.
       * If not specified, the pod priority will be default or zero if there is no
       * default.
       * +optional
       * </pre>
       *
       * <code>optional string priority_class_name = 24 [json_name = "priorityClassName"];</code>
       * @return The bytes for priorityClassName.
       */
      public com.google.protobuf.ByteString
          getPriorityClassNameBytes() {
        java.lang.Object ref = priorityClassName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          priorityClassName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * If specified, indicates the pod's priority. "system-node-critical" and
       * "system-cluster-critical" are two special keywords which indicate the
       * highest priorities with the former being the highest priority. Any other
       * name must be defined by creating a PriorityClass object with that name.
       * If not specified, the pod priority will be default or zero if there is no
       * default.
       * +optional
       * </pre>
       *
       * <code>optional string priority_class_name = 24 [json_name = "priorityClassName"];</code>
       * @param value The priorityClassName to set.
       * @return This builder for chaining.
       */
      public Builder setPriorityClassName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        priorityClassName_ = value;
        bitField0_ |= 0x00040000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified, indicates the pod's priority. "system-node-critical" and
       * "system-cluster-critical" are two special keywords which indicate the
       * highest priorities with the former being the highest priority. Any other
       * name must be defined by creating a PriorityClass object with that name.
       * If not specified, the pod priority will be default or zero if there is no
       * default.
       * +optional
       * </pre>
       *
       * <code>optional string priority_class_name = 24 [json_name = "priorityClassName"];</code>
       * @return This builder for chaining.
       */
      public Builder clearPriorityClassName() {
        priorityClassName_ = getDefaultInstance().getPriorityClassName();
        bitField0_ = (bitField0_ & ~0x00040000);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified, indicates the pod's priority. "system-node-critical" and
       * "system-cluster-critical" are two special keywords which indicate the
       * highest priorities with the former being the highest priority. Any other
       * name must be defined by creating a PriorityClass object with that name.
       * If not specified, the pod priority will be default or zero if there is no
       * default.
       * +optional
       * </pre>
       *
       * <code>optional string priority_class_name = 24 [json_name = "priorityClassName"];</code>
       * @param value The bytes for priorityClassName to set.
       * @return This builder for chaining.
       */
      public Builder setPriorityClassNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        priorityClassName_ = value;
        bitField0_ |= 0x00040000;
        onChanged();
        return this;
      }

      private int priority_ ;
      /**
       * <pre>
       * The priority value. Various system components use this field to find the
       * priority of the pod. When Priority Admission Controller is enabled, it
       * prevents users from setting this field. The admission controller populates
       * this field from priority_class_name.
       * The higher the value, the higher the priority.
       * +optional
       * </pre>
       *
       * <code>optional int32 priority = 25 [json_name = "priority"];</code>
       * @return Whether the priority field is set.
       */
      @java.lang.Override
      public boolean hasPriority() {
        return ((bitField0_ & 0x00080000) != 0);
      }
      /**
       * <pre>
       * The priority value. Various system components use this field to find the
       * priority of the pod. When Priority Admission Controller is enabled, it
       * prevents users from setting this field. The admission controller populates
       * this field from priority_class_name.
       * The higher the value, the higher the priority.
       * +optional
       * </pre>
       *
       * <code>optional int32 priority = 25 [json_name = "priority"];</code>
       * @return The priority.
       */
      @java.lang.Override
      public int getPriority() {
        return priority_;
      }
      /**
       * <pre>
       * The priority value. Various system components use this field to find the
       * priority of the pod. When Priority Admission Controller is enabled, it
       * prevents users from setting this field. The admission controller populates
       * this field from priority_class_name.
       * The higher the value, the higher the priority.
       * +optional
       * </pre>
       *
       * <code>optional int32 priority = 25 [json_name = "priority"];</code>
       * @param value The priority to set.
       * @return This builder for chaining.
       */
      public Builder setPriority(int value) {

        priority_ = value;
        bitField0_ |= 0x00080000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The priority value. Various system components use this field to find the
       * priority of the pod. When Priority Admission Controller is enabled, it
       * prevents users from setting this field. The admission controller populates
       * this field from priority_class_name.
       * The higher the value, the higher the priority.
       * +optional
       * </pre>
       *
       * <code>optional int32 priority = 25 [json_name = "priority"];</code>
       * @return This builder for chaining.
       */
      public Builder clearPriority() {
        bitField0_ = (bitField0_ & ~0x00080000);
        priority_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object runtimeClassName_ = "";
      /**
       * <pre>
       * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
       * to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
       * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
       * empty definition that uses the default runtime handler.
       * More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
       * +optional
       * </pre>
       *
       * <code>optional string runtime_class_name = 29 [json_name = "runtimeClassName"];</code>
       * @return Whether the runtimeClassName field is set.
       */
      public boolean hasRuntimeClassName() {
        return ((bitField0_ & 0x00100000) != 0);
      }
      /**
       * <pre>
       * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
       * to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
       * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
       * empty definition that uses the default runtime handler.
       * More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
       * +optional
       * </pre>
       *
       * <code>optional string runtime_class_name = 29 [json_name = "runtimeClassName"];</code>
       * @return The runtimeClassName.
       */
      public java.lang.String getRuntimeClassName() {
        java.lang.Object ref = runtimeClassName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          runtimeClassName_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
       * to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
       * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
       * empty definition that uses the default runtime handler.
       * More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
       * +optional
       * </pre>
       *
       * <code>optional string runtime_class_name = 29 [json_name = "runtimeClassName"];</code>
       * @return The bytes for runtimeClassName.
       */
      public com.google.protobuf.ByteString
          getRuntimeClassNameBytes() {
        java.lang.Object ref = runtimeClassName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          runtimeClassName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
       * to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
       * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
       * empty definition that uses the default runtime handler.
       * More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
       * +optional
       * </pre>
       *
       * <code>optional string runtime_class_name = 29 [json_name = "runtimeClassName"];</code>
       * @param value The runtimeClassName to set.
       * @return This builder for chaining.
       */
      public Builder setRuntimeClassName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        runtimeClassName_ = value;
        bitField0_ |= 0x00100000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
       * to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
       * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
       * empty definition that uses the default runtime handler.
       * More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
       * +optional
       * </pre>
       *
       * <code>optional string runtime_class_name = 29 [json_name = "runtimeClassName"];</code>
       * @return This builder for chaining.
       */
      public Builder clearRuntimeClassName() {
        runtimeClassName_ = getDefaultInstance().getRuntimeClassName();
        bitField0_ = (bitField0_ & ~0x00100000);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
       * to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
       * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
       * empty definition that uses the default runtime handler.
       * More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
       * +optional
       * </pre>
       *
       * <code>optional string runtime_class_name = 29 [json_name = "runtimeClassName"];</code>
       * @param value The bytes for runtimeClassName to set.
       * @return This builder for chaining.
       */
      public Builder setRuntimeClassNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        runtimeClassName_ = value;
        bitField0_ |= 0x00100000;
        onChanged();
        return this;
      }

      private boolean enableServiceLinks_ ;
      /**
       * <pre>
       * EnableServiceLinks indicates whether information about services should be injected into pod's
       * environment variables, matching the syntax of Docker links.
       * Optional: Defaults to true.
       * +optional
       * </pre>
       *
       * <code>optional bool enable_service_links = 30 [json_name = "enableServiceLinks"];</code>
       * @return Whether the enableServiceLinks field is set.
       */
      @java.lang.Override
      public boolean hasEnableServiceLinks() {
        return ((bitField0_ & 0x00200000) != 0);
      }
      /**
       * <pre>
       * EnableServiceLinks indicates whether information about services should be injected into pod's
       * environment variables, matching the syntax of Docker links.
       * Optional: Defaults to true.
       * +optional
       * </pre>
       *
       * <code>optional bool enable_service_links = 30 [json_name = "enableServiceLinks"];</code>
       * @return The enableServiceLinks.
       */
      @java.lang.Override
      public boolean getEnableServiceLinks() {
        return enableServiceLinks_;
      }
      /**
       * <pre>
       * EnableServiceLinks indicates whether information about services should be injected into pod's
       * environment variables, matching the syntax of Docker links.
       * Optional: Defaults to true.
       * +optional
       * </pre>
       *
       * <code>optional bool enable_service_links = 30 [json_name = "enableServiceLinks"];</code>
       * @param value The enableServiceLinks to set.
       * @return This builder for chaining.
       */
      public Builder setEnableServiceLinks(boolean value) {

        enableServiceLinks_ = value;
        bitField0_ |= 0x00200000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * EnableServiceLinks indicates whether information about services should be injected into pod's
       * environment variables, matching the syntax of Docker links.
       * Optional: Defaults to true.
       * +optional
       * </pre>
       *
       * <code>optional bool enable_service_links = 30 [json_name = "enableServiceLinks"];</code>
       * @return This builder for chaining.
       */
      public Builder clearEnableServiceLinks() {
        bitField0_ = (bitField0_ & ~0x00200000);
        enableServiceLinks_ = false;
        onChanged();
        return this;
      }

      private java.lang.Object preemptionPolicy_ = "";
      /**
       * <pre>
       * PreemptionPolicy is the Policy for preempting pods with lower priority.
       * One of Never, PreemptLowerPriority.
       * Defaults to PreemptLowerPriority if unset.
       * +optional
       * </pre>
       *
       * <code>optional string preemption_policy = 31 [json_name = "preemptionPolicy"];</code>
       * @return Whether the preemptionPolicy field is set.
       */
      public boolean hasPreemptionPolicy() {
        return ((bitField0_ & 0x00400000) != 0);
      }
      /**
       * <pre>
       * PreemptionPolicy is the Policy for preempting pods with lower priority.
       * One of Never, PreemptLowerPriority.
       * Defaults to PreemptLowerPriority if unset.
       * +optional
       * </pre>
       *
       * <code>optional string preemption_policy = 31 [json_name = "preemptionPolicy"];</code>
       * @return The preemptionPolicy.
       */
      public java.lang.String getPreemptionPolicy() {
        java.lang.Object ref = preemptionPolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          preemptionPolicy_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * PreemptionPolicy is the Policy for preempting pods with lower priority.
       * One of Never, PreemptLowerPriority.
       * Defaults to PreemptLowerPriority if unset.
       * +optional
       * </pre>
       *
       * <code>optional string preemption_policy = 31 [json_name = "preemptionPolicy"];</code>
       * @return The bytes for preemptionPolicy.
       */
      public com.google.protobuf.ByteString
          getPreemptionPolicyBytes() {
        java.lang.Object ref = preemptionPolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          preemptionPolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * PreemptionPolicy is the Policy for preempting pods with lower priority.
       * One of Never, PreemptLowerPriority.
       * Defaults to PreemptLowerPriority if unset.
       * +optional
       * </pre>
       *
       * <code>optional string preemption_policy = 31 [json_name = "preemptionPolicy"];</code>
       * @param value The preemptionPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setPreemptionPolicy(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        preemptionPolicy_ = value;
        bitField0_ |= 0x00400000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * PreemptionPolicy is the Policy for preempting pods with lower priority.
       * One of Never, PreemptLowerPriority.
       * Defaults to PreemptLowerPriority if unset.
       * +optional
       * </pre>
       *
       * <code>optional string preemption_policy = 31 [json_name = "preemptionPolicy"];</code>
       * @return This builder for chaining.
       */
      public Builder clearPreemptionPolicy() {
        preemptionPolicy_ = getDefaultInstance().getPreemptionPolicy();
        bitField0_ = (bitField0_ & ~0x00400000);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * PreemptionPolicy is the Policy for preempting pods with lower priority.
       * One of Never, PreemptLowerPriority.
       * Defaults to PreemptLowerPriority if unset.
       * +optional
       * </pre>
       *
       * <code>optional string preemption_policy = 31 [json_name = "preemptionPolicy"];</code>
       * @param value The bytes for preemptionPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setPreemptionPolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        preemptionPolicy_ = value;
        bitField0_ |= 0x00400000;
        onChanged();
        return this;
      }

      private boolean hostUsers_ ;
      /**
       * <pre>
       * Use the host's user namespace.
       * Optional: Default to true.
       * If set to true or not present, the pod will be run in the host user namespace, useful
       * for when the pod needs a feature only available to the host user namespace, such as
       * loading a kernel module with CAP_SYS_MODULE.
       * When set to false, a new userns is created for the pod. Setting false is useful for
       * mitigating container breakout vulnerabilities even allowing users to run their
       * containers as root without actually having root privileges on the host.
       * This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.
       * +k8s:conversion-gen=false
       * +optional
       * </pre>
       *
       * <code>optional bool host_users = 37 [json_name = "hostUsers"];</code>
       * @return Whether the hostUsers field is set.
       */
      @java.lang.Override
      public boolean hasHostUsers() {
        return ((bitField0_ & 0x00800000) != 0);
      }
      /**
       * <pre>
       * Use the host's user namespace.
       * Optional: Default to true.
       * If set to true or not present, the pod will be run in the host user namespace, useful
       * for when the pod needs a feature only available to the host user namespace, such as
       * loading a kernel module with CAP_SYS_MODULE.
       * When set to false, a new userns is created for the pod. Setting false is useful for
       * mitigating container breakout vulnerabilities even allowing users to run their
       * containers as root without actually having root privileges on the host.
       * This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.
       * +k8s:conversion-gen=false
       * +optional
       * </pre>
       *
       * <code>optional bool host_users = 37 [json_name = "hostUsers"];</code>
       * @return The hostUsers.
       */
      @java.lang.Override
      public boolean getHostUsers() {
        return hostUsers_;
      }
      /**
       * <pre>
       * Use the host's user namespace.
       * Optional: Default to true.
       * If set to true or not present, the pod will be run in the host user namespace, useful
       * for when the pod needs a feature only available to the host user namespace, such as
       * loading a kernel module with CAP_SYS_MODULE.
       * When set to false, a new userns is created for the pod. Setting false is useful for
       * mitigating container breakout vulnerabilities even allowing users to run their
       * containers as root without actually having root privileges on the host.
       * This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.
       * +k8s:conversion-gen=false
       * +optional
       * </pre>
       *
       * <code>optional bool host_users = 37 [json_name = "hostUsers"];</code>
       * @param value The hostUsers to set.
       * @return This builder for chaining.
       */
      public Builder setHostUsers(boolean value) {

        hostUsers_ = value;
        bitField0_ |= 0x00800000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Use the host's user namespace.
       * Optional: Default to true.
       * If set to true or not present, the pod will be run in the host user namespace, useful
       * for when the pod needs a feature only available to the host user namespace, such as
       * loading a kernel module with CAP_SYS_MODULE.
       * When set to false, a new userns is created for the pod. Setting false is useful for
       * mitigating container breakout vulnerabilities even allowing users to run their
       * containers as root without actually having root privileges on the host.
       * This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.
       * +k8s:conversion-gen=false
       * +optional
       * </pre>
       *
       * <code>optional bool host_users = 37 [json_name = "hostUsers"];</code>
       * @return This builder for chaining.
       */
      public Builder clearHostUsers() {
        bitField0_ = (bitField0_ & ~0x00800000);
        hostUsers_ = false;
        onChanged();
        return this;
      }

      private java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim> resourceClaims_ =
        java.util.Collections.emptyList();
      private void ensureResourceClaimsIsMutable() {
        if (!((bitField0_ & 0x01000000) != 0)) {
          resourceClaims_ = new java.util.ArrayList<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim>(resourceClaims_);
          bitField0_ |= 0x01000000;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaimOrBuilder> resourceClaimsBuilder_;

      /**
       * <pre>
       * ResourceClaims defines which ResourceClaims must be allocated
       * and reserved before the Pod is allowed to start. The resources
       * will be made available to those containers which consume them
       * by name.
       *
       * This is an alpha field and requires enabling the
       * DynamicResourceAllocation feature gate.
       *
       * This field is immutable.
       *
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * +featureGate=DynamicResourceAllocation
       * +optional
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
       */
      public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim> getResourceClaimsList() {
        if (resourceClaimsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(resourceClaims_);
        } else {
          return resourceClaimsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * ResourceClaims defines which ResourceClaims must be allocated
       * and reserved before the Pod is allowed to start. The resources
       * will be made available to those containers which consume them
       * by name.
       *
       * This is an alpha field and requires enabling the
       * DynamicResourceAllocation feature gate.
       *
       * This field is immutable.
       *
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * +featureGate=DynamicResourceAllocation
       * +optional
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
       */
      public int getResourceClaimsCount() {
        if (resourceClaimsBuilder_ == null) {
          return resourceClaims_.size();
        } else {
          return resourceClaimsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * ResourceClaims defines which ResourceClaims must be allocated
       * and reserved before the Pod is allowed to start. The resources
       * will be made available to those containers which consume them
       * by name.
       *
       * This is an alpha field and requires enabling the
       * DynamicResourceAllocation feature gate.
       *
       * This field is immutable.
       *
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * +featureGate=DynamicResourceAllocation
       * +optional
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim getResourceClaims(int index) {
        if (resourceClaimsBuilder_ == null) {
          return resourceClaims_.get(index);
        } else {
          return resourceClaimsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * ResourceClaims defines which ResourceClaims must be allocated
       * and reserved before the Pod is allowed to start. The resources
       * will be made available to those containers which consume them
       * by name.
       *
       * This is an alpha field and requires enabling the
       * DynamicResourceAllocation feature gate.
       *
       * This field is immutable.
       *
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * +featureGate=DynamicResourceAllocation
       * +optional
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
       */
      public Builder setResourceClaims(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim value) {
        if (resourceClaimsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureResourceClaimsIsMutable();
          resourceClaims_.set(index, value);
          onChanged();
        } else {
          resourceClaimsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * ResourceClaims defines which ResourceClaims must be allocated
       * and reserved before the Pod is allowed to start. The resources
       * will be made available to those containers which consume them
       * by name.
       *
       * This is an alpha field and requires enabling the
       * DynamicResourceAllocation feature gate.
       *
       * This field is immutable.
       *
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * +featureGate=DynamicResourceAllocation
       * +optional
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
       */
      public Builder setResourceClaims(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim.Builder builderForValue) {
        if (resourceClaimsBuilder_ == null) {
          ensureResourceClaimsIsMutable();
          resourceClaims_.set(index, builderForValue.build());
          onChanged();
        } else {
          resourceClaimsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ResourceClaims defines which ResourceClaims must be allocated
       * and reserved before the Pod is allowed to start. The resources
       * will be made available to those containers which consume them
       * by name.
       *
       * This is an alpha field and requires enabling the
       * DynamicResourceAllocation feature gate.
       *
       * This field is immutable.
       *
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * +featureGate=DynamicResourceAllocation
       * +optional
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
       */
      public Builder addResourceClaims(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim value) {
        if (resourceClaimsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureResourceClaimsIsMutable();
          resourceClaims_.add(value);
          onChanged();
        } else {
          resourceClaimsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * ResourceClaims defines which ResourceClaims must be allocated
       * and reserved before the Pod is allowed to start. The resources
       * will be made available to those containers which consume them
       * by name.
       *
       * This is an alpha field and requires enabling the
       * DynamicResourceAllocation feature gate.
       *
       * This field is immutable.
       *
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * +featureGate=DynamicResourceAllocation
       * +optional
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
       */
      public Builder addResourceClaims(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim value) {
        if (resourceClaimsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureResourceClaimsIsMutable();
          resourceClaims_.add(index, value);
          onChanged();
        } else {
          resourceClaimsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * ResourceClaims defines which ResourceClaims must be allocated
       * and reserved before the Pod is allowed to start. The resources
       * will be made available to those containers which consume them
       * by name.
       *
       * This is an alpha field and requires enabling the
       * DynamicResourceAllocation feature gate.
       *
       * This field is immutable.
       *
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * +featureGate=DynamicResourceAllocation
       * +optional
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
       */
      public Builder addResourceClaims(
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim.Builder builderForValue) {
        if (resourceClaimsBuilder_ == null) {
          ensureResourceClaimsIsMutable();
          resourceClaims_.add(builderForValue.build());
          onChanged();
        } else {
          resourceClaimsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ResourceClaims defines which ResourceClaims must be allocated
       * and reserved before the Pod is allowed to start. The resources
       * will be made available to those containers which consume them
       * by name.
       *
       * This is an alpha field and requires enabling the
       * DynamicResourceAllocation feature gate.
       *
       * This field is immutable.
       *
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * +featureGate=DynamicResourceAllocation
       * +optional
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
       */
      public Builder addResourceClaims(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim.Builder builderForValue) {
        if (resourceClaimsBuilder_ == null) {
          ensureResourceClaimsIsMutable();
          resourceClaims_.add(index, builderForValue.build());
          onChanged();
        } else {
          resourceClaimsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ResourceClaims defines which ResourceClaims must be allocated
       * and reserved before the Pod is allowed to start. The resources
       * will be made available to those containers which consume them
       * by name.
       *
       * This is an alpha field and requires enabling the
       * DynamicResourceAllocation feature gate.
       *
       * This field is immutable.
       *
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * +featureGate=DynamicResourceAllocation
       * +optional
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
       */
      public Builder addAllResourceClaims(
          java.lang.Iterable<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim> values) {
        if (resourceClaimsBuilder_ == null) {
          ensureResourceClaimsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, resourceClaims_);
          onChanged();
        } else {
          resourceClaimsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * ResourceClaims defines which ResourceClaims must be allocated
       * and reserved before the Pod is allowed to start. The resources
       * will be made available to those containers which consume them
       * by name.
       *
       * This is an alpha field and requires enabling the
       * DynamicResourceAllocation feature gate.
       *
       * This field is immutable.
       *
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * +featureGate=DynamicResourceAllocation
       * +optional
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
       */
      public Builder clearResourceClaims() {
        if (resourceClaimsBuilder_ == null) {
          resourceClaims_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x01000000);
          onChanged();
        } else {
          resourceClaimsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * ResourceClaims defines which ResourceClaims must be allocated
       * and reserved before the Pod is allowed to start. The resources
       * will be made available to those containers which consume them
       * by name.
       *
       * This is an alpha field and requires enabling the
       * DynamicResourceAllocation feature gate.
       *
       * This field is immutable.
       *
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * +featureGate=DynamicResourceAllocation
       * +optional
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
       */
      public Builder removeResourceClaims(int index) {
        if (resourceClaimsBuilder_ == null) {
          ensureResourceClaimsIsMutable();
          resourceClaims_.remove(index);
          onChanged();
        } else {
          resourceClaimsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * ResourceClaims defines which ResourceClaims must be allocated
       * and reserved before the Pod is allowed to start. The resources
       * will be made available to those containers which consume them
       * by name.
       *
       * This is an alpha field and requires enabling the
       * DynamicResourceAllocation feature gate.
       *
       * This field is immutable.
       *
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * +featureGate=DynamicResourceAllocation
       * +optional
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim.Builder getResourceClaimsBuilder(
          int index) {
        return getResourceClaimsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * ResourceClaims defines which ResourceClaims must be allocated
       * and reserved before the Pod is allowed to start. The resources
       * will be made available to those containers which consume them
       * by name.
       *
       * This is an alpha field and requires enabling the
       * DynamicResourceAllocation feature gate.
       *
       * This field is immutable.
       *
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * +featureGate=DynamicResourceAllocation
       * +optional
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaimOrBuilder getResourceClaimsOrBuilder(
          int index) {
        if (resourceClaimsBuilder_ == null) {
          return resourceClaims_.get(index);  } else {
          return resourceClaimsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * ResourceClaims defines which ResourceClaims must be allocated
       * and reserved before the Pod is allowed to start. The resources
       * will be made available to those containers which consume them
       * by name.
       *
       * This is an alpha field and requires enabling the
       * DynamicResourceAllocation feature gate.
       *
       * This field is immutable.
       *
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * +featureGate=DynamicResourceAllocation
       * +optional
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
       */
      public java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaimOrBuilder> 
           getResourceClaimsOrBuilderList() {
        if (resourceClaimsBuilder_ != null) {
          return resourceClaimsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(resourceClaims_);
        }
      }
      /**
       * <pre>
       * ResourceClaims defines which ResourceClaims must be allocated
       * and reserved before the Pod is allowed to start. The resources
       * will be made available to those containers which consume them
       * by name.
       *
       * This is an alpha field and requires enabling the
       * DynamicResourceAllocation feature gate.
       *
       * This field is immutable.
       *
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * +featureGate=DynamicResourceAllocation
       * +optional
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim.Builder addResourceClaimsBuilder() {
        return getResourceClaimsFieldBuilder().addBuilder(
            ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim.getDefaultInstance());
      }
      /**
       * <pre>
       * ResourceClaims defines which ResourceClaims must be allocated
       * and reserved before the Pod is allowed to start. The resources
       * will be made available to those containers which consume them
       * by name.
       *
       * This is an alpha field and requires enabling the
       * DynamicResourceAllocation feature gate.
       *
       * This field is immutable.
       *
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * +featureGate=DynamicResourceAllocation
       * +optional
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim.Builder addResourceClaimsBuilder(
          int index) {
        return getResourceClaimsFieldBuilder().addBuilder(
            index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim.getDefaultInstance());
      }
      /**
       * <pre>
       * ResourceClaims defines which ResourceClaims must be allocated
       * and reserved before the Pod is allowed to start. The resources
       * will be made available to those containers which consume them
       * by name.
       *
       * This is an alpha field and requires enabling the
       * DynamicResourceAllocation feature gate.
       *
       * This field is immutable.
       *
       * +patchMergeKey=name
       * +patchStrategy=merge,retainKeys
       * +listType=map
       * +listMapKey=name
       * +featureGate=DynamicResourceAllocation
       * +optional
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim resource_claims = 39 [json_name = "resourceClaims"];</code>
       */
      public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim.Builder> 
           getResourceClaimsBuilderList() {
        return getResourceClaimsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaimOrBuilder> 
          getResourceClaimsFieldBuilder() {
        if (resourceClaimsBuilder_ == null) {
          resourceClaimsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaim.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodResourceClaimOrBuilder>(
                  resourceClaims_,
                  ((bitField0_ & 0x01000000) != 0),
                  getParentForChildren(),
                  isClean());
          resourceClaims_ = null;
        }
        return resourceClaimsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chalk.pubsub.v1.PodStatusPubSub.PodSpec)
    }

    // @@protoc_insertion_point(class_scope:chalk.pubsub.v1.PodStatusPubSub.PodSpec)
    private static final ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec();
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<PodSpec>
        PARSER = new com.google.protobuf.AbstractParser<PodSpec>() {
      @java.lang.Override
      public PodSpec parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<PodSpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PodSpec> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ContainerStateOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chalk.pubsub.v1.PodStatusPubSub.ContainerState)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Details about a waiting container
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting waiting = 1 [json_name = "waiting"];</code>
     * @return Whether the waiting field is set.
     */
    boolean hasWaiting();
    /**
     * <pre>
     * Details about a waiting container
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting waiting = 1 [json_name = "waiting"];</code>
     * @return The waiting.
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting getWaiting();
    /**
     * <pre>
     * Details about a waiting container
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting waiting = 1 [json_name = "waiting"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaitingOrBuilder getWaitingOrBuilder();

    /**
     * <pre>
     * Details about a running container
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning running = 2 [json_name = "running"];</code>
     * @return Whether the running field is set.
     */
    boolean hasRunning();
    /**
     * <pre>
     * Details about a running container
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning running = 2 [json_name = "running"];</code>
     * @return The running.
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning getRunning();
    /**
     * <pre>
     * Details about a running container
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning running = 2 [json_name = "running"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunningOrBuilder getRunningOrBuilder();

    /**
     * <pre>
     * Details about a terminated container
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated terminated = 3 [json_name = "terminated"];</code>
     * @return Whether the terminated field is set.
     */
    boolean hasTerminated();
    /**
     * <pre>
     * Details about a terminated container
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated terminated = 3 [json_name = "terminated"];</code>
     * @return The terminated.
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated getTerminated();
    /**
     * <pre>
     * Details about a terminated container
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated terminated = 3 [json_name = "terminated"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminatedOrBuilder getTerminatedOrBuilder();
  }
  /**
   * <pre>
   * ContainerState holds a possible state of container.
   * Only one of its members may be specified.
   * If none of them is specified, the default one is ContainerStateWaiting.
   * </pre>
   *
   * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.ContainerState}
   */
  public static final class ContainerState extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chalk.pubsub.v1.PodStatusPubSub.ContainerState)
      ContainerStateOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ContainerState.newBuilder() to construct.
    private ContainerState(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ContainerState() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ContainerState();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ContainerState_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ContainerState_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.Builder.class);
    }

    private int bitField0_;
    public static final int WAITING_FIELD_NUMBER = 1;
    private ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting waiting_;
    /**
     * <pre>
     * Details about a waiting container
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting waiting = 1 [json_name = "waiting"];</code>
     * @return Whether the waiting field is set.
     */
    @java.lang.Override
    public boolean hasWaiting() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Details about a waiting container
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting waiting = 1 [json_name = "waiting"];</code>
     * @return The waiting.
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting getWaiting() {
      return waiting_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting.getDefaultInstance() : waiting_;
    }
    /**
     * <pre>
     * Details about a waiting container
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting waiting = 1 [json_name = "waiting"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaitingOrBuilder getWaitingOrBuilder() {
      return waiting_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting.getDefaultInstance() : waiting_;
    }

    public static final int RUNNING_FIELD_NUMBER = 2;
    private ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning running_;
    /**
     * <pre>
     * Details about a running container
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning running = 2 [json_name = "running"];</code>
     * @return Whether the running field is set.
     */
    @java.lang.Override
    public boolean hasRunning() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Details about a running container
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning running = 2 [json_name = "running"];</code>
     * @return The running.
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning getRunning() {
      return running_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning.getDefaultInstance() : running_;
    }
    /**
     * <pre>
     * Details about a running container
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning running = 2 [json_name = "running"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunningOrBuilder getRunningOrBuilder() {
      return running_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning.getDefaultInstance() : running_;
    }

    public static final int TERMINATED_FIELD_NUMBER = 3;
    private ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated terminated_;
    /**
     * <pre>
     * Details about a terminated container
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated terminated = 3 [json_name = "terminated"];</code>
     * @return Whether the terminated field is set.
     */
    @java.lang.Override
    public boolean hasTerminated() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Details about a terminated container
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated terminated = 3 [json_name = "terminated"];</code>
     * @return The terminated.
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated getTerminated() {
      return terminated_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated.getDefaultInstance() : terminated_;
    }
    /**
     * <pre>
     * Details about a terminated container
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated terminated = 3 [json_name = "terminated"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminatedOrBuilder getTerminatedOrBuilder() {
      return terminated_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated.getDefaultInstance() : terminated_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getWaiting());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getRunning());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(3, getTerminated());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getWaiting());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getRunning());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getTerminated());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState)) {
        return super.equals(obj);
      }
      ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState other = (ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState) obj;

      if (hasWaiting() != other.hasWaiting()) return false;
      if (hasWaiting()) {
        if (!getWaiting()
            .equals(other.getWaiting())) return false;
      }
      if (hasRunning() != other.hasRunning()) return false;
      if (hasRunning()) {
        if (!getRunning()
            .equals(other.getRunning())) return false;
      }
      if (hasTerminated() != other.hasTerminated()) return false;
      if (hasTerminated()) {
        if (!getTerminated()
            .equals(other.getTerminated())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasWaiting()) {
        hash = (37 * hash) + WAITING_FIELD_NUMBER;
        hash = (53 * hash) + getWaiting().hashCode();
      }
      if (hasRunning()) {
        hash = (37 * hash) + RUNNING_FIELD_NUMBER;
        hash = (53 * hash) + getRunning().hashCode();
      }
      if (hasTerminated()) {
        hash = (37 * hash) + TERMINATED_FIELD_NUMBER;
        hash = (53 * hash) + getTerminated().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ContainerState holds a possible state of container.
     * Only one of its members may be specified.
     * If none of them is specified, the default one is ContainerStateWaiting.
     * </pre>
     *
     * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.ContainerState}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chalk.pubsub.v1.PodStatusPubSub.ContainerState)
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ContainerState_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ContainerState_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.Builder.class);
      }

      // Construct using ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getWaitingFieldBuilder();
          getRunningFieldBuilder();
          getTerminatedFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        waiting_ = null;
        if (waitingBuilder_ != null) {
          waitingBuilder_.dispose();
          waitingBuilder_ = null;
        }
        running_ = null;
        if (runningBuilder_ != null) {
          runningBuilder_.dispose();
          runningBuilder_ = null;
        }
        terminated_ = null;
        if (terminatedBuilder_ != null) {
          terminatedBuilder_.dispose();
          terminatedBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ContainerState_descriptor;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState getDefaultInstanceForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.getDefaultInstance();
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState build() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState buildPartial() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState result = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.waiting_ = waitingBuilder_ == null
              ? waiting_
              : waitingBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.running_ = runningBuilder_ == null
              ? running_
              : runningBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.terminated_ = terminatedBuilder_ == null
              ? terminated_
              : terminatedBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState) {
          return mergeFrom((ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState other) {
        if (other == ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.getDefaultInstance()) return this;
        if (other.hasWaiting()) {
          mergeWaiting(other.getWaiting());
        }
        if (other.hasRunning()) {
          mergeRunning(other.getRunning());
        }
        if (other.hasTerminated()) {
          mergeTerminated(other.getTerminated());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getWaitingFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getRunningFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getTerminatedFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting waiting_;
      private com.google.protobuf.SingleFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaitingOrBuilder> waitingBuilder_;
      /**
       * <pre>
       * Details about a waiting container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting waiting = 1 [json_name = "waiting"];</code>
       * @return Whether the waiting field is set.
       */
      public boolean hasWaiting() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Details about a waiting container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting waiting = 1 [json_name = "waiting"];</code>
       * @return The waiting.
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting getWaiting() {
        if (waitingBuilder_ == null) {
          return waiting_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting.getDefaultInstance() : waiting_;
        } else {
          return waitingBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Details about a waiting container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting waiting = 1 [json_name = "waiting"];</code>
       */
      public Builder setWaiting(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting value) {
        if (waitingBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          waiting_ = value;
        } else {
          waitingBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Details about a waiting container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting waiting = 1 [json_name = "waiting"];</code>
       */
      public Builder setWaiting(
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting.Builder builderForValue) {
        if (waitingBuilder_ == null) {
          waiting_ = builderForValue.build();
        } else {
          waitingBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Details about a waiting container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting waiting = 1 [json_name = "waiting"];</code>
       */
      public Builder mergeWaiting(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting value) {
        if (waitingBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            waiting_ != null &&
            waiting_ != ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting.getDefaultInstance()) {
            getWaitingBuilder().mergeFrom(value);
          } else {
            waiting_ = value;
          }
        } else {
          waitingBuilder_.mergeFrom(value);
        }
        if (waiting_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Details about a waiting container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting waiting = 1 [json_name = "waiting"];</code>
       */
      public Builder clearWaiting() {
        bitField0_ = (bitField0_ & ~0x00000001);
        waiting_ = null;
        if (waitingBuilder_ != null) {
          waitingBuilder_.dispose();
          waitingBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Details about a waiting container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting waiting = 1 [json_name = "waiting"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting.Builder getWaitingBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getWaitingFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Details about a waiting container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting waiting = 1 [json_name = "waiting"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaitingOrBuilder getWaitingOrBuilder() {
        if (waitingBuilder_ != null) {
          return waitingBuilder_.getMessageOrBuilder();
        } else {
          return waiting_ == null ?
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting.getDefaultInstance() : waiting_;
        }
      }
      /**
       * <pre>
       * Details about a waiting container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting waiting = 1 [json_name = "waiting"];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaitingOrBuilder> 
          getWaitingFieldBuilder() {
        if (waitingBuilder_ == null) {
          waitingBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaitingOrBuilder>(
                  getWaiting(),
                  getParentForChildren(),
                  isClean());
          waiting_ = null;
        }
        return waitingBuilder_;
      }

      private ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning running_;
      private com.google.protobuf.SingleFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunningOrBuilder> runningBuilder_;
      /**
       * <pre>
       * Details about a running container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning running = 2 [json_name = "running"];</code>
       * @return Whether the running field is set.
       */
      public boolean hasRunning() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Details about a running container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning running = 2 [json_name = "running"];</code>
       * @return The running.
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning getRunning() {
        if (runningBuilder_ == null) {
          return running_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning.getDefaultInstance() : running_;
        } else {
          return runningBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Details about a running container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning running = 2 [json_name = "running"];</code>
       */
      public Builder setRunning(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning value) {
        if (runningBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          running_ = value;
        } else {
          runningBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Details about a running container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning running = 2 [json_name = "running"];</code>
       */
      public Builder setRunning(
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning.Builder builderForValue) {
        if (runningBuilder_ == null) {
          running_ = builderForValue.build();
        } else {
          runningBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Details about a running container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning running = 2 [json_name = "running"];</code>
       */
      public Builder mergeRunning(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning value) {
        if (runningBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            running_ != null &&
            running_ != ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning.getDefaultInstance()) {
            getRunningBuilder().mergeFrom(value);
          } else {
            running_ = value;
          }
        } else {
          runningBuilder_.mergeFrom(value);
        }
        if (running_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Details about a running container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning running = 2 [json_name = "running"];</code>
       */
      public Builder clearRunning() {
        bitField0_ = (bitField0_ & ~0x00000002);
        running_ = null;
        if (runningBuilder_ != null) {
          runningBuilder_.dispose();
          runningBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Details about a running container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning running = 2 [json_name = "running"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning.Builder getRunningBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getRunningFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Details about a running container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning running = 2 [json_name = "running"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunningOrBuilder getRunningOrBuilder() {
        if (runningBuilder_ != null) {
          return runningBuilder_.getMessageOrBuilder();
        } else {
          return running_ == null ?
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning.getDefaultInstance() : running_;
        }
      }
      /**
       * <pre>
       * Details about a running container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning running = 2 [json_name = "running"];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunningOrBuilder> 
          getRunningFieldBuilder() {
        if (runningBuilder_ == null) {
          runningBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunningOrBuilder>(
                  getRunning(),
                  getParentForChildren(),
                  isClean());
          running_ = null;
        }
        return runningBuilder_;
      }

      private ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated terminated_;
      private com.google.protobuf.SingleFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminatedOrBuilder> terminatedBuilder_;
      /**
       * <pre>
       * Details about a terminated container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated terminated = 3 [json_name = "terminated"];</code>
       * @return Whether the terminated field is set.
       */
      public boolean hasTerminated() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Details about a terminated container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated terminated = 3 [json_name = "terminated"];</code>
       * @return The terminated.
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated getTerminated() {
        if (terminatedBuilder_ == null) {
          return terminated_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated.getDefaultInstance() : terminated_;
        } else {
          return terminatedBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Details about a terminated container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated terminated = 3 [json_name = "terminated"];</code>
       */
      public Builder setTerminated(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated value) {
        if (terminatedBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          terminated_ = value;
        } else {
          terminatedBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Details about a terminated container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated terminated = 3 [json_name = "terminated"];</code>
       */
      public Builder setTerminated(
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated.Builder builderForValue) {
        if (terminatedBuilder_ == null) {
          terminated_ = builderForValue.build();
        } else {
          terminatedBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Details about a terminated container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated terminated = 3 [json_name = "terminated"];</code>
       */
      public Builder mergeTerminated(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated value) {
        if (terminatedBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            terminated_ != null &&
            terminated_ != ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated.getDefaultInstance()) {
            getTerminatedBuilder().mergeFrom(value);
          } else {
            terminated_ = value;
          }
        } else {
          terminatedBuilder_.mergeFrom(value);
        }
        if (terminated_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Details about a terminated container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated terminated = 3 [json_name = "terminated"];</code>
       */
      public Builder clearTerminated() {
        bitField0_ = (bitField0_ & ~0x00000004);
        terminated_ = null;
        if (terminatedBuilder_ != null) {
          terminatedBuilder_.dispose();
          terminatedBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Details about a terminated container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated terminated = 3 [json_name = "terminated"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated.Builder getTerminatedBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getTerminatedFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Details about a terminated container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated terminated = 3 [json_name = "terminated"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminatedOrBuilder getTerminatedOrBuilder() {
        if (terminatedBuilder_ != null) {
          return terminatedBuilder_.getMessageOrBuilder();
        } else {
          return terminated_ == null ?
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated.getDefaultInstance() : terminated_;
        }
      }
      /**
       * <pre>
       * Details about a terminated container
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated terminated = 3 [json_name = "terminated"];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminatedOrBuilder> 
          getTerminatedFieldBuilder() {
        if (terminatedBuilder_ == null) {
          terminatedBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminatedOrBuilder>(
                  getTerminated(),
                  getParentForChildren(),
                  isClean());
          terminated_ = null;
        }
        return terminatedBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chalk.pubsub.v1.PodStatusPubSub.ContainerState)
    }

    // @@protoc_insertion_point(class_scope:chalk.pubsub.v1.PodStatusPubSub.ContainerState)
    private static final ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState();
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ContainerState>
        PARSER = new com.google.protobuf.AbstractParser<ContainerState>() {
      @java.lang.Override
      public ContainerState parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ContainerState> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ContainerState> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ContainerStateRunningOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Time at which the container was last (re-)started
     * +optional
     * </pre>
     *
     * <code>int64 started_at = 1 [json_name = "startedAt", (.gen_bq_schema.bigquery) = { ... }</code>
     * @return The startedAt.
     */
    long getStartedAt();
  }
  /**
   * <pre>
   * ContainerStateRunning is a running state of a container.
   * </pre>
   *
   * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning}
   */
  public static final class ContainerStateRunning extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning)
      ContainerStateRunningOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ContainerStateRunning.newBuilder() to construct.
    private ContainerStateRunning(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ContainerStateRunning() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ContainerStateRunning();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ContainerStateRunning_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ContainerStateRunning_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning.Builder.class);
    }

    public static final int STARTED_AT_FIELD_NUMBER = 1;
    private long startedAt_ = 0L;
    /**
     * <pre>
     * Time at which the container was last (re-)started
     * +optional
     * </pre>
     *
     * <code>int64 started_at = 1 [json_name = "startedAt", (.gen_bq_schema.bigquery) = { ... }</code>
     * @return The startedAt.
     */
    @java.lang.Override
    public long getStartedAt() {
      return startedAt_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (startedAt_ != 0L) {
        output.writeInt64(1, startedAt_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (startedAt_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, startedAt_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning)) {
        return super.equals(obj);
      }
      ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning other = (ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning) obj;

      if (getStartedAt()
          != other.getStartedAt()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + STARTED_AT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getStartedAt());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ContainerStateRunning is a running state of a container.
     * </pre>
     *
     * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning)
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunningOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ContainerStateRunning_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ContainerStateRunning_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning.Builder.class);
      }

      // Construct using ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        startedAt_ = 0L;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ContainerStateRunning_descriptor;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning getDefaultInstanceForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning.getDefaultInstance();
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning build() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning buildPartial() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning result = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.startedAt_ = startedAt_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning) {
          return mergeFrom((ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning other) {
        if (other == ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning.getDefaultInstance()) return this;
        if (other.getStartedAt() != 0L) {
          setStartedAt(other.getStartedAt());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                startedAt_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long startedAt_ ;
      /**
       * <pre>
       * Time at which the container was last (re-)started
       * +optional
       * </pre>
       *
       * <code>int64 started_at = 1 [json_name = "startedAt", (.gen_bq_schema.bigquery) = { ... }</code>
       * @return The startedAt.
       */
      @java.lang.Override
      public long getStartedAt() {
        return startedAt_;
      }
      /**
       * <pre>
       * Time at which the container was last (re-)started
       * +optional
       * </pre>
       *
       * <code>int64 started_at = 1 [json_name = "startedAt", (.gen_bq_schema.bigquery) = { ... }</code>
       * @param value The startedAt to set.
       * @return This builder for chaining.
       */
      public Builder setStartedAt(long value) {

        startedAt_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Time at which the container was last (re-)started
       * +optional
       * </pre>
       *
       * <code>int64 started_at = 1 [json_name = "startedAt", (.gen_bq_schema.bigquery) = { ... }</code>
       * @return This builder for chaining.
       */
      public Builder clearStartedAt() {
        bitField0_ = (bitField0_ & ~0x00000001);
        startedAt_ = 0L;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning)
    }

    // @@protoc_insertion_point(class_scope:chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning)
    private static final ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning();
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ContainerStateRunning>
        PARSER = new com.google.protobuf.AbstractParser<ContainerStateRunning>() {
      @java.lang.Override
      public ContainerStateRunning parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ContainerStateRunning> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ContainerStateRunning> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateRunning getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ContainerStateTerminatedOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Exit status from the last termination of the container
     * </pre>
     *
     * <code>int32 exit_code = 1 [json_name = "exitCode"];</code>
     * @return The exitCode.
     */
    int getExitCode();

    /**
     * <pre>
     * Signal from the last termination of the container
     * +optional
     * </pre>
     *
     * <code>optional int32 signal = 2 [json_name = "signal"];</code>
     * @return Whether the signal field is set.
     */
    boolean hasSignal();
    /**
     * <pre>
     * Signal from the last termination of the container
     * +optional
     * </pre>
     *
     * <code>optional int32 signal = 2 [json_name = "signal"];</code>
     * @return The signal.
     */
    int getSignal();

    /**
     * <pre>
     * (brief) reason from the last termination of the container
     * +optional
     * </pre>
     *
     * <code>optional string reason = 3 [json_name = "reason"];</code>
     * @return Whether the reason field is set.
     */
    boolean hasReason();
    /**
     * <pre>
     * (brief) reason from the last termination of the container
     * +optional
     * </pre>
     *
     * <code>optional string reason = 3 [json_name = "reason"];</code>
     * @return The reason.
     */
    java.lang.String getReason();
    /**
     * <pre>
     * (brief) reason from the last termination of the container
     * +optional
     * </pre>
     *
     * <code>optional string reason = 3 [json_name = "reason"];</code>
     * @return The bytes for reason.
     */
    com.google.protobuf.ByteString
        getReasonBytes();

    /**
     * <pre>
     * Message regarding the last termination of the container
     * +optional
     * </pre>
     *
     * <code>optional string message = 4 [json_name = "message"];</code>
     * @return Whether the message field is set.
     */
    boolean hasMessage();
    /**
     * <pre>
     * Message regarding the last termination of the container
     * +optional
     * </pre>
     *
     * <code>optional string message = 4 [json_name = "message"];</code>
     * @return The message.
     */
    java.lang.String getMessage();
    /**
     * <pre>
     * Message regarding the last termination of the container
     * +optional
     * </pre>
     *
     * <code>optional string message = 4 [json_name = "message"];</code>
     * @return The bytes for message.
     */
    com.google.protobuf.ByteString
        getMessageBytes();

    /**
     * <pre>
     * Time at which previous execution of the container started
     * +optional
     * </pre>
     *
     * <code>optional int64 started_at = 5 [json_name = "startedAt", (.gen_bq_schema.bigquery) = { ... }</code>
     * @return Whether the startedAt field is set.
     */
    boolean hasStartedAt();
    /**
     * <pre>
     * Time at which previous execution of the container started
     * +optional
     * </pre>
     *
     * <code>optional int64 started_at = 5 [json_name = "startedAt", (.gen_bq_schema.bigquery) = { ... }</code>
     * @return The startedAt.
     */
    long getStartedAt();

    /**
     * <pre>
     * Time at which the container last terminated
     * +optional
     * </pre>
     *
     * <code>optional int64 finished_at = 6 [json_name = "finishedAt", (.gen_bq_schema.bigquery) = { ... }</code>
     * @return Whether the finishedAt field is set.
     */
    boolean hasFinishedAt();
    /**
     * <pre>
     * Time at which the container last terminated
     * +optional
     * </pre>
     *
     * <code>optional int64 finished_at = 6 [json_name = "finishedAt", (.gen_bq_schema.bigquery) = { ... }</code>
     * @return The finishedAt.
     */
    long getFinishedAt();

    /**
     * <pre>
     * Container's ID in the format '&lt;type&gt;://&lt;container_id&gt;'
     * +optional
     * </pre>
     *
     * <code>optional string container_id = 7 [json_name = "containerId"];</code>
     * @return Whether the containerId field is set.
     */
    boolean hasContainerId();
    /**
     * <pre>
     * Container's ID in the format '&lt;type&gt;://&lt;container_id&gt;'
     * +optional
     * </pre>
     *
     * <code>optional string container_id = 7 [json_name = "containerId"];</code>
     * @return The containerId.
     */
    java.lang.String getContainerId();
    /**
     * <pre>
     * Container's ID in the format '&lt;type&gt;://&lt;container_id&gt;'
     * +optional
     * </pre>
     *
     * <code>optional string container_id = 7 [json_name = "containerId"];</code>
     * @return The bytes for containerId.
     */
    com.google.protobuf.ByteString
        getContainerIdBytes();
  }
  /**
   * <pre>
   * ContainerStateTerminated is a terminated state of a container.
   * </pre>
   *
   * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated}
   */
  public static final class ContainerStateTerminated extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated)
      ContainerStateTerminatedOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ContainerStateTerminated.newBuilder() to construct.
    private ContainerStateTerminated(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ContainerStateTerminated() {
      reason_ = "";
      message_ = "";
      containerId_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ContainerStateTerminated();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ContainerStateTerminated_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ContainerStateTerminated_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated.Builder.class);
    }

    private int bitField0_;
    public static final int EXIT_CODE_FIELD_NUMBER = 1;
    private int exitCode_ = 0;
    /**
     * <pre>
     * Exit status from the last termination of the container
     * </pre>
     *
     * <code>int32 exit_code = 1 [json_name = "exitCode"];</code>
     * @return The exitCode.
     */
    @java.lang.Override
    public int getExitCode() {
      return exitCode_;
    }

    public static final int SIGNAL_FIELD_NUMBER = 2;
    private int signal_ = 0;
    /**
     * <pre>
     * Signal from the last termination of the container
     * +optional
     * </pre>
     *
     * <code>optional int32 signal = 2 [json_name = "signal"];</code>
     * @return Whether the signal field is set.
     */
    @java.lang.Override
    public boolean hasSignal() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Signal from the last termination of the container
     * +optional
     * </pre>
     *
     * <code>optional int32 signal = 2 [json_name = "signal"];</code>
     * @return The signal.
     */
    @java.lang.Override
    public int getSignal() {
      return signal_;
    }

    public static final int REASON_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object reason_ = "";
    /**
     * <pre>
     * (brief) reason from the last termination of the container
     * +optional
     * </pre>
     *
     * <code>optional string reason = 3 [json_name = "reason"];</code>
     * @return Whether the reason field is set.
     */
    @java.lang.Override
    public boolean hasReason() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * (brief) reason from the last termination of the container
     * +optional
     * </pre>
     *
     * <code>optional string reason = 3 [json_name = "reason"];</code>
     * @return The reason.
     */
    @java.lang.Override
    public java.lang.String getReason() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        reason_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * (brief) reason from the last termination of the container
     * +optional
     * </pre>
     *
     * <code>optional string reason = 3 [json_name = "reason"];</code>
     * @return The bytes for reason.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getReasonBytes() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        reason_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MESSAGE_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object message_ = "";
    /**
     * <pre>
     * Message regarding the last termination of the container
     * +optional
     * </pre>
     *
     * <code>optional string message = 4 [json_name = "message"];</code>
     * @return Whether the message field is set.
     */
    @java.lang.Override
    public boolean hasMessage() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Message regarding the last termination of the container
     * +optional
     * </pre>
     *
     * <code>optional string message = 4 [json_name = "message"];</code>
     * @return The message.
     */
    @java.lang.Override
    public java.lang.String getMessage() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        message_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Message regarding the last termination of the container
     * +optional
     * </pre>
     *
     * <code>optional string message = 4 [json_name = "message"];</code>
     * @return The bytes for message.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getMessageBytes() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        message_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STARTED_AT_FIELD_NUMBER = 5;
    private long startedAt_ = 0L;
    /**
     * <pre>
     * Time at which previous execution of the container started
     * +optional
     * </pre>
     *
     * <code>optional int64 started_at = 5 [json_name = "startedAt", (.gen_bq_schema.bigquery) = { ... }</code>
     * @return Whether the startedAt field is set.
     */
    @java.lang.Override
    public boolean hasStartedAt() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Time at which previous execution of the container started
     * +optional
     * </pre>
     *
     * <code>optional int64 started_at = 5 [json_name = "startedAt", (.gen_bq_schema.bigquery) = { ... }</code>
     * @return The startedAt.
     */
    @java.lang.Override
    public long getStartedAt() {
      return startedAt_;
    }

    public static final int FINISHED_AT_FIELD_NUMBER = 6;
    private long finishedAt_ = 0L;
    /**
     * <pre>
     * Time at which the container last terminated
     * +optional
     * </pre>
     *
     * <code>optional int64 finished_at = 6 [json_name = "finishedAt", (.gen_bq_schema.bigquery) = { ... }</code>
     * @return Whether the finishedAt field is set.
     */
    @java.lang.Override
    public boolean hasFinishedAt() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Time at which the container last terminated
     * +optional
     * </pre>
     *
     * <code>optional int64 finished_at = 6 [json_name = "finishedAt", (.gen_bq_schema.bigquery) = { ... }</code>
     * @return The finishedAt.
     */
    @java.lang.Override
    public long getFinishedAt() {
      return finishedAt_;
    }

    public static final int CONTAINER_ID_FIELD_NUMBER = 7;
    @SuppressWarnings("serial")
    private volatile java.lang.Object containerId_ = "";
    /**
     * <pre>
     * Container's ID in the format '&lt;type&gt;://&lt;container_id&gt;'
     * +optional
     * </pre>
     *
     * <code>optional string container_id = 7 [json_name = "containerId"];</code>
     * @return Whether the containerId field is set.
     */
    @java.lang.Override
    public boolean hasContainerId() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Container's ID in the format '&lt;type&gt;://&lt;container_id&gt;'
     * +optional
     * </pre>
     *
     * <code>optional string container_id = 7 [json_name = "containerId"];</code>
     * @return The containerId.
     */
    @java.lang.Override
    public java.lang.String getContainerId() {
      java.lang.Object ref = containerId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        containerId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Container's ID in the format '&lt;type&gt;://&lt;container_id&gt;'
     * +optional
     * </pre>
     *
     * <code>optional string container_id = 7 [json_name = "containerId"];</code>
     * @return The bytes for containerId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getContainerIdBytes() {
      java.lang.Object ref = containerId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        containerId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (exitCode_ != 0) {
        output.writeInt32(1, exitCode_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt32(2, signal_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, reason_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, message_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeInt64(5, startedAt_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeInt64(6, finishedAt_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 7, containerId_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (exitCode_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, exitCode_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, signal_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, reason_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, message_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(5, startedAt_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(6, finishedAt_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(7, containerId_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated)) {
        return super.equals(obj);
      }
      ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated other = (ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated) obj;

      if (getExitCode()
          != other.getExitCode()) return false;
      if (hasSignal() != other.hasSignal()) return false;
      if (hasSignal()) {
        if (getSignal()
            != other.getSignal()) return false;
      }
      if (hasReason() != other.hasReason()) return false;
      if (hasReason()) {
        if (!getReason()
            .equals(other.getReason())) return false;
      }
      if (hasMessage() != other.hasMessage()) return false;
      if (hasMessage()) {
        if (!getMessage()
            .equals(other.getMessage())) return false;
      }
      if (hasStartedAt() != other.hasStartedAt()) return false;
      if (hasStartedAt()) {
        if (getStartedAt()
            != other.getStartedAt()) return false;
      }
      if (hasFinishedAt() != other.hasFinishedAt()) return false;
      if (hasFinishedAt()) {
        if (getFinishedAt()
            != other.getFinishedAt()) return false;
      }
      if (hasContainerId() != other.hasContainerId()) return false;
      if (hasContainerId()) {
        if (!getContainerId()
            .equals(other.getContainerId())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + EXIT_CODE_FIELD_NUMBER;
      hash = (53 * hash) + getExitCode();
      if (hasSignal()) {
        hash = (37 * hash) + SIGNAL_FIELD_NUMBER;
        hash = (53 * hash) + getSignal();
      }
      if (hasReason()) {
        hash = (37 * hash) + REASON_FIELD_NUMBER;
        hash = (53 * hash) + getReason().hashCode();
      }
      if (hasMessage()) {
        hash = (37 * hash) + MESSAGE_FIELD_NUMBER;
        hash = (53 * hash) + getMessage().hashCode();
      }
      if (hasStartedAt()) {
        hash = (37 * hash) + STARTED_AT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getStartedAt());
      }
      if (hasFinishedAt()) {
        hash = (37 * hash) + FINISHED_AT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getFinishedAt());
      }
      if (hasContainerId()) {
        hash = (37 * hash) + CONTAINER_ID_FIELD_NUMBER;
        hash = (53 * hash) + getContainerId().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ContainerStateTerminated is a terminated state of a container.
     * </pre>
     *
     * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated)
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminatedOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ContainerStateTerminated_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ContainerStateTerminated_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated.Builder.class);
      }

      // Construct using ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        exitCode_ = 0;
        signal_ = 0;
        reason_ = "";
        message_ = "";
        startedAt_ = 0L;
        finishedAt_ = 0L;
        containerId_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ContainerStateTerminated_descriptor;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated getDefaultInstanceForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated.getDefaultInstance();
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated build() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated buildPartial() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated result = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.exitCode_ = exitCode_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.signal_ = signal_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.reason_ = reason_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.message_ = message_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.startedAt_ = startedAt_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.finishedAt_ = finishedAt_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.containerId_ = containerId_;
          to_bitField0_ |= 0x00000020;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated) {
          return mergeFrom((ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated other) {
        if (other == ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated.getDefaultInstance()) return this;
        if (other.getExitCode() != 0) {
          setExitCode(other.getExitCode());
        }
        if (other.hasSignal()) {
          setSignal(other.getSignal());
        }
        if (other.hasReason()) {
          reason_ = other.reason_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        if (other.hasMessage()) {
          message_ = other.message_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (other.hasStartedAt()) {
          setStartedAt(other.getStartedAt());
        }
        if (other.hasFinishedAt()) {
          setFinishedAt(other.getFinishedAt());
        }
        if (other.hasContainerId()) {
          containerId_ = other.containerId_;
          bitField0_ |= 0x00000040;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                exitCode_ = input.readInt32();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                signal_ = input.readInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 26: {
                reason_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                message_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 40: {
                startedAt_ = input.readInt64();
                bitField0_ |= 0x00000010;
                break;
              } // case 40
              case 48: {
                finishedAt_ = input.readInt64();
                bitField0_ |= 0x00000020;
                break;
              } // case 48
              case 58: {
                containerId_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000040;
                break;
              } // case 58
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int exitCode_ ;
      /**
       * <pre>
       * Exit status from the last termination of the container
       * </pre>
       *
       * <code>int32 exit_code = 1 [json_name = "exitCode"];</code>
       * @return The exitCode.
       */
      @java.lang.Override
      public int getExitCode() {
        return exitCode_;
      }
      /**
       * <pre>
       * Exit status from the last termination of the container
       * </pre>
       *
       * <code>int32 exit_code = 1 [json_name = "exitCode"];</code>
       * @param value The exitCode to set.
       * @return This builder for chaining.
       */
      public Builder setExitCode(int value) {

        exitCode_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Exit status from the last termination of the container
       * </pre>
       *
       * <code>int32 exit_code = 1 [json_name = "exitCode"];</code>
       * @return This builder for chaining.
       */
      public Builder clearExitCode() {
        bitField0_ = (bitField0_ & ~0x00000001);
        exitCode_ = 0;
        onChanged();
        return this;
      }

      private int signal_ ;
      /**
       * <pre>
       * Signal from the last termination of the container
       * +optional
       * </pre>
       *
       * <code>optional int32 signal = 2 [json_name = "signal"];</code>
       * @return Whether the signal field is set.
       */
      @java.lang.Override
      public boolean hasSignal() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Signal from the last termination of the container
       * +optional
       * </pre>
       *
       * <code>optional int32 signal = 2 [json_name = "signal"];</code>
       * @return The signal.
       */
      @java.lang.Override
      public int getSignal() {
        return signal_;
      }
      /**
       * <pre>
       * Signal from the last termination of the container
       * +optional
       * </pre>
       *
       * <code>optional int32 signal = 2 [json_name = "signal"];</code>
       * @param value The signal to set.
       * @return This builder for chaining.
       */
      public Builder setSignal(int value) {

        signal_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Signal from the last termination of the container
       * +optional
       * </pre>
       *
       * <code>optional int32 signal = 2 [json_name = "signal"];</code>
       * @return This builder for chaining.
       */
      public Builder clearSignal() {
        bitField0_ = (bitField0_ & ~0x00000002);
        signal_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object reason_ = "";
      /**
       * <pre>
       * (brief) reason from the last termination of the container
       * +optional
       * </pre>
       *
       * <code>optional string reason = 3 [json_name = "reason"];</code>
       * @return Whether the reason field is set.
       */
      public boolean hasReason() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * (brief) reason from the last termination of the container
       * +optional
       * </pre>
       *
       * <code>optional string reason = 3 [json_name = "reason"];</code>
       * @return The reason.
       */
      public java.lang.String getReason() {
        java.lang.Object ref = reason_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          reason_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * (brief) reason from the last termination of the container
       * +optional
       * </pre>
       *
       * <code>optional string reason = 3 [json_name = "reason"];</code>
       * @return The bytes for reason.
       */
      public com.google.protobuf.ByteString
          getReasonBytes() {
        java.lang.Object ref = reason_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          reason_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * (brief) reason from the last termination of the container
       * +optional
       * </pre>
       *
       * <code>optional string reason = 3 [json_name = "reason"];</code>
       * @param value The reason to set.
       * @return This builder for chaining.
       */
      public Builder setReason(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        reason_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * (brief) reason from the last termination of the container
       * +optional
       * </pre>
       *
       * <code>optional string reason = 3 [json_name = "reason"];</code>
       * @return This builder for chaining.
       */
      public Builder clearReason() {
        reason_ = getDefaultInstance().getReason();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * (brief) reason from the last termination of the container
       * +optional
       * </pre>
       *
       * <code>optional string reason = 3 [json_name = "reason"];</code>
       * @param value The bytes for reason to set.
       * @return This builder for chaining.
       */
      public Builder setReasonBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        reason_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private java.lang.Object message_ = "";
      /**
       * <pre>
       * Message regarding the last termination of the container
       * +optional
       * </pre>
       *
       * <code>optional string message = 4 [json_name = "message"];</code>
       * @return Whether the message field is set.
       */
      public boolean hasMessage() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Message regarding the last termination of the container
       * +optional
       * </pre>
       *
       * <code>optional string message = 4 [json_name = "message"];</code>
       * @return The message.
       */
      public java.lang.String getMessage() {
        java.lang.Object ref = message_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          message_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Message regarding the last termination of the container
       * +optional
       * </pre>
       *
       * <code>optional string message = 4 [json_name = "message"];</code>
       * @return The bytes for message.
       */
      public com.google.protobuf.ByteString
          getMessageBytes() {
        java.lang.Object ref = message_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          message_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Message regarding the last termination of the container
       * +optional
       * </pre>
       *
       * <code>optional string message = 4 [json_name = "message"];</code>
       * @param value The message to set.
       * @return This builder for chaining.
       */
      public Builder setMessage(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        message_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Message regarding the last termination of the container
       * +optional
       * </pre>
       *
       * <code>optional string message = 4 [json_name = "message"];</code>
       * @return This builder for chaining.
       */
      public Builder clearMessage() {
        message_ = getDefaultInstance().getMessage();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Message regarding the last termination of the container
       * +optional
       * </pre>
       *
       * <code>optional string message = 4 [json_name = "message"];</code>
       * @param value The bytes for message to set.
       * @return This builder for chaining.
       */
      public Builder setMessageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        message_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private long startedAt_ ;
      /**
       * <pre>
       * Time at which previous execution of the container started
       * +optional
       * </pre>
       *
       * <code>optional int64 started_at = 5 [json_name = "startedAt", (.gen_bq_schema.bigquery) = { ... }</code>
       * @return Whether the startedAt field is set.
       */
      @java.lang.Override
      public boolean hasStartedAt() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Time at which previous execution of the container started
       * +optional
       * </pre>
       *
       * <code>optional int64 started_at = 5 [json_name = "startedAt", (.gen_bq_schema.bigquery) = { ... }</code>
       * @return The startedAt.
       */
      @java.lang.Override
      public long getStartedAt() {
        return startedAt_;
      }
      /**
       * <pre>
       * Time at which previous execution of the container started
       * +optional
       * </pre>
       *
       * <code>optional int64 started_at = 5 [json_name = "startedAt", (.gen_bq_schema.bigquery) = { ... }</code>
       * @param value The startedAt to set.
       * @return This builder for chaining.
       */
      public Builder setStartedAt(long value) {

        startedAt_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Time at which previous execution of the container started
       * +optional
       * </pre>
       *
       * <code>optional int64 started_at = 5 [json_name = "startedAt", (.gen_bq_schema.bigquery) = { ... }</code>
       * @return This builder for chaining.
       */
      public Builder clearStartedAt() {
        bitField0_ = (bitField0_ & ~0x00000010);
        startedAt_ = 0L;
        onChanged();
        return this;
      }

      private long finishedAt_ ;
      /**
       * <pre>
       * Time at which the container last terminated
       * +optional
       * </pre>
       *
       * <code>optional int64 finished_at = 6 [json_name = "finishedAt", (.gen_bq_schema.bigquery) = { ... }</code>
       * @return Whether the finishedAt field is set.
       */
      @java.lang.Override
      public boolean hasFinishedAt() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Time at which the container last terminated
       * +optional
       * </pre>
       *
       * <code>optional int64 finished_at = 6 [json_name = "finishedAt", (.gen_bq_schema.bigquery) = { ... }</code>
       * @return The finishedAt.
       */
      @java.lang.Override
      public long getFinishedAt() {
        return finishedAt_;
      }
      /**
       * <pre>
       * Time at which the container last terminated
       * +optional
       * </pre>
       *
       * <code>optional int64 finished_at = 6 [json_name = "finishedAt", (.gen_bq_schema.bigquery) = { ... }</code>
       * @param value The finishedAt to set.
       * @return This builder for chaining.
       */
      public Builder setFinishedAt(long value) {

        finishedAt_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Time at which the container last terminated
       * +optional
       * </pre>
       *
       * <code>optional int64 finished_at = 6 [json_name = "finishedAt", (.gen_bq_schema.bigquery) = { ... }</code>
       * @return This builder for chaining.
       */
      public Builder clearFinishedAt() {
        bitField0_ = (bitField0_ & ~0x00000020);
        finishedAt_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object containerId_ = "";
      /**
       * <pre>
       * Container's ID in the format '&lt;type&gt;://&lt;container_id&gt;'
       * +optional
       * </pre>
       *
       * <code>optional string container_id = 7 [json_name = "containerId"];</code>
       * @return Whether the containerId field is set.
       */
      public boolean hasContainerId() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Container's ID in the format '&lt;type&gt;://&lt;container_id&gt;'
       * +optional
       * </pre>
       *
       * <code>optional string container_id = 7 [json_name = "containerId"];</code>
       * @return The containerId.
       */
      public java.lang.String getContainerId() {
        java.lang.Object ref = containerId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          containerId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Container's ID in the format '&lt;type&gt;://&lt;container_id&gt;'
       * +optional
       * </pre>
       *
       * <code>optional string container_id = 7 [json_name = "containerId"];</code>
       * @return The bytes for containerId.
       */
      public com.google.protobuf.ByteString
          getContainerIdBytes() {
        java.lang.Object ref = containerId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          containerId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Container's ID in the format '&lt;type&gt;://&lt;container_id&gt;'
       * +optional
       * </pre>
       *
       * <code>optional string container_id = 7 [json_name = "containerId"];</code>
       * @param value The containerId to set.
       * @return This builder for chaining.
       */
      public Builder setContainerId(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        containerId_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Container's ID in the format '&lt;type&gt;://&lt;container_id&gt;'
       * +optional
       * </pre>
       *
       * <code>optional string container_id = 7 [json_name = "containerId"];</code>
       * @return This builder for chaining.
       */
      public Builder clearContainerId() {
        containerId_ = getDefaultInstance().getContainerId();
        bitField0_ = (bitField0_ & ~0x00000040);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Container's ID in the format '&lt;type&gt;://&lt;container_id&gt;'
       * +optional
       * </pre>
       *
       * <code>optional string container_id = 7 [json_name = "containerId"];</code>
       * @param value The bytes for containerId to set.
       * @return This builder for chaining.
       */
      public Builder setContainerIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        containerId_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated)
    }

    // @@protoc_insertion_point(class_scope:chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated)
    private static final ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated();
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ContainerStateTerminated>
        PARSER = new com.google.protobuf.AbstractParser<ContainerStateTerminated>() {
      @java.lang.Override
      public ContainerStateTerminated parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ContainerStateTerminated> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ContainerStateTerminated> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateTerminated getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface EnvVarOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chalk.pubsub.v1.PodStatusPubSub.EnvVar)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Name of the environment variable. Must be a C_IDENTIFIER.
     * </pre>
     *
     * <code>string name = 1 [json_name = "name"];</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * Name of the environment variable. Must be a C_IDENTIFIER.
     * </pre>
     *
     * <code>string name = 1 [json_name = "name"];</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * Variable references $(VAR_NAME) are expanded
     * using the previously defined environment variables in the container and
     * any service environment variables. If a variable cannot be resolved,
     * the reference in the input string will be unchanged. Double $$ are reduced
     * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
     * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
     * Escaped references will never be expanded, regardless of whether the variable
     * exists or not.
     * Defaults to "".
     * </pre>
     *
     * <code>string value = 2 [json_name = "value"];</code>
     * @return The value.
     */
    java.lang.String getValue();
    /**
     * <pre>
     * Variable references $(VAR_NAME) are expanded
     * using the previously defined environment variables in the container and
     * any service environment variables. If a variable cannot be resolved,
     * the reference in the input string will be unchanged. Double $$ are reduced
     * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
     * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
     * Escaped references will never be expanded, regardless of whether the variable
     * exists or not.
     * Defaults to "".
     * </pre>
     *
     * <code>string value = 2 [json_name = "value"];</code>
     * @return The bytes for value.
     */
    com.google.protobuf.ByteString
        getValueBytes();
  }
  /**
   * <pre>
   * EnvVar represents an environment variable present in a Container.
   * </pre>
   *
   * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.EnvVar}
   */
  public static final class EnvVar extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chalk.pubsub.v1.PodStatusPubSub.EnvVar)
      EnvVarOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use EnvVar.newBuilder() to construct.
    private EnvVar(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private EnvVar() {
      name_ = "";
      value_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new EnvVar();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_EnvVar_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_EnvVar_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar.Builder.class);
    }

    public static final int NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * Name of the environment variable. Must be a C_IDENTIFIER.
     * </pre>
     *
     * <code>string name = 1 [json_name = "name"];</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Name of the environment variable. Must be a C_IDENTIFIER.
     * </pre>
     *
     * <code>string name = 1 [json_name = "name"];</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VALUE_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object value_ = "";
    /**
     * <pre>
     * Variable references $(VAR_NAME) are expanded
     * using the previously defined environment variables in the container and
     * any service environment variables. If a variable cannot be resolved,
     * the reference in the input string will be unchanged. Double $$ are reduced
     * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
     * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
     * Escaped references will never be expanded, regardless of whether the variable
     * exists or not.
     * Defaults to "".
     * </pre>
     *
     * <code>string value = 2 [json_name = "value"];</code>
     * @return The value.
     */
    @java.lang.Override
    public java.lang.String getValue() {
      java.lang.Object ref = value_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        value_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Variable references $(VAR_NAME) are expanded
     * using the previously defined environment variables in the container and
     * any service environment variables. If a variable cannot be resolved,
     * the reference in the input string will be unchanged. Double $$ are reduced
     * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
     * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
     * Escaped references will never be expanded, regardless of whether the variable
     * exists or not.
     * Defaults to "".
     * </pre>
     *
     * <code>string value = 2 [json_name = "value"];</code>
     * @return The bytes for value.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getValueBytes() {
      java.lang.Object ref = value_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        value_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(name_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(value_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, value_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(name_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(value_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, value_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar)) {
        return super.equals(obj);
      }
      ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar other = (ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar) obj;

      if (!getName()
          .equals(other.getName())) return false;
      if (!getValue()
          .equals(other.getValue())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      hash = (37 * hash) + VALUE_FIELD_NUMBER;
      hash = (53 * hash) + getValue().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * EnvVar represents an environment variable present in a Container.
     * </pre>
     *
     * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.EnvVar}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chalk.pubsub.v1.PodStatusPubSub.EnvVar)
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVarOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_EnvVar_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_EnvVar_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar.Builder.class);
      }

      // Construct using ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        name_ = "";
        value_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_EnvVar_descriptor;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar getDefaultInstanceForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar.getDefaultInstance();
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar build() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar buildPartial() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar result = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.name_ = name_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.value_ = value_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar) {
          return mergeFrom((ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar other) {
        if (other == ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar.getDefaultInstance()) return this;
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (!other.getValue().isEmpty()) {
          value_ = other.value_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                name_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                value_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * Name of the environment variable. Must be a C_IDENTIFIER.
       * </pre>
       *
       * <code>string name = 1 [json_name = "name"];</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Name of the environment variable. Must be a C_IDENTIFIER.
       * </pre>
       *
       * <code>string name = 1 [json_name = "name"];</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Name of the environment variable. Must be a C_IDENTIFIER.
       * </pre>
       *
       * <code>string name = 1 [json_name = "name"];</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name of the environment variable. Must be a C_IDENTIFIER.
       * </pre>
       *
       * <code>string name = 1 [json_name = "name"];</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name of the environment variable. Must be a C_IDENTIFIER.
       * </pre>
       *
       * <code>string name = 1 [json_name = "name"];</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object value_ = "";
      /**
       * <pre>
       * Variable references $(VAR_NAME) are expanded
       * using the previously defined environment variables in the container and
       * any service environment variables. If a variable cannot be resolved,
       * the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
       * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
       * Escaped references will never be expanded, regardless of whether the variable
       * exists or not.
       * Defaults to "".
       * </pre>
       *
       * <code>string value = 2 [json_name = "value"];</code>
       * @return The value.
       */
      public java.lang.String getValue() {
        java.lang.Object ref = value_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          value_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Variable references $(VAR_NAME) are expanded
       * using the previously defined environment variables in the container and
       * any service environment variables. If a variable cannot be resolved,
       * the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
       * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
       * Escaped references will never be expanded, regardless of whether the variable
       * exists or not.
       * Defaults to "".
       * </pre>
       *
       * <code>string value = 2 [json_name = "value"];</code>
       * @return The bytes for value.
       */
      public com.google.protobuf.ByteString
          getValueBytes() {
        java.lang.Object ref = value_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          value_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Variable references $(VAR_NAME) are expanded
       * using the previously defined environment variables in the container and
       * any service environment variables. If a variable cannot be resolved,
       * the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
       * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
       * Escaped references will never be expanded, regardless of whether the variable
       * exists or not.
       * Defaults to "".
       * </pre>
       *
       * <code>string value = 2 [json_name = "value"];</code>
       * @param value The value to set.
       * @return This builder for chaining.
       */
      public Builder setValue(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        value_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Variable references $(VAR_NAME) are expanded
       * using the previously defined environment variables in the container and
       * any service environment variables. If a variable cannot be resolved,
       * the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
       * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
       * Escaped references will never be expanded, regardless of whether the variable
       * exists or not.
       * Defaults to "".
       * </pre>
       *
       * <code>string value = 2 [json_name = "value"];</code>
       * @return This builder for chaining.
       */
      public Builder clearValue() {
        value_ = getDefaultInstance().getValue();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Variable references $(VAR_NAME) are expanded
       * using the previously defined environment variables in the container and
       * any service environment variables. If a variable cannot be resolved,
       * the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
       * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
       * Escaped references will never be expanded, regardless of whether the variable
       * exists or not.
       * Defaults to "".
       * </pre>
       *
       * <code>string value = 2 [json_name = "value"];</code>
       * @param value The bytes for value to set.
       * @return This builder for chaining.
       */
      public Builder setValueBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        value_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chalk.pubsub.v1.PodStatusPubSub.EnvVar)
    }

    // @@protoc_insertion_point(class_scope:chalk.pubsub.v1.PodStatusPubSub.EnvVar)
    private static final ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar();
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<EnvVar>
        PARSER = new com.google.protobuf.AbstractParser<EnvVar>() {
      @java.lang.Override
      public EnvVar parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<EnvVar> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<EnvVar> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ContainerOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chalk.pubsub.v1.PodStatusPubSub.Container)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Name of the container specified as a DNS_LABEL.
     * Each container in a pod must have a unique name (DNS_LABEL).
     * Cannot be updated.
     * </pre>
     *
     * <code>string name = 1 [json_name = "name"];</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * Name of the container specified as a DNS_LABEL.
     * Each container in a pod must have a unique name (DNS_LABEL).
     * Cannot be updated.
     * </pre>
     *
     * <code>string name = 1 [json_name = "name"];</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * Container image name.
     * More info: https://kubernetes.io/docs/concepts/containers/images
     * This field is optional to allow higher level config management to default or override
     * container images in workload controllers like Deployments and StatefulSets.
     * +optional
     * </pre>
     *
     * <code>optional string image = 2 [json_name = "image"];</code>
     * @return Whether the image field is set.
     */
    boolean hasImage();
    /**
     * <pre>
     * Container image name.
     * More info: https://kubernetes.io/docs/concepts/containers/images
     * This field is optional to allow higher level config management to default or override
     * container images in workload controllers like Deployments and StatefulSets.
     * +optional
     * </pre>
     *
     * <code>optional string image = 2 [json_name = "image"];</code>
     * @return The image.
     */
    java.lang.String getImage();
    /**
     * <pre>
     * Container image name.
     * More info: https://kubernetes.io/docs/concepts/containers/images
     * This field is optional to allow higher level config management to default or override
     * container images in workload controllers like Deployments and StatefulSets.
     * +optional
     * </pre>
     *
     * <code>optional string image = 2 [json_name = "image"];</code>
     * @return The bytes for image.
     */
    com.google.protobuf.ByteString
        getImageBytes();

    /**
     * <pre>
     * Entrypoint array. Not executed within a shell.
     * The container image's ENTRYPOINT is used if this is not provided.
     * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
     * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
     * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
     * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
     * of whether the variable exists or not. Cannot be updated.
     * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string command = 3 [json_name = "command"];</code>
     * @return A list containing the command.
     */
    java.util.List<java.lang.String>
        getCommandList();
    /**
     * <pre>
     * Entrypoint array. Not executed within a shell.
     * The container image's ENTRYPOINT is used if this is not provided.
     * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
     * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
     * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
     * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
     * of whether the variable exists or not. Cannot be updated.
     * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string command = 3 [json_name = "command"];</code>
     * @return The count of command.
     */
    int getCommandCount();
    /**
     * <pre>
     * Entrypoint array. Not executed within a shell.
     * The container image's ENTRYPOINT is used if this is not provided.
     * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
     * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
     * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
     * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
     * of whether the variable exists or not. Cannot be updated.
     * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string command = 3 [json_name = "command"];</code>
     * @param index The index of the element to return.
     * @return The command at the given index.
     */
    java.lang.String getCommand(int index);
    /**
     * <pre>
     * Entrypoint array. Not executed within a shell.
     * The container image's ENTRYPOINT is used if this is not provided.
     * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
     * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
     * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
     * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
     * of whether the variable exists or not. Cannot be updated.
     * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string command = 3 [json_name = "command"];</code>
     * @param index The index of the value to return.
     * @return The bytes of the command at the given index.
     */
    com.google.protobuf.ByteString
        getCommandBytes(int index);

    /**
     * <pre>
     * Arguments to the entrypoint.
     * The container image's CMD is used if this is not provided.
     * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
     * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
     * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
     * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
     * of whether the variable exists or not. Cannot be updated.
     * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string args = 4 [json_name = "args"];</code>
     * @return A list containing the args.
     */
    java.util.List<java.lang.String>
        getArgsList();
    /**
     * <pre>
     * Arguments to the entrypoint.
     * The container image's CMD is used if this is not provided.
     * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
     * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
     * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
     * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
     * of whether the variable exists or not. Cannot be updated.
     * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string args = 4 [json_name = "args"];</code>
     * @return The count of args.
     */
    int getArgsCount();
    /**
     * <pre>
     * Arguments to the entrypoint.
     * The container image's CMD is used if this is not provided.
     * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
     * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
     * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
     * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
     * of whether the variable exists or not. Cannot be updated.
     * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string args = 4 [json_name = "args"];</code>
     * @param index The index of the element to return.
     * @return The args at the given index.
     */
    java.lang.String getArgs(int index);
    /**
     * <pre>
     * Arguments to the entrypoint.
     * The container image's CMD is used if this is not provided.
     * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
     * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
     * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
     * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
     * of whether the variable exists or not. Cannot be updated.
     * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string args = 4 [json_name = "args"];</code>
     * @param index The index of the value to return.
     * @return The bytes of the args at the given index.
     */
    com.google.protobuf.ByteString
        getArgsBytes(int index);

    /**
     * <pre>
     * Container's working directory.
     * If not specified, the container runtime's default will be used, which
     * might be configured in the container image.
     * Cannot be updated.
     * +optional
     * </pre>
     *
     * <code>optional string working_dir = 5 [json_name = "workingDir"];</code>
     * @return Whether the workingDir field is set.
     */
    boolean hasWorkingDir();
    /**
     * <pre>
     * Container's working directory.
     * If not specified, the container runtime's default will be used, which
     * might be configured in the container image.
     * Cannot be updated.
     * +optional
     * </pre>
     *
     * <code>optional string working_dir = 5 [json_name = "workingDir"];</code>
     * @return The workingDir.
     */
    java.lang.String getWorkingDir();
    /**
     * <pre>
     * Container's working directory.
     * If not specified, the container runtime's default will be used, which
     * might be configured in the container image.
     * Cannot be updated.
     * +optional
     * </pre>
     *
     * <code>optional string working_dir = 5 [json_name = "workingDir"];</code>
     * @return The bytes for workingDir.
     */
    com.google.protobuf.ByteString
        getWorkingDirBytes();

    /**
     * <pre>
     * List of environment variables to set in the container.
     * Cannot be updated.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
     */
    java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar> 
        getEnvList();
    /**
     * <pre>
     * List of environment variables to set in the container.
     * Cannot be updated.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar getEnv(int index);
    /**
     * <pre>
     * List of environment variables to set in the container.
     * Cannot be updated.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
     */
    int getEnvCount();
    /**
     * <pre>
     * List of environment variables to set in the container.
     * Cannot be updated.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
     */
    java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVarOrBuilder> 
        getEnvOrBuilderList();
    /**
     * <pre>
     * List of environment variables to set in the container.
     * Cannot be updated.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVarOrBuilder getEnvOrBuilder(
        int index);

    /**
     * <pre>
     * Compute Resources required by this container.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements resources = 8 [json_name = "resources"];</code>
     * @return Whether the resources field is set.
     */
    boolean hasResources();
    /**
     * <pre>
     * Compute Resources required by this container.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements resources = 8 [json_name = "resources"];</code>
     * @return The resources.
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements getResources();
    /**
     * <pre>
     * Compute Resources required by this container.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements resources = 8 [json_name = "resources"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirementsOrBuilder getResourcesOrBuilder();

    /**
     * <pre>
     * RestartPolicy defines the restart behavior of individual containers in a pod.
     * This field may only be set for init containers, and the only allowed value is "Always".
     * For non-init containers or when this field is not specified,
     * the restart behavior is defined by the Pod's restart policy and the container type.
     * Setting the RestartPolicy as "Always" for the init container will have the following effect:
     * this init container will be continually restarted on
     * exit until all regular containers have terminated. Once all regular
     * containers have completed, all init containers with restartPolicy "Always"
     * will be shut down. This lifecycle differs from normal init containers and
     * is often referred to as a "sidecar" container. Although this init
     * container still starts in the init container sequence, it does not wait
     * for the container to complete before proceeding to the next init
     * container. Instead, the next init container starts immediately after this
     * init container is started, or after any startupProbe has successfully
     * completed.
     * +featureGate=SidecarContainers
     * +optional
     * </pre>
     *
     * <code>optional string restart_policy = 24 [json_name = "restartPolicy"];</code>
     * @return Whether the restartPolicy field is set.
     */
    boolean hasRestartPolicy();
    /**
     * <pre>
     * RestartPolicy defines the restart behavior of individual containers in a pod.
     * This field may only be set for init containers, and the only allowed value is "Always".
     * For non-init containers or when this field is not specified,
     * the restart behavior is defined by the Pod's restart policy and the container type.
     * Setting the RestartPolicy as "Always" for the init container will have the following effect:
     * this init container will be continually restarted on
     * exit until all regular containers have terminated. Once all regular
     * containers have completed, all init containers with restartPolicy "Always"
     * will be shut down. This lifecycle differs from normal init containers and
     * is often referred to as a "sidecar" container. Although this init
     * container still starts in the init container sequence, it does not wait
     * for the container to complete before proceeding to the next init
     * container. Instead, the next init container starts immediately after this
     * init container is started, or after any startupProbe has successfully
     * completed.
     * +featureGate=SidecarContainers
     * +optional
     * </pre>
     *
     * <code>optional string restart_policy = 24 [json_name = "restartPolicy"];</code>
     * @return The restartPolicy.
     */
    java.lang.String getRestartPolicy();
    /**
     * <pre>
     * RestartPolicy defines the restart behavior of individual containers in a pod.
     * This field may only be set for init containers, and the only allowed value is "Always".
     * For non-init containers or when this field is not specified,
     * the restart behavior is defined by the Pod's restart policy and the container type.
     * Setting the RestartPolicy as "Always" for the init container will have the following effect:
     * this init container will be continually restarted on
     * exit until all regular containers have terminated. Once all regular
     * containers have completed, all init containers with restartPolicy "Always"
     * will be shut down. This lifecycle differs from normal init containers and
     * is often referred to as a "sidecar" container. Although this init
     * container still starts in the init container sequence, it does not wait
     * for the container to complete before proceeding to the next init
     * container. Instead, the next init container starts immediately after this
     * init container is started, or after any startupProbe has successfully
     * completed.
     * +featureGate=SidecarContainers
     * +optional
     * </pre>
     *
     * <code>optional string restart_policy = 24 [json_name = "restartPolicy"];</code>
     * @return The bytes for restartPolicy.
     */
    com.google.protobuf.ByteString
        getRestartPolicyBytes();

    /**
     * <pre>
     * Optional: Path at which the file to which the container's termination message
     * will be written is mounted into the container's filesystem.
     * Message written is intended to be brief final status, such as an assertion failure message.
     * Will be truncated by the node if greater than 4096 bytes. The total message length across
     * all containers will be limited to 12kb.
     * Defaults to /dev/termination-log.
     * Cannot be updated.
     * +optional
     * </pre>
     *
     * <code>optional string termination_message_path = 13 [json_name = "terminationMessagePath"];</code>
     * @return Whether the terminationMessagePath field is set.
     */
    boolean hasTerminationMessagePath();
    /**
     * <pre>
     * Optional: Path at which the file to which the container's termination message
     * will be written is mounted into the container's filesystem.
     * Message written is intended to be brief final status, such as an assertion failure message.
     * Will be truncated by the node if greater than 4096 bytes. The total message length across
     * all containers will be limited to 12kb.
     * Defaults to /dev/termination-log.
     * Cannot be updated.
     * +optional
     * </pre>
     *
     * <code>optional string termination_message_path = 13 [json_name = "terminationMessagePath"];</code>
     * @return The terminationMessagePath.
     */
    java.lang.String getTerminationMessagePath();
    /**
     * <pre>
     * Optional: Path at which the file to which the container's termination message
     * will be written is mounted into the container's filesystem.
     * Message written is intended to be brief final status, such as an assertion failure message.
     * Will be truncated by the node if greater than 4096 bytes. The total message length across
     * all containers will be limited to 12kb.
     * Defaults to /dev/termination-log.
     * Cannot be updated.
     * +optional
     * </pre>
     *
     * <code>optional string termination_message_path = 13 [json_name = "terminationMessagePath"];</code>
     * @return The bytes for terminationMessagePath.
     */
    com.google.protobuf.ByteString
        getTerminationMessagePathBytes();

    /**
     * <pre>
     * Indicate how the termination message should be populated. File will use the contents of
     * terminationMessagePath to populate the container status message on both success and failure.
     * FallbackToLogsOnError will use the last chunk of container log output if the termination
     * message file is empty and the container exited with an error.
     * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
     * Defaults to File.
     * Cannot be updated.
     * +optional
     * </pre>
     *
     * <code>optional string termination_message_policy = 20 [json_name = "terminationMessagePolicy"];</code>
     * @return Whether the terminationMessagePolicy field is set.
     */
    boolean hasTerminationMessagePolicy();
    /**
     * <pre>
     * Indicate how the termination message should be populated. File will use the contents of
     * terminationMessagePath to populate the container status message on both success and failure.
     * FallbackToLogsOnError will use the last chunk of container log output if the termination
     * message file is empty and the container exited with an error.
     * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
     * Defaults to File.
     * Cannot be updated.
     * +optional
     * </pre>
     *
     * <code>optional string termination_message_policy = 20 [json_name = "terminationMessagePolicy"];</code>
     * @return The terminationMessagePolicy.
     */
    java.lang.String getTerminationMessagePolicy();
    /**
     * <pre>
     * Indicate how the termination message should be populated. File will use the contents of
     * terminationMessagePath to populate the container status message on both success and failure.
     * FallbackToLogsOnError will use the last chunk of container log output if the termination
     * message file is empty and the container exited with an error.
     * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
     * Defaults to File.
     * Cannot be updated.
     * +optional
     * </pre>
     *
     * <code>optional string termination_message_policy = 20 [json_name = "terminationMessagePolicy"];</code>
     * @return The bytes for terminationMessagePolicy.
     */
    com.google.protobuf.ByteString
        getTerminationMessagePolicyBytes();

    /**
     * <pre>
     * Image pull policy.
     * One of Always, Never, IfNotPresent.
     * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
     * +optional
     * </pre>
     *
     * <code>optional string image_pull_policy = 14 [json_name = "imagePullPolicy"];</code>
     * @return Whether the imagePullPolicy field is set.
     */
    boolean hasImagePullPolicy();
    /**
     * <pre>
     * Image pull policy.
     * One of Always, Never, IfNotPresent.
     * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
     * +optional
     * </pre>
     *
     * <code>optional string image_pull_policy = 14 [json_name = "imagePullPolicy"];</code>
     * @return The imagePullPolicy.
     */
    java.lang.String getImagePullPolicy();
    /**
     * <pre>
     * Image pull policy.
     * One of Always, Never, IfNotPresent.
     * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
     * +optional
     * </pre>
     *
     * <code>optional string image_pull_policy = 14 [json_name = "imagePullPolicy"];</code>
     * @return The bytes for imagePullPolicy.
     */
    com.google.protobuf.ByteString
        getImagePullPolicyBytes();

    /**
     * <pre>
     * Whether this container should allocate a buffer for stdin in the container runtime. If this
     * is not set, reads from stdin in the container will always result in EOF.
     * </pre>
     *
     * <code>bool stdin = 16 [json_name = "stdin"];</code>
     * @return The stdin.
     */
    boolean getStdin();

    /**
     * <pre>
     * Whether the container runtime should close the stdin channel after it has been opened by
     * a single attach. When stdin is true the stdin stream will remain open across multiple attach
     * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
     * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
     * at which time stdin is closed and remains closed until the container is restarted. If this
     * flag is false, a container processes that reads from stdin will never receive an EOF.
     * </pre>
     *
     * <code>bool stdin_once = 17 [json_name = "stdinOnce"];</code>
     * @return The stdinOnce.
     */
    boolean getStdinOnce();

    /**
     * <pre>
     * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
     * </pre>
     *
     * <code>bool tty = 18 [json_name = "tty"];</code>
     * @return The tty.
     */
    boolean getTty();
  }
  /**
   * <pre>
   * A single application container that you want to run within a pod.
   * </pre>
   *
   * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.Container}
   */
  public static final class Container extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chalk.pubsub.v1.PodStatusPubSub.Container)
      ContainerOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Container.newBuilder() to construct.
    private Container(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Container() {
      name_ = "";
      image_ = "";
      command_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      args_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      workingDir_ = "";
      env_ = java.util.Collections.emptyList();
      restartPolicy_ = "";
      terminationMessagePath_ = "";
      terminationMessagePolicy_ = "";
      imagePullPolicy_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Container();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_Container_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_Container_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * Name of the container specified as a DNS_LABEL.
     * Each container in a pod must have a unique name (DNS_LABEL).
     * Cannot be updated.
     * </pre>
     *
     * <code>string name = 1 [json_name = "name"];</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Name of the container specified as a DNS_LABEL.
     * Each container in a pod must have a unique name (DNS_LABEL).
     * Cannot be updated.
     * </pre>
     *
     * <code>string name = 1 [json_name = "name"];</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int IMAGE_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object image_ = "";
    /**
     * <pre>
     * Container image name.
     * More info: https://kubernetes.io/docs/concepts/containers/images
     * This field is optional to allow higher level config management to default or override
     * container images in workload controllers like Deployments and StatefulSets.
     * +optional
     * </pre>
     *
     * <code>optional string image = 2 [json_name = "image"];</code>
     * @return Whether the image field is set.
     */
    @java.lang.Override
    public boolean hasImage() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Container image name.
     * More info: https://kubernetes.io/docs/concepts/containers/images
     * This field is optional to allow higher level config management to default or override
     * container images in workload controllers like Deployments and StatefulSets.
     * +optional
     * </pre>
     *
     * <code>optional string image = 2 [json_name = "image"];</code>
     * @return The image.
     */
    @java.lang.Override
    public java.lang.String getImage() {
      java.lang.Object ref = image_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        image_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Container image name.
     * More info: https://kubernetes.io/docs/concepts/containers/images
     * This field is optional to allow higher level config management to default or override
     * container images in workload controllers like Deployments and StatefulSets.
     * +optional
     * </pre>
     *
     * <code>optional string image = 2 [json_name = "image"];</code>
     * @return The bytes for image.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getImageBytes() {
      java.lang.Object ref = image_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        image_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int COMMAND_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList command_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * Entrypoint array. Not executed within a shell.
     * The container image's ENTRYPOINT is used if this is not provided.
     * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
     * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
     * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
     * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
     * of whether the variable exists or not. Cannot be updated.
     * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string command = 3 [json_name = "command"];</code>
     * @return A list containing the command.
     */
    public com.google.protobuf.ProtocolStringList
        getCommandList() {
      return command_;
    }
    /**
     * <pre>
     * Entrypoint array. Not executed within a shell.
     * The container image's ENTRYPOINT is used if this is not provided.
     * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
     * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
     * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
     * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
     * of whether the variable exists or not. Cannot be updated.
     * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string command = 3 [json_name = "command"];</code>
     * @return The count of command.
     */
    public int getCommandCount() {
      return command_.size();
    }
    /**
     * <pre>
     * Entrypoint array. Not executed within a shell.
     * The container image's ENTRYPOINT is used if this is not provided.
     * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
     * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
     * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
     * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
     * of whether the variable exists or not. Cannot be updated.
     * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string command = 3 [json_name = "command"];</code>
     * @param index The index of the element to return.
     * @return The command at the given index.
     */
    public java.lang.String getCommand(int index) {
      return command_.get(index);
    }
    /**
     * <pre>
     * Entrypoint array. Not executed within a shell.
     * The container image's ENTRYPOINT is used if this is not provided.
     * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
     * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
     * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
     * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
     * of whether the variable exists or not. Cannot be updated.
     * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string command = 3 [json_name = "command"];</code>
     * @param index The index of the value to return.
     * @return The bytes of the command at the given index.
     */
    public com.google.protobuf.ByteString
        getCommandBytes(int index) {
      return command_.getByteString(index);
    }

    public static final int ARGS_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList args_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * Arguments to the entrypoint.
     * The container image's CMD is used if this is not provided.
     * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
     * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
     * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
     * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
     * of whether the variable exists or not. Cannot be updated.
     * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string args = 4 [json_name = "args"];</code>
     * @return A list containing the args.
     */
    public com.google.protobuf.ProtocolStringList
        getArgsList() {
      return args_;
    }
    /**
     * <pre>
     * Arguments to the entrypoint.
     * The container image's CMD is used if this is not provided.
     * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
     * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
     * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
     * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
     * of whether the variable exists or not. Cannot be updated.
     * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string args = 4 [json_name = "args"];</code>
     * @return The count of args.
     */
    public int getArgsCount() {
      return args_.size();
    }
    /**
     * <pre>
     * Arguments to the entrypoint.
     * The container image's CMD is used if this is not provided.
     * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
     * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
     * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
     * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
     * of whether the variable exists or not. Cannot be updated.
     * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string args = 4 [json_name = "args"];</code>
     * @param index The index of the element to return.
     * @return The args at the given index.
     */
    public java.lang.String getArgs(int index) {
      return args_.get(index);
    }
    /**
     * <pre>
     * Arguments to the entrypoint.
     * The container image's CMD is used if this is not provided.
     * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
     * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
     * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
     * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
     * of whether the variable exists or not. Cannot be updated.
     * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string args = 4 [json_name = "args"];</code>
     * @param index The index of the value to return.
     * @return The bytes of the args at the given index.
     */
    public com.google.protobuf.ByteString
        getArgsBytes(int index) {
      return args_.getByteString(index);
    }

    public static final int WORKING_DIR_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private volatile java.lang.Object workingDir_ = "";
    /**
     * <pre>
     * Container's working directory.
     * If not specified, the container runtime's default will be used, which
     * might be configured in the container image.
     * Cannot be updated.
     * +optional
     * </pre>
     *
     * <code>optional string working_dir = 5 [json_name = "workingDir"];</code>
     * @return Whether the workingDir field is set.
     */
    @java.lang.Override
    public boolean hasWorkingDir() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Container's working directory.
     * If not specified, the container runtime's default will be used, which
     * might be configured in the container image.
     * Cannot be updated.
     * +optional
     * </pre>
     *
     * <code>optional string working_dir = 5 [json_name = "workingDir"];</code>
     * @return The workingDir.
     */
    @java.lang.Override
    public java.lang.String getWorkingDir() {
      java.lang.Object ref = workingDir_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        workingDir_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Container's working directory.
     * If not specified, the container runtime's default will be used, which
     * might be configured in the container image.
     * Cannot be updated.
     * +optional
     * </pre>
     *
     * <code>optional string working_dir = 5 [json_name = "workingDir"];</code>
     * @return The bytes for workingDir.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getWorkingDirBytes() {
      java.lang.Object ref = workingDir_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        workingDir_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ENV_FIELD_NUMBER = 7;
    @SuppressWarnings("serial")
    private java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar> env_;
    /**
     * <pre>
     * List of environment variables to set in the container.
     * Cannot be updated.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
     */
    @java.lang.Override
    public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar> getEnvList() {
      return env_;
    }
    /**
     * <pre>
     * List of environment variables to set in the container.
     * Cannot be updated.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
     */
    @java.lang.Override
    public java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVarOrBuilder> 
        getEnvOrBuilderList() {
      return env_;
    }
    /**
     * <pre>
     * List of environment variables to set in the container.
     * Cannot be updated.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
     */
    @java.lang.Override
    public int getEnvCount() {
      return env_.size();
    }
    /**
     * <pre>
     * List of environment variables to set in the container.
     * Cannot be updated.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar getEnv(int index) {
      return env_.get(index);
    }
    /**
     * <pre>
     * List of environment variables to set in the container.
     * Cannot be updated.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVarOrBuilder getEnvOrBuilder(
        int index) {
      return env_.get(index);
    }

    public static final int RESOURCES_FIELD_NUMBER = 8;
    private ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements resources_;
    /**
     * <pre>
     * Compute Resources required by this container.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements resources = 8 [json_name = "resources"];</code>
     * @return Whether the resources field is set.
     */
    @java.lang.Override
    public boolean hasResources() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Compute Resources required by this container.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements resources = 8 [json_name = "resources"];</code>
     * @return The resources.
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements getResources() {
      return resources_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements.getDefaultInstance() : resources_;
    }
    /**
     * <pre>
     * Compute Resources required by this container.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements resources = 8 [json_name = "resources"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirementsOrBuilder getResourcesOrBuilder() {
      return resources_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements.getDefaultInstance() : resources_;
    }

    public static final int RESTART_POLICY_FIELD_NUMBER = 24;
    @SuppressWarnings("serial")
    private volatile java.lang.Object restartPolicy_ = "";
    /**
     * <pre>
     * RestartPolicy defines the restart behavior of individual containers in a pod.
     * This field may only be set for init containers, and the only allowed value is "Always".
     * For non-init containers or when this field is not specified,
     * the restart behavior is defined by the Pod's restart policy and the container type.
     * Setting the RestartPolicy as "Always" for the init container will have the following effect:
     * this init container will be continually restarted on
     * exit until all regular containers have terminated. Once all regular
     * containers have completed, all init containers with restartPolicy "Always"
     * will be shut down. This lifecycle differs from normal init containers and
     * is often referred to as a "sidecar" container. Although this init
     * container still starts in the init container sequence, it does not wait
     * for the container to complete before proceeding to the next init
     * container. Instead, the next init container starts immediately after this
     * init container is started, or after any startupProbe has successfully
     * completed.
     * +featureGate=SidecarContainers
     * +optional
     * </pre>
     *
     * <code>optional string restart_policy = 24 [json_name = "restartPolicy"];</code>
     * @return Whether the restartPolicy field is set.
     */
    @java.lang.Override
    public boolean hasRestartPolicy() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * RestartPolicy defines the restart behavior of individual containers in a pod.
     * This field may only be set for init containers, and the only allowed value is "Always".
     * For non-init containers or when this field is not specified,
     * the restart behavior is defined by the Pod's restart policy and the container type.
     * Setting the RestartPolicy as "Always" for the init container will have the following effect:
     * this init container will be continually restarted on
     * exit until all regular containers have terminated. Once all regular
     * containers have completed, all init containers with restartPolicy "Always"
     * will be shut down. This lifecycle differs from normal init containers and
     * is often referred to as a "sidecar" container. Although this init
     * container still starts in the init container sequence, it does not wait
     * for the container to complete before proceeding to the next init
     * container. Instead, the next init container starts immediately after this
     * init container is started, or after any startupProbe has successfully
     * completed.
     * +featureGate=SidecarContainers
     * +optional
     * </pre>
     *
     * <code>optional string restart_policy = 24 [json_name = "restartPolicy"];</code>
     * @return The restartPolicy.
     */
    @java.lang.Override
    public java.lang.String getRestartPolicy() {
      java.lang.Object ref = restartPolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        restartPolicy_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * RestartPolicy defines the restart behavior of individual containers in a pod.
     * This field may only be set for init containers, and the only allowed value is "Always".
     * For non-init containers or when this field is not specified,
     * the restart behavior is defined by the Pod's restart policy and the container type.
     * Setting the RestartPolicy as "Always" for the init container will have the following effect:
     * this init container will be continually restarted on
     * exit until all regular containers have terminated. Once all regular
     * containers have completed, all init containers with restartPolicy "Always"
     * will be shut down. This lifecycle differs from normal init containers and
     * is often referred to as a "sidecar" container. Although this init
     * container still starts in the init container sequence, it does not wait
     * for the container to complete before proceeding to the next init
     * container. Instead, the next init container starts immediately after this
     * init container is started, or after any startupProbe has successfully
     * completed.
     * +featureGate=SidecarContainers
     * +optional
     * </pre>
     *
     * <code>optional string restart_policy = 24 [json_name = "restartPolicy"];</code>
     * @return The bytes for restartPolicy.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getRestartPolicyBytes() {
      java.lang.Object ref = restartPolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        restartPolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TERMINATION_MESSAGE_PATH_FIELD_NUMBER = 13;
    @SuppressWarnings("serial")
    private volatile java.lang.Object terminationMessagePath_ = "";
    /**
     * <pre>
     * Optional: Path at which the file to which the container's termination message
     * will be written is mounted into the container's filesystem.
     * Message written is intended to be brief final status, such as an assertion failure message.
     * Will be truncated by the node if greater than 4096 bytes. The total message length across
     * all containers will be limited to 12kb.
     * Defaults to /dev/termination-log.
     * Cannot be updated.
     * +optional
     * </pre>
     *
     * <code>optional string termination_message_path = 13 [json_name = "terminationMessagePath"];</code>
     * @return Whether the terminationMessagePath field is set.
     */
    @java.lang.Override
    public boolean hasTerminationMessagePath() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Optional: Path at which the file to which the container's termination message
     * will be written is mounted into the container's filesystem.
     * Message written is intended to be brief final status, such as an assertion failure message.
     * Will be truncated by the node if greater than 4096 bytes. The total message length across
     * all containers will be limited to 12kb.
     * Defaults to /dev/termination-log.
     * Cannot be updated.
     * +optional
     * </pre>
     *
     * <code>optional string termination_message_path = 13 [json_name = "terminationMessagePath"];</code>
     * @return The terminationMessagePath.
     */
    @java.lang.Override
    public java.lang.String getTerminationMessagePath() {
      java.lang.Object ref = terminationMessagePath_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        terminationMessagePath_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Optional: Path at which the file to which the container's termination message
     * will be written is mounted into the container's filesystem.
     * Message written is intended to be brief final status, such as an assertion failure message.
     * Will be truncated by the node if greater than 4096 bytes. The total message length across
     * all containers will be limited to 12kb.
     * Defaults to /dev/termination-log.
     * Cannot be updated.
     * +optional
     * </pre>
     *
     * <code>optional string termination_message_path = 13 [json_name = "terminationMessagePath"];</code>
     * @return The bytes for terminationMessagePath.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTerminationMessagePathBytes() {
      java.lang.Object ref = terminationMessagePath_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        terminationMessagePath_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TERMINATION_MESSAGE_POLICY_FIELD_NUMBER = 20;
    @SuppressWarnings("serial")
    private volatile java.lang.Object terminationMessagePolicy_ = "";
    /**
     * <pre>
     * Indicate how the termination message should be populated. File will use the contents of
     * terminationMessagePath to populate the container status message on both success and failure.
     * FallbackToLogsOnError will use the last chunk of container log output if the termination
     * message file is empty and the container exited with an error.
     * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
     * Defaults to File.
     * Cannot be updated.
     * +optional
     * </pre>
     *
     * <code>optional string termination_message_policy = 20 [json_name = "terminationMessagePolicy"];</code>
     * @return Whether the terminationMessagePolicy field is set.
     */
    @java.lang.Override
    public boolean hasTerminationMessagePolicy() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Indicate how the termination message should be populated. File will use the contents of
     * terminationMessagePath to populate the container status message on both success and failure.
     * FallbackToLogsOnError will use the last chunk of container log output if the termination
     * message file is empty and the container exited with an error.
     * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
     * Defaults to File.
     * Cannot be updated.
     * +optional
     * </pre>
     *
     * <code>optional string termination_message_policy = 20 [json_name = "terminationMessagePolicy"];</code>
     * @return The terminationMessagePolicy.
     */
    @java.lang.Override
    public java.lang.String getTerminationMessagePolicy() {
      java.lang.Object ref = terminationMessagePolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        terminationMessagePolicy_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Indicate how the termination message should be populated. File will use the contents of
     * terminationMessagePath to populate the container status message on both success and failure.
     * FallbackToLogsOnError will use the last chunk of container log output if the termination
     * message file is empty and the container exited with an error.
     * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
     * Defaults to File.
     * Cannot be updated.
     * +optional
     * </pre>
     *
     * <code>optional string termination_message_policy = 20 [json_name = "terminationMessagePolicy"];</code>
     * @return The bytes for terminationMessagePolicy.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTerminationMessagePolicyBytes() {
      java.lang.Object ref = terminationMessagePolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        terminationMessagePolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int IMAGE_PULL_POLICY_FIELD_NUMBER = 14;
    @SuppressWarnings("serial")
    private volatile java.lang.Object imagePullPolicy_ = "";
    /**
     * <pre>
     * Image pull policy.
     * One of Always, Never, IfNotPresent.
     * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
     * +optional
     * </pre>
     *
     * <code>optional string image_pull_policy = 14 [json_name = "imagePullPolicy"];</code>
     * @return Whether the imagePullPolicy field is set.
     */
    @java.lang.Override
    public boolean hasImagePullPolicy() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Image pull policy.
     * One of Always, Never, IfNotPresent.
     * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
     * +optional
     * </pre>
     *
     * <code>optional string image_pull_policy = 14 [json_name = "imagePullPolicy"];</code>
     * @return The imagePullPolicy.
     */
    @java.lang.Override
    public java.lang.String getImagePullPolicy() {
      java.lang.Object ref = imagePullPolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        imagePullPolicy_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Image pull policy.
     * One of Always, Never, IfNotPresent.
     * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
     * +optional
     * </pre>
     *
     * <code>optional string image_pull_policy = 14 [json_name = "imagePullPolicy"];</code>
     * @return The bytes for imagePullPolicy.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getImagePullPolicyBytes() {
      java.lang.Object ref = imagePullPolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        imagePullPolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STDIN_FIELD_NUMBER = 16;
    private boolean stdin_ = false;
    /**
     * <pre>
     * Whether this container should allocate a buffer for stdin in the container runtime. If this
     * is not set, reads from stdin in the container will always result in EOF.
     * </pre>
     *
     * <code>bool stdin = 16 [json_name = "stdin"];</code>
     * @return The stdin.
     */
    @java.lang.Override
    public boolean getStdin() {
      return stdin_;
    }

    public static final int STDIN_ONCE_FIELD_NUMBER = 17;
    private boolean stdinOnce_ = false;
    /**
     * <pre>
     * Whether the container runtime should close the stdin channel after it has been opened by
     * a single attach. When stdin is true the stdin stream will remain open across multiple attach
     * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
     * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
     * at which time stdin is closed and remains closed until the container is restarted. If this
     * flag is false, a container processes that reads from stdin will never receive an EOF.
     * </pre>
     *
     * <code>bool stdin_once = 17 [json_name = "stdinOnce"];</code>
     * @return The stdinOnce.
     */
    @java.lang.Override
    public boolean getStdinOnce() {
      return stdinOnce_;
    }

    public static final int TTY_FIELD_NUMBER = 18;
    private boolean tty_ = false;
    /**
     * <pre>
     * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
     * </pre>
     *
     * <code>bool tty = 18 [json_name = "tty"];</code>
     * @return The tty.
     */
    @java.lang.Override
    public boolean getTty() {
      return tty_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(name_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, image_);
      }
      for (int i = 0; i < command_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, command_.getRaw(i));
      }
      for (int i = 0; i < args_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, args_.getRaw(i));
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, workingDir_);
      }
      for (int i = 0; i < env_.size(); i++) {
        output.writeMessage(7, env_.get(i));
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(8, getResources());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 13, terminationMessagePath_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 14, imagePullPolicy_);
      }
      if (stdin_ != false) {
        output.writeBool(16, stdin_);
      }
      if (stdinOnce_ != false) {
        output.writeBool(17, stdinOnce_);
      }
      if (tty_ != false) {
        output.writeBool(18, tty_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 20, terminationMessagePolicy_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 24, restartPolicy_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(name_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, image_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < command_.size(); i++) {
          dataSize += computeStringSizeNoTag(command_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getCommandList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < args_.size(); i++) {
          dataSize += computeStringSizeNoTag(args_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getArgsList().size();
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, workingDir_);
      }
      for (int i = 0; i < env_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, env_.get(i));
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, getResources());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(13, terminationMessagePath_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(14, imagePullPolicy_);
      }
      if (stdin_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(16, stdin_);
      }
      if (stdinOnce_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(17, stdinOnce_);
      }
      if (tty_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(18, tty_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(20, terminationMessagePolicy_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(24, restartPolicy_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container)) {
        return super.equals(obj);
      }
      ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container other = (ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container) obj;

      if (!getName()
          .equals(other.getName())) return false;
      if (hasImage() != other.hasImage()) return false;
      if (hasImage()) {
        if (!getImage()
            .equals(other.getImage())) return false;
      }
      if (!getCommandList()
          .equals(other.getCommandList())) return false;
      if (!getArgsList()
          .equals(other.getArgsList())) return false;
      if (hasWorkingDir() != other.hasWorkingDir()) return false;
      if (hasWorkingDir()) {
        if (!getWorkingDir()
            .equals(other.getWorkingDir())) return false;
      }
      if (!getEnvList()
          .equals(other.getEnvList())) return false;
      if (hasResources() != other.hasResources()) return false;
      if (hasResources()) {
        if (!getResources()
            .equals(other.getResources())) return false;
      }
      if (hasRestartPolicy() != other.hasRestartPolicy()) return false;
      if (hasRestartPolicy()) {
        if (!getRestartPolicy()
            .equals(other.getRestartPolicy())) return false;
      }
      if (hasTerminationMessagePath() != other.hasTerminationMessagePath()) return false;
      if (hasTerminationMessagePath()) {
        if (!getTerminationMessagePath()
            .equals(other.getTerminationMessagePath())) return false;
      }
      if (hasTerminationMessagePolicy() != other.hasTerminationMessagePolicy()) return false;
      if (hasTerminationMessagePolicy()) {
        if (!getTerminationMessagePolicy()
            .equals(other.getTerminationMessagePolicy())) return false;
      }
      if (hasImagePullPolicy() != other.hasImagePullPolicy()) return false;
      if (hasImagePullPolicy()) {
        if (!getImagePullPolicy()
            .equals(other.getImagePullPolicy())) return false;
      }
      if (getStdin()
          != other.getStdin()) return false;
      if (getStdinOnce()
          != other.getStdinOnce()) return false;
      if (getTty()
          != other.getTty()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      if (hasImage()) {
        hash = (37 * hash) + IMAGE_FIELD_NUMBER;
        hash = (53 * hash) + getImage().hashCode();
      }
      if (getCommandCount() > 0) {
        hash = (37 * hash) + COMMAND_FIELD_NUMBER;
        hash = (53 * hash) + getCommandList().hashCode();
      }
      if (getArgsCount() > 0) {
        hash = (37 * hash) + ARGS_FIELD_NUMBER;
        hash = (53 * hash) + getArgsList().hashCode();
      }
      if (hasWorkingDir()) {
        hash = (37 * hash) + WORKING_DIR_FIELD_NUMBER;
        hash = (53 * hash) + getWorkingDir().hashCode();
      }
      if (getEnvCount() > 0) {
        hash = (37 * hash) + ENV_FIELD_NUMBER;
        hash = (53 * hash) + getEnvList().hashCode();
      }
      if (hasResources()) {
        hash = (37 * hash) + RESOURCES_FIELD_NUMBER;
        hash = (53 * hash) + getResources().hashCode();
      }
      if (hasRestartPolicy()) {
        hash = (37 * hash) + RESTART_POLICY_FIELD_NUMBER;
        hash = (53 * hash) + getRestartPolicy().hashCode();
      }
      if (hasTerminationMessagePath()) {
        hash = (37 * hash) + TERMINATION_MESSAGE_PATH_FIELD_NUMBER;
        hash = (53 * hash) + getTerminationMessagePath().hashCode();
      }
      if (hasTerminationMessagePolicy()) {
        hash = (37 * hash) + TERMINATION_MESSAGE_POLICY_FIELD_NUMBER;
        hash = (53 * hash) + getTerminationMessagePolicy().hashCode();
      }
      if (hasImagePullPolicy()) {
        hash = (37 * hash) + IMAGE_PULL_POLICY_FIELD_NUMBER;
        hash = (53 * hash) + getImagePullPolicy().hashCode();
      }
      hash = (37 * hash) + STDIN_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getStdin());
      hash = (37 * hash) + STDIN_ONCE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getStdinOnce());
      hash = (37 * hash) + TTY_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getTty());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * A single application container that you want to run within a pod.
     * </pre>
     *
     * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.Container}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chalk.pubsub.v1.PodStatusPubSub.Container)
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_Container_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_Container_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.Builder.class);
      }

      // Construct using ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getEnvFieldBuilder();
          getResourcesFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        name_ = "";
        image_ = "";
        command_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        args_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        workingDir_ = "";
        if (envBuilder_ == null) {
          env_ = java.util.Collections.emptyList();
        } else {
          env_ = null;
          envBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        resources_ = null;
        if (resourcesBuilder_ != null) {
          resourcesBuilder_.dispose();
          resourcesBuilder_ = null;
        }
        restartPolicy_ = "";
        terminationMessagePath_ = "";
        terminationMessagePolicy_ = "";
        imagePullPolicy_ = "";
        stdin_ = false;
        stdinOnce_ = false;
        tty_ = false;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_Container_descriptor;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container getDefaultInstanceForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.getDefaultInstance();
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container build() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container buildPartial() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container result = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container result) {
        if (envBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0)) {
            env_ = java.util.Collections.unmodifiableList(env_);
            bitField0_ = (bitField0_ & ~0x00000020);
          }
          result.env_ = env_;
        } else {
          result.env_ = envBuilder_.build();
        }
      }

      private void buildPartial0(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.name_ = name_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.image_ = image_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          command_.makeImmutable();
          result.command_ = command_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          args_.makeImmutable();
          result.args_ = args_;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.workingDir_ = workingDir_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.resources_ = resourcesBuilder_ == null
              ? resources_
              : resourcesBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.restartPolicy_ = restartPolicy_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.terminationMessagePath_ = terminationMessagePath_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.terminationMessagePolicy_ = terminationMessagePolicy_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.imagePullPolicy_ = imagePullPolicy_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.stdin_ = stdin_;
        }
        if (((from_bitField0_ & 0x00001000) != 0)) {
          result.stdinOnce_ = stdinOnce_;
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          result.tty_ = tty_;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container) {
          return mergeFrom((ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container other) {
        if (other == ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container.getDefaultInstance()) return this;
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasImage()) {
          image_ = other.image_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (!other.command_.isEmpty()) {
          if (command_.isEmpty()) {
            command_ = other.command_;
            bitField0_ |= 0x00000004;
          } else {
            ensureCommandIsMutable();
            command_.addAll(other.command_);
          }
          onChanged();
        }
        if (!other.args_.isEmpty()) {
          if (args_.isEmpty()) {
            args_ = other.args_;
            bitField0_ |= 0x00000008;
          } else {
            ensureArgsIsMutable();
            args_.addAll(other.args_);
          }
          onChanged();
        }
        if (other.hasWorkingDir()) {
          workingDir_ = other.workingDir_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        if (envBuilder_ == null) {
          if (!other.env_.isEmpty()) {
            if (env_.isEmpty()) {
              env_ = other.env_;
              bitField0_ = (bitField0_ & ~0x00000020);
            } else {
              ensureEnvIsMutable();
              env_.addAll(other.env_);
            }
            onChanged();
          }
        } else {
          if (!other.env_.isEmpty()) {
            if (envBuilder_.isEmpty()) {
              envBuilder_.dispose();
              envBuilder_ = null;
              env_ = other.env_;
              bitField0_ = (bitField0_ & ~0x00000020);
              envBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getEnvFieldBuilder() : null;
            } else {
              envBuilder_.addAllMessages(other.env_);
            }
          }
        }
        if (other.hasResources()) {
          mergeResources(other.getResources());
        }
        if (other.hasRestartPolicy()) {
          restartPolicy_ = other.restartPolicy_;
          bitField0_ |= 0x00000080;
          onChanged();
        }
        if (other.hasTerminationMessagePath()) {
          terminationMessagePath_ = other.terminationMessagePath_;
          bitField0_ |= 0x00000100;
          onChanged();
        }
        if (other.hasTerminationMessagePolicy()) {
          terminationMessagePolicy_ = other.terminationMessagePolicy_;
          bitField0_ |= 0x00000200;
          onChanged();
        }
        if (other.hasImagePullPolicy()) {
          imagePullPolicy_ = other.imagePullPolicy_;
          bitField0_ |= 0x00000400;
          onChanged();
        }
        if (other.getStdin() != false) {
          setStdin(other.getStdin());
        }
        if (other.getStdinOnce() != false) {
          setStdinOnce(other.getStdinOnce());
        }
        if (other.getTty() != false) {
          setTty(other.getTty());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                name_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                image_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                java.lang.String s = input.readStringRequireUtf8();
                ensureCommandIsMutable();
                command_.add(s);
                break;
              } // case 26
              case 34: {
                java.lang.String s = input.readStringRequireUtf8();
                ensureArgsIsMutable();
                args_.add(s);
                break;
              } // case 34
              case 42: {
                workingDir_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000010;
                break;
              } // case 42
              case 58: {
                ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar m =
                    input.readMessage(
                        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar.parser(),
                        extensionRegistry);
                if (envBuilder_ == null) {
                  ensureEnvIsMutable();
                  env_.add(m);
                } else {
                  envBuilder_.addMessage(m);
                }
                break;
              } // case 58
              case 66: {
                input.readMessage(
                    getResourcesFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000040;
                break;
              } // case 66
              case 106: {
                terminationMessagePath_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000100;
                break;
              } // case 106
              case 114: {
                imagePullPolicy_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000400;
                break;
              } // case 114
              case 128: {
                stdin_ = input.readBool();
                bitField0_ |= 0x00000800;
                break;
              } // case 128
              case 136: {
                stdinOnce_ = input.readBool();
                bitField0_ |= 0x00001000;
                break;
              } // case 136
              case 144: {
                tty_ = input.readBool();
                bitField0_ |= 0x00002000;
                break;
              } // case 144
              case 162: {
                terminationMessagePolicy_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000200;
                break;
              } // case 162
              case 194: {
                restartPolicy_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000080;
                break;
              } // case 194
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * Name of the container specified as a DNS_LABEL.
       * Each container in a pod must have a unique name (DNS_LABEL).
       * Cannot be updated.
       * </pre>
       *
       * <code>string name = 1 [json_name = "name"];</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Name of the container specified as a DNS_LABEL.
       * Each container in a pod must have a unique name (DNS_LABEL).
       * Cannot be updated.
       * </pre>
       *
       * <code>string name = 1 [json_name = "name"];</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Name of the container specified as a DNS_LABEL.
       * Each container in a pod must have a unique name (DNS_LABEL).
       * Cannot be updated.
       * </pre>
       *
       * <code>string name = 1 [json_name = "name"];</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name of the container specified as a DNS_LABEL.
       * Each container in a pod must have a unique name (DNS_LABEL).
       * Cannot be updated.
       * </pre>
       *
       * <code>string name = 1 [json_name = "name"];</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name of the container specified as a DNS_LABEL.
       * Each container in a pod must have a unique name (DNS_LABEL).
       * Cannot be updated.
       * </pre>
       *
       * <code>string name = 1 [json_name = "name"];</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object image_ = "";
      /**
       * <pre>
       * Container image name.
       * More info: https://kubernetes.io/docs/concepts/containers/images
       * This field is optional to allow higher level config management to default or override
       * container images in workload controllers like Deployments and StatefulSets.
       * +optional
       * </pre>
       *
       * <code>optional string image = 2 [json_name = "image"];</code>
       * @return Whether the image field is set.
       */
      public boolean hasImage() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Container image name.
       * More info: https://kubernetes.io/docs/concepts/containers/images
       * This field is optional to allow higher level config management to default or override
       * container images in workload controllers like Deployments and StatefulSets.
       * +optional
       * </pre>
       *
       * <code>optional string image = 2 [json_name = "image"];</code>
       * @return The image.
       */
      public java.lang.String getImage() {
        java.lang.Object ref = image_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          image_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Container image name.
       * More info: https://kubernetes.io/docs/concepts/containers/images
       * This field is optional to allow higher level config management to default or override
       * container images in workload controllers like Deployments and StatefulSets.
       * +optional
       * </pre>
       *
       * <code>optional string image = 2 [json_name = "image"];</code>
       * @return The bytes for image.
       */
      public com.google.protobuf.ByteString
          getImageBytes() {
        java.lang.Object ref = image_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          image_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Container image name.
       * More info: https://kubernetes.io/docs/concepts/containers/images
       * This field is optional to allow higher level config management to default or override
       * container images in workload controllers like Deployments and StatefulSets.
       * +optional
       * </pre>
       *
       * <code>optional string image = 2 [json_name = "image"];</code>
       * @param value The image to set.
       * @return This builder for chaining.
       */
      public Builder setImage(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        image_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Container image name.
       * More info: https://kubernetes.io/docs/concepts/containers/images
       * This field is optional to allow higher level config management to default or override
       * container images in workload controllers like Deployments and StatefulSets.
       * +optional
       * </pre>
       *
       * <code>optional string image = 2 [json_name = "image"];</code>
       * @return This builder for chaining.
       */
      public Builder clearImage() {
        image_ = getDefaultInstance().getImage();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Container image name.
       * More info: https://kubernetes.io/docs/concepts/containers/images
       * This field is optional to allow higher level config management to default or override
       * container images in workload controllers like Deployments and StatefulSets.
       * +optional
       * </pre>
       *
       * <code>optional string image = 2 [json_name = "image"];</code>
       * @param value The bytes for image to set.
       * @return This builder for chaining.
       */
      public Builder setImageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        image_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringArrayList command_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureCommandIsMutable() {
        if (!command_.isModifiable()) {
          command_ = new com.google.protobuf.LazyStringArrayList(command_);
        }
        bitField0_ |= 0x00000004;
      }
      /**
       * <pre>
       * Entrypoint array. Not executed within a shell.
       * The container image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string command = 3 [json_name = "command"];</code>
       * @return A list containing the command.
       */
      public com.google.protobuf.ProtocolStringList
          getCommandList() {
        command_.makeImmutable();
        return command_;
      }
      /**
       * <pre>
       * Entrypoint array. Not executed within a shell.
       * The container image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string command = 3 [json_name = "command"];</code>
       * @return The count of command.
       */
      public int getCommandCount() {
        return command_.size();
      }
      /**
       * <pre>
       * Entrypoint array. Not executed within a shell.
       * The container image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string command = 3 [json_name = "command"];</code>
       * @param index The index of the element to return.
       * @return The command at the given index.
       */
      public java.lang.String getCommand(int index) {
        return command_.get(index);
      }
      /**
       * <pre>
       * Entrypoint array. Not executed within a shell.
       * The container image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string command = 3 [json_name = "command"];</code>
       * @param index The index of the value to return.
       * @return The bytes of the command at the given index.
       */
      public com.google.protobuf.ByteString
          getCommandBytes(int index) {
        return command_.getByteString(index);
      }
      /**
       * <pre>
       * Entrypoint array. Not executed within a shell.
       * The container image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string command = 3 [json_name = "command"];</code>
       * @param index The index to set the value at.
       * @param value The command to set.
       * @return This builder for chaining.
       */
      public Builder setCommand(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureCommandIsMutable();
        command_.set(index, value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Entrypoint array. Not executed within a shell.
       * The container image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string command = 3 [json_name = "command"];</code>
       * @param value The command to add.
       * @return This builder for chaining.
       */
      public Builder addCommand(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureCommandIsMutable();
        command_.add(value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Entrypoint array. Not executed within a shell.
       * The container image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string command = 3 [json_name = "command"];</code>
       * @param values The command to add.
       * @return This builder for chaining.
       */
      public Builder addAllCommand(
          java.lang.Iterable<java.lang.String> values) {
        ensureCommandIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, command_);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Entrypoint array. Not executed within a shell.
       * The container image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string command = 3 [json_name = "command"];</code>
       * @return This builder for chaining.
       */
      public Builder clearCommand() {
        command_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000004);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Entrypoint array. Not executed within a shell.
       * The container image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string command = 3 [json_name = "command"];</code>
       * @param value The bytes of the command to add.
       * @return This builder for chaining.
       */
      public Builder addCommandBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        ensureCommandIsMutable();
        command_.add(value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringArrayList args_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureArgsIsMutable() {
        if (!args_.isModifiable()) {
          args_ = new com.google.protobuf.LazyStringArrayList(args_);
        }
        bitField0_ |= 0x00000008;
      }
      /**
       * <pre>
       * Arguments to the entrypoint.
       * The container image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string args = 4 [json_name = "args"];</code>
       * @return A list containing the args.
       */
      public com.google.protobuf.ProtocolStringList
          getArgsList() {
        args_.makeImmutable();
        return args_;
      }
      /**
       * <pre>
       * Arguments to the entrypoint.
       * The container image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string args = 4 [json_name = "args"];</code>
       * @return The count of args.
       */
      public int getArgsCount() {
        return args_.size();
      }
      /**
       * <pre>
       * Arguments to the entrypoint.
       * The container image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string args = 4 [json_name = "args"];</code>
       * @param index The index of the element to return.
       * @return The args at the given index.
       */
      public java.lang.String getArgs(int index) {
        return args_.get(index);
      }
      /**
       * <pre>
       * Arguments to the entrypoint.
       * The container image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string args = 4 [json_name = "args"];</code>
       * @param index The index of the value to return.
       * @return The bytes of the args at the given index.
       */
      public com.google.protobuf.ByteString
          getArgsBytes(int index) {
        return args_.getByteString(index);
      }
      /**
       * <pre>
       * Arguments to the entrypoint.
       * The container image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string args = 4 [json_name = "args"];</code>
       * @param index The index to set the value at.
       * @param value The args to set.
       * @return This builder for chaining.
       */
      public Builder setArgs(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureArgsIsMutable();
        args_.set(index, value);
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Arguments to the entrypoint.
       * The container image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string args = 4 [json_name = "args"];</code>
       * @param value The args to add.
       * @return This builder for chaining.
       */
      public Builder addArgs(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureArgsIsMutable();
        args_.add(value);
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Arguments to the entrypoint.
       * The container image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string args = 4 [json_name = "args"];</code>
       * @param values The args to add.
       * @return This builder for chaining.
       */
      public Builder addAllArgs(
          java.lang.Iterable<java.lang.String> values) {
        ensureArgsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, args_);
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Arguments to the entrypoint.
       * The container image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string args = 4 [json_name = "args"];</code>
       * @return This builder for chaining.
       */
      public Builder clearArgs() {
        args_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000008);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Arguments to the entrypoint.
       * The container image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string args = 4 [json_name = "args"];</code>
       * @param value The bytes of the args to add.
       * @return This builder for chaining.
       */
      public Builder addArgsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        ensureArgsIsMutable();
        args_.add(value);
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private java.lang.Object workingDir_ = "";
      /**
       * <pre>
       * Container's working directory.
       * If not specified, the container runtime's default will be used, which
       * might be configured in the container image.
       * Cannot be updated.
       * +optional
       * </pre>
       *
       * <code>optional string working_dir = 5 [json_name = "workingDir"];</code>
       * @return Whether the workingDir field is set.
       */
      public boolean hasWorkingDir() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Container's working directory.
       * If not specified, the container runtime's default will be used, which
       * might be configured in the container image.
       * Cannot be updated.
       * +optional
       * </pre>
       *
       * <code>optional string working_dir = 5 [json_name = "workingDir"];</code>
       * @return The workingDir.
       */
      public java.lang.String getWorkingDir() {
        java.lang.Object ref = workingDir_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          workingDir_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Container's working directory.
       * If not specified, the container runtime's default will be used, which
       * might be configured in the container image.
       * Cannot be updated.
       * +optional
       * </pre>
       *
       * <code>optional string working_dir = 5 [json_name = "workingDir"];</code>
       * @return The bytes for workingDir.
       */
      public com.google.protobuf.ByteString
          getWorkingDirBytes() {
        java.lang.Object ref = workingDir_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          workingDir_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Container's working directory.
       * If not specified, the container runtime's default will be used, which
       * might be configured in the container image.
       * Cannot be updated.
       * +optional
       * </pre>
       *
       * <code>optional string working_dir = 5 [json_name = "workingDir"];</code>
       * @param value The workingDir to set.
       * @return This builder for chaining.
       */
      public Builder setWorkingDir(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        workingDir_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Container's working directory.
       * If not specified, the container runtime's default will be used, which
       * might be configured in the container image.
       * Cannot be updated.
       * +optional
       * </pre>
       *
       * <code>optional string working_dir = 5 [json_name = "workingDir"];</code>
       * @return This builder for chaining.
       */
      public Builder clearWorkingDir() {
        workingDir_ = getDefaultInstance().getWorkingDir();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Container's working directory.
       * If not specified, the container runtime's default will be used, which
       * might be configured in the container image.
       * Cannot be updated.
       * +optional
       * </pre>
       *
       * <code>optional string working_dir = 5 [json_name = "workingDir"];</code>
       * @param value The bytes for workingDir to set.
       * @return This builder for chaining.
       */
      public Builder setWorkingDirBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        workingDir_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      private java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar> env_ =
        java.util.Collections.emptyList();
      private void ensureEnvIsMutable() {
        if (!((bitField0_ & 0x00000020) != 0)) {
          env_ = new java.util.ArrayList<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar>(env_);
          bitField0_ |= 0x00000020;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVarOrBuilder> envBuilder_;

      /**
       * <pre>
       * List of environment variables to set in the container.
       * Cannot be updated.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
       */
      public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar> getEnvList() {
        if (envBuilder_ == null) {
          return java.util.Collections.unmodifiableList(env_);
        } else {
          return envBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * List of environment variables to set in the container.
       * Cannot be updated.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
       */
      public int getEnvCount() {
        if (envBuilder_ == null) {
          return env_.size();
        } else {
          return envBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * List of environment variables to set in the container.
       * Cannot be updated.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar getEnv(int index) {
        if (envBuilder_ == null) {
          return env_.get(index);
        } else {
          return envBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * List of environment variables to set in the container.
       * Cannot be updated.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
       */
      public Builder setEnv(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar value) {
        if (envBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEnvIsMutable();
          env_.set(index, value);
          onChanged();
        } else {
          envBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of environment variables to set in the container.
       * Cannot be updated.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
       */
      public Builder setEnv(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar.Builder builderForValue) {
        if (envBuilder_ == null) {
          ensureEnvIsMutable();
          env_.set(index, builderForValue.build());
          onChanged();
        } else {
          envBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of environment variables to set in the container.
       * Cannot be updated.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
       */
      public Builder addEnv(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar value) {
        if (envBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEnvIsMutable();
          env_.add(value);
          onChanged();
        } else {
          envBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * List of environment variables to set in the container.
       * Cannot be updated.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
       */
      public Builder addEnv(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar value) {
        if (envBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEnvIsMutable();
          env_.add(index, value);
          onChanged();
        } else {
          envBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of environment variables to set in the container.
       * Cannot be updated.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
       */
      public Builder addEnv(
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar.Builder builderForValue) {
        if (envBuilder_ == null) {
          ensureEnvIsMutable();
          env_.add(builderForValue.build());
          onChanged();
        } else {
          envBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of environment variables to set in the container.
       * Cannot be updated.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
       */
      public Builder addEnv(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar.Builder builderForValue) {
        if (envBuilder_ == null) {
          ensureEnvIsMutable();
          env_.add(index, builderForValue.build());
          onChanged();
        } else {
          envBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of environment variables to set in the container.
       * Cannot be updated.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
       */
      public Builder addAllEnv(
          java.lang.Iterable<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar> values) {
        if (envBuilder_ == null) {
          ensureEnvIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, env_);
          onChanged();
        } else {
          envBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * List of environment variables to set in the container.
       * Cannot be updated.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
       */
      public Builder clearEnv() {
        if (envBuilder_ == null) {
          env_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
          onChanged();
        } else {
          envBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * List of environment variables to set in the container.
       * Cannot be updated.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
       */
      public Builder removeEnv(int index) {
        if (envBuilder_ == null) {
          ensureEnvIsMutable();
          env_.remove(index);
          onChanged();
        } else {
          envBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * List of environment variables to set in the container.
       * Cannot be updated.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar.Builder getEnvBuilder(
          int index) {
        return getEnvFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * List of environment variables to set in the container.
       * Cannot be updated.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVarOrBuilder getEnvOrBuilder(
          int index) {
        if (envBuilder_ == null) {
          return env_.get(index);  } else {
          return envBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * List of environment variables to set in the container.
       * Cannot be updated.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
       */
      public java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVarOrBuilder> 
           getEnvOrBuilderList() {
        if (envBuilder_ != null) {
          return envBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(env_);
        }
      }
      /**
       * <pre>
       * List of environment variables to set in the container.
       * Cannot be updated.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar.Builder addEnvBuilder() {
        return getEnvFieldBuilder().addBuilder(
            ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar.getDefaultInstance());
      }
      /**
       * <pre>
       * List of environment variables to set in the container.
       * Cannot be updated.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar.Builder addEnvBuilder(
          int index) {
        return getEnvFieldBuilder().addBuilder(
            index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar.getDefaultInstance());
      }
      /**
       * <pre>
       * List of environment variables to set in the container.
       * Cannot be updated.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.EnvVar env = 7 [json_name = "env"];</code>
       */
      public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar.Builder> 
           getEnvBuilderList() {
        return getEnvFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVarOrBuilder> 
          getEnvFieldBuilder() {
        if (envBuilder_ == null) {
          envBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVar.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.EnvVarOrBuilder>(
                  env_,
                  ((bitField0_ & 0x00000020) != 0),
                  getParentForChildren(),
                  isClean());
          env_ = null;
        }
        return envBuilder_;
      }

      private ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements resources_;
      private com.google.protobuf.SingleFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirementsOrBuilder> resourcesBuilder_;
      /**
       * <pre>
       * Compute Resources required by this container.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements resources = 8 [json_name = "resources"];</code>
       * @return Whether the resources field is set.
       */
      public boolean hasResources() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Compute Resources required by this container.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements resources = 8 [json_name = "resources"];</code>
       * @return The resources.
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements getResources() {
        if (resourcesBuilder_ == null) {
          return resources_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements.getDefaultInstance() : resources_;
        } else {
          return resourcesBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Compute Resources required by this container.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements resources = 8 [json_name = "resources"];</code>
       */
      public Builder setResources(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements value) {
        if (resourcesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          resources_ = value;
        } else {
          resourcesBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Compute Resources required by this container.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements resources = 8 [json_name = "resources"];</code>
       */
      public Builder setResources(
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements.Builder builderForValue) {
        if (resourcesBuilder_ == null) {
          resources_ = builderForValue.build();
        } else {
          resourcesBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Compute Resources required by this container.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements resources = 8 [json_name = "resources"];</code>
       */
      public Builder mergeResources(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements value) {
        if (resourcesBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0) &&
            resources_ != null &&
            resources_ != ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements.getDefaultInstance()) {
            getResourcesBuilder().mergeFrom(value);
          } else {
            resources_ = value;
          }
        } else {
          resourcesBuilder_.mergeFrom(value);
        }
        if (resources_ != null) {
          bitField0_ |= 0x00000040;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Compute Resources required by this container.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements resources = 8 [json_name = "resources"];</code>
       */
      public Builder clearResources() {
        bitField0_ = (bitField0_ & ~0x00000040);
        resources_ = null;
        if (resourcesBuilder_ != null) {
          resourcesBuilder_.dispose();
          resourcesBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Compute Resources required by this container.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements resources = 8 [json_name = "resources"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements.Builder getResourcesBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getResourcesFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Compute Resources required by this container.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements resources = 8 [json_name = "resources"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirementsOrBuilder getResourcesOrBuilder() {
        if (resourcesBuilder_ != null) {
          return resourcesBuilder_.getMessageOrBuilder();
        } else {
          return resources_ == null ?
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements.getDefaultInstance() : resources_;
        }
      }
      /**
       * <pre>
       * Compute Resources required by this container.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements resources = 8 [json_name = "resources"];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirementsOrBuilder> 
          getResourcesFieldBuilder() {
        if (resourcesBuilder_ == null) {
          resourcesBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirementsOrBuilder>(
                  getResources(),
                  getParentForChildren(),
                  isClean());
          resources_ = null;
        }
        return resourcesBuilder_;
      }

      private java.lang.Object restartPolicy_ = "";
      /**
       * <pre>
       * RestartPolicy defines the restart behavior of individual containers in a pod.
       * This field may only be set for init containers, and the only allowed value is "Always".
       * For non-init containers or when this field is not specified,
       * the restart behavior is defined by the Pod's restart policy and the container type.
       * Setting the RestartPolicy as "Always" for the init container will have the following effect:
       * this init container will be continually restarted on
       * exit until all regular containers have terminated. Once all regular
       * containers have completed, all init containers with restartPolicy "Always"
       * will be shut down. This lifecycle differs from normal init containers and
       * is often referred to as a "sidecar" container. Although this init
       * container still starts in the init container sequence, it does not wait
       * for the container to complete before proceeding to the next init
       * container. Instead, the next init container starts immediately after this
       * init container is started, or after any startupProbe has successfully
       * completed.
       * +featureGate=SidecarContainers
       * +optional
       * </pre>
       *
       * <code>optional string restart_policy = 24 [json_name = "restartPolicy"];</code>
       * @return Whether the restartPolicy field is set.
       */
      public boolean hasRestartPolicy() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * RestartPolicy defines the restart behavior of individual containers in a pod.
       * This field may only be set for init containers, and the only allowed value is "Always".
       * For non-init containers or when this field is not specified,
       * the restart behavior is defined by the Pod's restart policy and the container type.
       * Setting the RestartPolicy as "Always" for the init container will have the following effect:
       * this init container will be continually restarted on
       * exit until all regular containers have terminated. Once all regular
       * containers have completed, all init containers with restartPolicy "Always"
       * will be shut down. This lifecycle differs from normal init containers and
       * is often referred to as a "sidecar" container. Although this init
       * container still starts in the init container sequence, it does not wait
       * for the container to complete before proceeding to the next init
       * container. Instead, the next init container starts immediately after this
       * init container is started, or after any startupProbe has successfully
       * completed.
       * +featureGate=SidecarContainers
       * +optional
       * </pre>
       *
       * <code>optional string restart_policy = 24 [json_name = "restartPolicy"];</code>
       * @return The restartPolicy.
       */
      public java.lang.String getRestartPolicy() {
        java.lang.Object ref = restartPolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          restartPolicy_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * RestartPolicy defines the restart behavior of individual containers in a pod.
       * This field may only be set for init containers, and the only allowed value is "Always".
       * For non-init containers or when this field is not specified,
       * the restart behavior is defined by the Pod's restart policy and the container type.
       * Setting the RestartPolicy as "Always" for the init container will have the following effect:
       * this init container will be continually restarted on
       * exit until all regular containers have terminated. Once all regular
       * containers have completed, all init containers with restartPolicy "Always"
       * will be shut down. This lifecycle differs from normal init containers and
       * is often referred to as a "sidecar" container. Although this init
       * container still starts in the init container sequence, it does not wait
       * for the container to complete before proceeding to the next init
       * container. Instead, the next init container starts immediately after this
       * init container is started, or after any startupProbe has successfully
       * completed.
       * +featureGate=SidecarContainers
       * +optional
       * </pre>
       *
       * <code>optional string restart_policy = 24 [json_name = "restartPolicy"];</code>
       * @return The bytes for restartPolicy.
       */
      public com.google.protobuf.ByteString
          getRestartPolicyBytes() {
        java.lang.Object ref = restartPolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          restartPolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * RestartPolicy defines the restart behavior of individual containers in a pod.
       * This field may only be set for init containers, and the only allowed value is "Always".
       * For non-init containers or when this field is not specified,
       * the restart behavior is defined by the Pod's restart policy and the container type.
       * Setting the RestartPolicy as "Always" for the init container will have the following effect:
       * this init container will be continually restarted on
       * exit until all regular containers have terminated. Once all regular
       * containers have completed, all init containers with restartPolicy "Always"
       * will be shut down. This lifecycle differs from normal init containers and
       * is often referred to as a "sidecar" container. Although this init
       * container still starts in the init container sequence, it does not wait
       * for the container to complete before proceeding to the next init
       * container. Instead, the next init container starts immediately after this
       * init container is started, or after any startupProbe has successfully
       * completed.
       * +featureGate=SidecarContainers
       * +optional
       * </pre>
       *
       * <code>optional string restart_policy = 24 [json_name = "restartPolicy"];</code>
       * @param value The restartPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setRestartPolicy(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        restartPolicy_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * RestartPolicy defines the restart behavior of individual containers in a pod.
       * This field may only be set for init containers, and the only allowed value is "Always".
       * For non-init containers or when this field is not specified,
       * the restart behavior is defined by the Pod's restart policy and the container type.
       * Setting the RestartPolicy as "Always" for the init container will have the following effect:
       * this init container will be continually restarted on
       * exit until all regular containers have terminated. Once all regular
       * containers have completed, all init containers with restartPolicy "Always"
       * will be shut down. This lifecycle differs from normal init containers and
       * is often referred to as a "sidecar" container. Although this init
       * container still starts in the init container sequence, it does not wait
       * for the container to complete before proceeding to the next init
       * container. Instead, the next init container starts immediately after this
       * init container is started, or after any startupProbe has successfully
       * completed.
       * +featureGate=SidecarContainers
       * +optional
       * </pre>
       *
       * <code>optional string restart_policy = 24 [json_name = "restartPolicy"];</code>
       * @return This builder for chaining.
       */
      public Builder clearRestartPolicy() {
        restartPolicy_ = getDefaultInstance().getRestartPolicy();
        bitField0_ = (bitField0_ & ~0x00000080);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * RestartPolicy defines the restart behavior of individual containers in a pod.
       * This field may only be set for init containers, and the only allowed value is "Always".
       * For non-init containers or when this field is not specified,
       * the restart behavior is defined by the Pod's restart policy and the container type.
       * Setting the RestartPolicy as "Always" for the init container will have the following effect:
       * this init container will be continually restarted on
       * exit until all regular containers have terminated. Once all regular
       * containers have completed, all init containers with restartPolicy "Always"
       * will be shut down. This lifecycle differs from normal init containers and
       * is often referred to as a "sidecar" container. Although this init
       * container still starts in the init container sequence, it does not wait
       * for the container to complete before proceeding to the next init
       * container. Instead, the next init container starts immediately after this
       * init container is started, or after any startupProbe has successfully
       * completed.
       * +featureGate=SidecarContainers
       * +optional
       * </pre>
       *
       * <code>optional string restart_policy = 24 [json_name = "restartPolicy"];</code>
       * @param value The bytes for restartPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setRestartPolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        restartPolicy_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }

      private java.lang.Object terminationMessagePath_ = "";
      /**
       * <pre>
       * Optional: Path at which the file to which the container's termination message
       * will be written is mounted into the container's filesystem.
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes. The total message length across
       * all containers will be limited to 12kb.
       * Defaults to /dev/termination-log.
       * Cannot be updated.
       * +optional
       * </pre>
       *
       * <code>optional string termination_message_path = 13 [json_name = "terminationMessagePath"];</code>
       * @return Whether the terminationMessagePath field is set.
       */
      public boolean hasTerminationMessagePath() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * Optional: Path at which the file to which the container's termination message
       * will be written is mounted into the container's filesystem.
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes. The total message length across
       * all containers will be limited to 12kb.
       * Defaults to /dev/termination-log.
       * Cannot be updated.
       * +optional
       * </pre>
       *
       * <code>optional string termination_message_path = 13 [json_name = "terminationMessagePath"];</code>
       * @return The terminationMessagePath.
       */
      public java.lang.String getTerminationMessagePath() {
        java.lang.Object ref = terminationMessagePath_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          terminationMessagePath_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Optional: Path at which the file to which the container's termination message
       * will be written is mounted into the container's filesystem.
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes. The total message length across
       * all containers will be limited to 12kb.
       * Defaults to /dev/termination-log.
       * Cannot be updated.
       * +optional
       * </pre>
       *
       * <code>optional string termination_message_path = 13 [json_name = "terminationMessagePath"];</code>
       * @return The bytes for terminationMessagePath.
       */
      public com.google.protobuf.ByteString
          getTerminationMessagePathBytes() {
        java.lang.Object ref = terminationMessagePath_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          terminationMessagePath_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Optional: Path at which the file to which the container's termination message
       * will be written is mounted into the container's filesystem.
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes. The total message length across
       * all containers will be limited to 12kb.
       * Defaults to /dev/termination-log.
       * Cannot be updated.
       * +optional
       * </pre>
       *
       * <code>optional string termination_message_path = 13 [json_name = "terminationMessagePath"];</code>
       * @param value The terminationMessagePath to set.
       * @return This builder for chaining.
       */
      public Builder setTerminationMessagePath(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        terminationMessagePath_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optional: Path at which the file to which the container's termination message
       * will be written is mounted into the container's filesystem.
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes. The total message length across
       * all containers will be limited to 12kb.
       * Defaults to /dev/termination-log.
       * Cannot be updated.
       * +optional
       * </pre>
       *
       * <code>optional string termination_message_path = 13 [json_name = "terminationMessagePath"];</code>
       * @return This builder for chaining.
       */
      public Builder clearTerminationMessagePath() {
        terminationMessagePath_ = getDefaultInstance().getTerminationMessagePath();
        bitField0_ = (bitField0_ & ~0x00000100);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optional: Path at which the file to which the container's termination message
       * will be written is mounted into the container's filesystem.
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes. The total message length across
       * all containers will be limited to 12kb.
       * Defaults to /dev/termination-log.
       * Cannot be updated.
       * +optional
       * </pre>
       *
       * <code>optional string termination_message_path = 13 [json_name = "terminationMessagePath"];</code>
       * @param value The bytes for terminationMessagePath to set.
       * @return This builder for chaining.
       */
      public Builder setTerminationMessagePathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        terminationMessagePath_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }

      private java.lang.Object terminationMessagePolicy_ = "";
      /**
       * <pre>
       * Indicate how the termination message should be populated. File will use the contents of
       * terminationMessagePath to populate the container status message on both success and failure.
       * FallbackToLogsOnError will use the last chunk of container log output if the termination
       * message file is empty and the container exited with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       * +optional
       * </pre>
       *
       * <code>optional string termination_message_policy = 20 [json_name = "terminationMessagePolicy"];</code>
       * @return Whether the terminationMessagePolicy field is set.
       */
      public boolean hasTerminationMessagePolicy() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * Indicate how the termination message should be populated. File will use the contents of
       * terminationMessagePath to populate the container status message on both success and failure.
       * FallbackToLogsOnError will use the last chunk of container log output if the termination
       * message file is empty and the container exited with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       * +optional
       * </pre>
       *
       * <code>optional string termination_message_policy = 20 [json_name = "terminationMessagePolicy"];</code>
       * @return The terminationMessagePolicy.
       */
      public java.lang.String getTerminationMessagePolicy() {
        java.lang.Object ref = terminationMessagePolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          terminationMessagePolicy_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Indicate how the termination message should be populated. File will use the contents of
       * terminationMessagePath to populate the container status message on both success and failure.
       * FallbackToLogsOnError will use the last chunk of container log output if the termination
       * message file is empty and the container exited with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       * +optional
       * </pre>
       *
       * <code>optional string termination_message_policy = 20 [json_name = "terminationMessagePolicy"];</code>
       * @return The bytes for terminationMessagePolicy.
       */
      public com.google.protobuf.ByteString
          getTerminationMessagePolicyBytes() {
        java.lang.Object ref = terminationMessagePolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          terminationMessagePolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Indicate how the termination message should be populated. File will use the contents of
       * terminationMessagePath to populate the container status message on both success and failure.
       * FallbackToLogsOnError will use the last chunk of container log output if the termination
       * message file is empty and the container exited with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       * +optional
       * </pre>
       *
       * <code>optional string termination_message_policy = 20 [json_name = "terminationMessagePolicy"];</code>
       * @param value The terminationMessagePolicy to set.
       * @return This builder for chaining.
       */
      public Builder setTerminationMessagePolicy(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        terminationMessagePolicy_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicate how the termination message should be populated. File will use the contents of
       * terminationMessagePath to populate the container status message on both success and failure.
       * FallbackToLogsOnError will use the last chunk of container log output if the termination
       * message file is empty and the container exited with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       * +optional
       * </pre>
       *
       * <code>optional string termination_message_policy = 20 [json_name = "terminationMessagePolicy"];</code>
       * @return This builder for chaining.
       */
      public Builder clearTerminationMessagePolicy() {
        terminationMessagePolicy_ = getDefaultInstance().getTerminationMessagePolicy();
        bitField0_ = (bitField0_ & ~0x00000200);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicate how the termination message should be populated. File will use the contents of
       * terminationMessagePath to populate the container status message on both success and failure.
       * FallbackToLogsOnError will use the last chunk of container log output if the termination
       * message file is empty and the container exited with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       * +optional
       * </pre>
       *
       * <code>optional string termination_message_policy = 20 [json_name = "terminationMessagePolicy"];</code>
       * @param value The bytes for terminationMessagePolicy to set.
       * @return This builder for chaining.
       */
      public Builder setTerminationMessagePolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        terminationMessagePolicy_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }

      private java.lang.Object imagePullPolicy_ = "";
      /**
       * <pre>
       * Image pull policy.
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
       * +optional
       * </pre>
       *
       * <code>optional string image_pull_policy = 14 [json_name = "imagePullPolicy"];</code>
       * @return Whether the imagePullPolicy field is set.
       */
      public boolean hasImagePullPolicy() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <pre>
       * Image pull policy.
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
       * +optional
       * </pre>
       *
       * <code>optional string image_pull_policy = 14 [json_name = "imagePullPolicy"];</code>
       * @return The imagePullPolicy.
       */
      public java.lang.String getImagePullPolicy() {
        java.lang.Object ref = imagePullPolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          imagePullPolicy_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Image pull policy.
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
       * +optional
       * </pre>
       *
       * <code>optional string image_pull_policy = 14 [json_name = "imagePullPolicy"];</code>
       * @return The bytes for imagePullPolicy.
       */
      public com.google.protobuf.ByteString
          getImagePullPolicyBytes() {
        java.lang.Object ref = imagePullPolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          imagePullPolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Image pull policy.
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
       * +optional
       * </pre>
       *
       * <code>optional string image_pull_policy = 14 [json_name = "imagePullPolicy"];</code>
       * @param value The imagePullPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setImagePullPolicy(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        imagePullPolicy_ = value;
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Image pull policy.
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
       * +optional
       * </pre>
       *
       * <code>optional string image_pull_policy = 14 [json_name = "imagePullPolicy"];</code>
       * @return This builder for chaining.
       */
      public Builder clearImagePullPolicy() {
        imagePullPolicy_ = getDefaultInstance().getImagePullPolicy();
        bitField0_ = (bitField0_ & ~0x00000400);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Image pull policy.
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
       * +optional
       * </pre>
       *
       * <code>optional string image_pull_policy = 14 [json_name = "imagePullPolicy"];</code>
       * @param value The bytes for imagePullPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setImagePullPolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        imagePullPolicy_ = value;
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }

      private boolean stdin_ ;
      /**
       * <pre>
       * Whether this container should allocate a buffer for stdin in the container runtime. If this
       * is not set, reads from stdin in the container will always result in EOF.
       * </pre>
       *
       * <code>bool stdin = 16 [json_name = "stdin"];</code>
       * @return The stdin.
       */
      @java.lang.Override
      public boolean getStdin() {
        return stdin_;
      }
      /**
       * <pre>
       * Whether this container should allocate a buffer for stdin in the container runtime. If this
       * is not set, reads from stdin in the container will always result in EOF.
       * </pre>
       *
       * <code>bool stdin = 16 [json_name = "stdin"];</code>
       * @param value The stdin to set.
       * @return This builder for chaining.
       */
      public Builder setStdin(boolean value) {

        stdin_ = value;
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether this container should allocate a buffer for stdin in the container runtime. If this
       * is not set, reads from stdin in the container will always result in EOF.
       * </pre>
       *
       * <code>bool stdin = 16 [json_name = "stdin"];</code>
       * @return This builder for chaining.
       */
      public Builder clearStdin() {
        bitField0_ = (bitField0_ & ~0x00000800);
        stdin_ = false;
        onChanged();
        return this;
      }

      private boolean stdinOnce_ ;
      /**
       * <pre>
       * Whether the container runtime should close the stdin channel after it has been opened by
       * a single attach. When stdin is true the stdin stream will remain open across multiple attach
       * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
       * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
       * at which time stdin is closed and remains closed until the container is restarted. If this
       * flag is false, a container processes that reads from stdin will never receive an EOF.
       * </pre>
       *
       * <code>bool stdin_once = 17 [json_name = "stdinOnce"];</code>
       * @return The stdinOnce.
       */
      @java.lang.Override
      public boolean getStdinOnce() {
        return stdinOnce_;
      }
      /**
       * <pre>
       * Whether the container runtime should close the stdin channel after it has been opened by
       * a single attach. When stdin is true the stdin stream will remain open across multiple attach
       * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
       * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
       * at which time stdin is closed and remains closed until the container is restarted. If this
       * flag is false, a container processes that reads from stdin will never receive an EOF.
       * </pre>
       *
       * <code>bool stdin_once = 17 [json_name = "stdinOnce"];</code>
       * @param value The stdinOnce to set.
       * @return This builder for chaining.
       */
      public Builder setStdinOnce(boolean value) {

        stdinOnce_ = value;
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether the container runtime should close the stdin channel after it has been opened by
       * a single attach. When stdin is true the stdin stream will remain open across multiple attach
       * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
       * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
       * at which time stdin is closed and remains closed until the container is restarted. If this
       * flag is false, a container processes that reads from stdin will never receive an EOF.
       * </pre>
       *
       * <code>bool stdin_once = 17 [json_name = "stdinOnce"];</code>
       * @return This builder for chaining.
       */
      public Builder clearStdinOnce() {
        bitField0_ = (bitField0_ & ~0x00001000);
        stdinOnce_ = false;
        onChanged();
        return this;
      }

      private boolean tty_ ;
      /**
       * <pre>
       * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
       * </pre>
       *
       * <code>bool tty = 18 [json_name = "tty"];</code>
       * @return The tty.
       */
      @java.lang.Override
      public boolean getTty() {
        return tty_;
      }
      /**
       * <pre>
       * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
       * </pre>
       *
       * <code>bool tty = 18 [json_name = "tty"];</code>
       * @param value The tty to set.
       * @return This builder for chaining.
       */
      public Builder setTty(boolean value) {

        tty_ = value;
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
       * </pre>
       *
       * <code>bool tty = 18 [json_name = "tty"];</code>
       * @return This builder for chaining.
       */
      public Builder clearTty() {
        bitField0_ = (bitField0_ & ~0x00002000);
        tty_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chalk.pubsub.v1.PodStatusPubSub.Container)
    }

    // @@protoc_insertion_point(class_scope:chalk.pubsub.v1.PodStatusPubSub.Container)
    private static final ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container();
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Container>
        PARSER = new com.google.protobuf.AbstractParser<Container>() {
      @java.lang.Override
      public Container parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Container> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Container> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Container getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ContainerStateWaitingOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * (brief) reason the container is not yet running.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 1 [json_name = "reason"];</code>
     * @return Whether the reason field is set.
     */
    boolean hasReason();
    /**
     * <pre>
     * (brief) reason the container is not yet running.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 1 [json_name = "reason"];</code>
     * @return The reason.
     */
    java.lang.String getReason();
    /**
     * <pre>
     * (brief) reason the container is not yet running.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 1 [json_name = "reason"];</code>
     * @return The bytes for reason.
     */
    com.google.protobuf.ByteString
        getReasonBytes();

    /**
     * <pre>
     * Message regarding why the container is not yet running.
     * +optional
     * </pre>
     *
     * <code>optional string message = 2 [json_name = "message"];</code>
     * @return Whether the message field is set.
     */
    boolean hasMessage();
    /**
     * <pre>
     * Message regarding why the container is not yet running.
     * +optional
     * </pre>
     *
     * <code>optional string message = 2 [json_name = "message"];</code>
     * @return The message.
     */
    java.lang.String getMessage();
    /**
     * <pre>
     * Message regarding why the container is not yet running.
     * +optional
     * </pre>
     *
     * <code>optional string message = 2 [json_name = "message"];</code>
     * @return The bytes for message.
     */
    com.google.protobuf.ByteString
        getMessageBytes();
  }
  /**
   * <pre>
   * ContainerStateWaiting is a waiting state of a container.
   * </pre>
   *
   * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting}
   */
  public static final class ContainerStateWaiting extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting)
      ContainerStateWaitingOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ContainerStateWaiting.newBuilder() to construct.
    private ContainerStateWaiting(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ContainerStateWaiting() {
      reason_ = "";
      message_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ContainerStateWaiting();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ContainerStateWaiting_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ContainerStateWaiting_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting.Builder.class);
    }

    private int bitField0_;
    public static final int REASON_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object reason_ = "";
    /**
     * <pre>
     * (brief) reason the container is not yet running.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 1 [json_name = "reason"];</code>
     * @return Whether the reason field is set.
     */
    @java.lang.Override
    public boolean hasReason() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * (brief) reason the container is not yet running.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 1 [json_name = "reason"];</code>
     * @return The reason.
     */
    @java.lang.Override
    public java.lang.String getReason() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        reason_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * (brief) reason the container is not yet running.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 1 [json_name = "reason"];</code>
     * @return The bytes for reason.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getReasonBytes() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        reason_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MESSAGE_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object message_ = "";
    /**
     * <pre>
     * Message regarding why the container is not yet running.
     * +optional
     * </pre>
     *
     * <code>optional string message = 2 [json_name = "message"];</code>
     * @return Whether the message field is set.
     */
    @java.lang.Override
    public boolean hasMessage() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Message regarding why the container is not yet running.
     * +optional
     * </pre>
     *
     * <code>optional string message = 2 [json_name = "message"];</code>
     * @return The message.
     */
    @java.lang.Override
    public java.lang.String getMessage() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        message_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Message regarding why the container is not yet running.
     * +optional
     * </pre>
     *
     * <code>optional string message = 2 [json_name = "message"];</code>
     * @return The bytes for message.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getMessageBytes() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        message_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, reason_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, message_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, reason_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, message_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting)) {
        return super.equals(obj);
      }
      ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting other = (ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting) obj;

      if (hasReason() != other.hasReason()) return false;
      if (hasReason()) {
        if (!getReason()
            .equals(other.getReason())) return false;
      }
      if (hasMessage() != other.hasMessage()) return false;
      if (hasMessage()) {
        if (!getMessage()
            .equals(other.getMessage())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasReason()) {
        hash = (37 * hash) + REASON_FIELD_NUMBER;
        hash = (53 * hash) + getReason().hashCode();
      }
      if (hasMessage()) {
        hash = (37 * hash) + MESSAGE_FIELD_NUMBER;
        hash = (53 * hash) + getMessage().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ContainerStateWaiting is a waiting state of a container.
     * </pre>
     *
     * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting)
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaitingOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ContainerStateWaiting_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ContainerStateWaiting_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting.Builder.class);
      }

      // Construct using ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        reason_ = "";
        message_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ContainerStateWaiting_descriptor;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting getDefaultInstanceForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting.getDefaultInstance();
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting build() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting buildPartial() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting result = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.reason_ = reason_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.message_ = message_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting) {
          return mergeFrom((ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting other) {
        if (other == ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting.getDefaultInstance()) return this;
        if (other.hasReason()) {
          reason_ = other.reason_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasMessage()) {
          message_ = other.message_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                reason_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                message_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object reason_ = "";
      /**
       * <pre>
       * (brief) reason the container is not yet running.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 1 [json_name = "reason"];</code>
       * @return Whether the reason field is set.
       */
      public boolean hasReason() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * (brief) reason the container is not yet running.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 1 [json_name = "reason"];</code>
       * @return The reason.
       */
      public java.lang.String getReason() {
        java.lang.Object ref = reason_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          reason_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * (brief) reason the container is not yet running.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 1 [json_name = "reason"];</code>
       * @return The bytes for reason.
       */
      public com.google.protobuf.ByteString
          getReasonBytes() {
        java.lang.Object ref = reason_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          reason_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * (brief) reason the container is not yet running.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 1 [json_name = "reason"];</code>
       * @param value The reason to set.
       * @return This builder for chaining.
       */
      public Builder setReason(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        reason_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * (brief) reason the container is not yet running.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 1 [json_name = "reason"];</code>
       * @return This builder for chaining.
       */
      public Builder clearReason() {
        reason_ = getDefaultInstance().getReason();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * (brief) reason the container is not yet running.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 1 [json_name = "reason"];</code>
       * @param value The bytes for reason to set.
       * @return This builder for chaining.
       */
      public Builder setReasonBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        reason_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object message_ = "";
      /**
       * <pre>
       * Message regarding why the container is not yet running.
       * +optional
       * </pre>
       *
       * <code>optional string message = 2 [json_name = "message"];</code>
       * @return Whether the message field is set.
       */
      public boolean hasMessage() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Message regarding why the container is not yet running.
       * +optional
       * </pre>
       *
       * <code>optional string message = 2 [json_name = "message"];</code>
       * @return The message.
       */
      public java.lang.String getMessage() {
        java.lang.Object ref = message_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          message_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Message regarding why the container is not yet running.
       * +optional
       * </pre>
       *
       * <code>optional string message = 2 [json_name = "message"];</code>
       * @return The bytes for message.
       */
      public com.google.protobuf.ByteString
          getMessageBytes() {
        java.lang.Object ref = message_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          message_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Message regarding why the container is not yet running.
       * +optional
       * </pre>
       *
       * <code>optional string message = 2 [json_name = "message"];</code>
       * @param value The message to set.
       * @return This builder for chaining.
       */
      public Builder setMessage(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        message_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Message regarding why the container is not yet running.
       * +optional
       * </pre>
       *
       * <code>optional string message = 2 [json_name = "message"];</code>
       * @return This builder for chaining.
       */
      public Builder clearMessage() {
        message_ = getDefaultInstance().getMessage();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Message regarding why the container is not yet running.
       * +optional
       * </pre>
       *
       * <code>optional string message = 2 [json_name = "message"];</code>
       * @param value The bytes for message to set.
       * @return This builder for chaining.
       */
      public Builder setMessageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        message_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting)
    }

    // @@protoc_insertion_point(class_scope:chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting)
    private static final ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting();
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ContainerStateWaiting>
        PARSER = new com.google.protobuf.AbstractParser<ContainerStateWaiting>() {
      @java.lang.Override
      public ContainerStateWaiting parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ContainerStateWaiting> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ContainerStateWaiting> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateWaiting getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ContainerStatusOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chalk.pubsub.v1.PodStatusPubSub.ContainerStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Name is a DNS_LABEL representing the unique name of the container.
     * Each container in a pod must have a unique name across all container types.
     * Cannot be updated.
     * </pre>
     *
     * <code>string name = 1 [json_name = "name"];</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * Name is a DNS_LABEL representing the unique name of the container.
     * Each container in a pod must have a unique name across all container types.
     * Cannot be updated.
     * </pre>
     *
     * <code>string name = 1 [json_name = "name"];</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * State holds details about the container's current condition.
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState state = 2 [json_name = "state"];</code>
     * @return Whether the state field is set.
     */
    boolean hasState();
    /**
     * <pre>
     * State holds details about the container's current condition.
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState state = 2 [json_name = "state"];</code>
     * @return The state.
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState getState();
    /**
     * <pre>
     * State holds details about the container's current condition.
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState state = 2 [json_name = "state"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateOrBuilder getStateOrBuilder();

    /**
     * <pre>
     * LastTerminationState holds the last termination state of the container to
     * help debug container crashes and restarts. This field is not
     * populated if the container is still running and RestartCount is 0.
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState last_state = 3 [json_name = "lastState"];</code>
     * @return Whether the lastState field is set.
     */
    boolean hasLastState();
    /**
     * <pre>
     * LastTerminationState holds the last termination state of the container to
     * help debug container crashes and restarts. This field is not
     * populated if the container is still running and RestartCount is 0.
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState last_state = 3 [json_name = "lastState"];</code>
     * @return The lastState.
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState getLastState();
    /**
     * <pre>
     * LastTerminationState holds the last termination state of the container to
     * help debug container crashes and restarts. This field is not
     * populated if the container is still running and RestartCount is 0.
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState last_state = 3 [json_name = "lastState"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateOrBuilder getLastStateOrBuilder();

    /**
     * <pre>
     * Ready specifies whether the container is currently passing its readiness check.
     * The value will change as readiness probes keep executing. If no readiness
     * probes are specified, this field defaults to true once the container is
     * fully started (see Started field).
     *
     * The value is typically used to determine whether a container is ready to
     * accept traffic.
     * </pre>
     *
     * <code>optional bool ready = 4 [json_name = "ready"];</code>
     * @return Whether the ready field is set.
     */
    boolean hasReady();
    /**
     * <pre>
     * Ready specifies whether the container is currently passing its readiness check.
     * The value will change as readiness probes keep executing. If no readiness
     * probes are specified, this field defaults to true once the container is
     * fully started (see Started field).
     *
     * The value is typically used to determine whether a container is ready to
     * accept traffic.
     * </pre>
     *
     * <code>optional bool ready = 4 [json_name = "ready"];</code>
     * @return The ready.
     */
    boolean getReady();

    /**
     * <pre>
     * RestartCount holds the number of times the container has been restarted.
     * Kubelet makes an effort to always increment the value, but there
     * are cases when the state may be lost due to node restarts and then the value
     * may be reset to 0. The value is never negative.
     * </pre>
     *
     * <code>int32 restart_count = 5 [json_name = "restartCount"];</code>
     * @return The restartCount.
     */
    int getRestartCount();

    /**
     * <pre>
     * Image is the name of container image that the container is running.
     * The container image may not match the image used in the PodSpec,
     * as it may have been resolved by the runtime.
     * More info: https://kubernetes.io/docs/concepts/containers/images.
     * </pre>
     *
     * <code>string image = 6 [json_name = "image"];</code>
     * @return The image.
     */
    java.lang.String getImage();
    /**
     * <pre>
     * Image is the name of container image that the container is running.
     * The container image may not match the image used in the PodSpec,
     * as it may have been resolved by the runtime.
     * More info: https://kubernetes.io/docs/concepts/containers/images.
     * </pre>
     *
     * <code>string image = 6 [json_name = "image"];</code>
     * @return The bytes for image.
     */
    com.google.protobuf.ByteString
        getImageBytes();

    /**
     * <pre>
     * ImageID is the image ID of the container's image. The image ID may not
     * match the image ID of the image used in the PodSpec, as it may have been
     * resolved by the runtime.
     * </pre>
     *
     * <code>string image_id = 7 [json_name = "imageId"];</code>
     * @return The imageId.
     */
    java.lang.String getImageId();
    /**
     * <pre>
     * ImageID is the image ID of the container's image. The image ID may not
     * match the image ID of the image used in the PodSpec, as it may have been
     * resolved by the runtime.
     * </pre>
     *
     * <code>string image_id = 7 [json_name = "imageId"];</code>
     * @return The bytes for imageId.
     */
    com.google.protobuf.ByteString
        getImageIdBytes();

    /**
     * <pre>
     * ContainerID is the ID of the container in the format '&lt;type&gt;://&lt;container_id&gt;'.
     * Where type is a container runtime identifier, returned from Version call of CRI API
     * (for example "containerd").
     * +optional
     * </pre>
     *
     * <code>string container_id = 8 [json_name = "containerId"];</code>
     * @return The containerId.
     */
    java.lang.String getContainerId();
    /**
     * <pre>
     * ContainerID is the ID of the container in the format '&lt;type&gt;://&lt;container_id&gt;'.
     * Where type is a container runtime identifier, returned from Version call of CRI API
     * (for example "containerd").
     * +optional
     * </pre>
     *
     * <code>string container_id = 8 [json_name = "containerId"];</code>
     * @return The bytes for containerId.
     */
    com.google.protobuf.ByteString
        getContainerIdBytes();

    /**
     * <pre>
     * Started indicates whether the container has finished its postStart lifecycle hook
     * and passed its startup probe.
     * Initialized as false, becomes true after startupProbe is considered
     * successful. Resets to false when the container is restarted, or if kubelet
     * loses state temporarily. In both cases, startup probes will run again.
     * Is always true when no startupProbe is defined and container is running and
     * has passed the postStart lifecycle hook.
     * </pre>
     *
     * <code>bool started = 9 [json_name = "started"];</code>
     * @return The started.
     */
    boolean getStarted();
  }
  /**
   * <pre>
   * ContainerStatus contains details for the current status of this container.
   * </pre>
   *
   * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.ContainerStatus}
   */
  public static final class ContainerStatus extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chalk.pubsub.v1.PodStatusPubSub.ContainerStatus)
      ContainerStatusOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ContainerStatus.newBuilder() to construct.
    private ContainerStatus(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ContainerStatus() {
      name_ = "";
      image_ = "";
      imageId_ = "";
      containerId_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ContainerStatus();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ContainerStatus_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ContainerStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * Name is a DNS_LABEL representing the unique name of the container.
     * Each container in a pod must have a unique name across all container types.
     * Cannot be updated.
     * </pre>
     *
     * <code>string name = 1 [json_name = "name"];</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Name is a DNS_LABEL representing the unique name of the container.
     * Each container in a pod must have a unique name across all container types.
     * Cannot be updated.
     * </pre>
     *
     * <code>string name = 1 [json_name = "name"];</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STATE_FIELD_NUMBER = 2;
    private ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState state_;
    /**
     * <pre>
     * State holds details about the container's current condition.
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState state = 2 [json_name = "state"];</code>
     * @return Whether the state field is set.
     */
    @java.lang.Override
    public boolean hasState() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * State holds details about the container's current condition.
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState state = 2 [json_name = "state"];</code>
     * @return The state.
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState getState() {
      return state_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.getDefaultInstance() : state_;
    }
    /**
     * <pre>
     * State holds details about the container's current condition.
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState state = 2 [json_name = "state"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateOrBuilder getStateOrBuilder() {
      return state_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.getDefaultInstance() : state_;
    }

    public static final int LAST_STATE_FIELD_NUMBER = 3;
    private ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState lastState_;
    /**
     * <pre>
     * LastTerminationState holds the last termination state of the container to
     * help debug container crashes and restarts. This field is not
     * populated if the container is still running and RestartCount is 0.
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState last_state = 3 [json_name = "lastState"];</code>
     * @return Whether the lastState field is set.
     */
    @java.lang.Override
    public boolean hasLastState() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * LastTerminationState holds the last termination state of the container to
     * help debug container crashes and restarts. This field is not
     * populated if the container is still running and RestartCount is 0.
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState last_state = 3 [json_name = "lastState"];</code>
     * @return The lastState.
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState getLastState() {
      return lastState_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.getDefaultInstance() : lastState_;
    }
    /**
     * <pre>
     * LastTerminationState holds the last termination state of the container to
     * help debug container crashes and restarts. This field is not
     * populated if the container is still running and RestartCount is 0.
     * +optional
     * </pre>
     *
     * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState last_state = 3 [json_name = "lastState"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateOrBuilder getLastStateOrBuilder() {
      return lastState_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.getDefaultInstance() : lastState_;
    }

    public static final int READY_FIELD_NUMBER = 4;
    private boolean ready_ = false;
    /**
     * <pre>
     * Ready specifies whether the container is currently passing its readiness check.
     * The value will change as readiness probes keep executing. If no readiness
     * probes are specified, this field defaults to true once the container is
     * fully started (see Started field).
     *
     * The value is typically used to determine whether a container is ready to
     * accept traffic.
     * </pre>
     *
     * <code>optional bool ready = 4 [json_name = "ready"];</code>
     * @return Whether the ready field is set.
     */
    @java.lang.Override
    public boolean hasReady() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Ready specifies whether the container is currently passing its readiness check.
     * The value will change as readiness probes keep executing. If no readiness
     * probes are specified, this field defaults to true once the container is
     * fully started (see Started field).
     *
     * The value is typically used to determine whether a container is ready to
     * accept traffic.
     * </pre>
     *
     * <code>optional bool ready = 4 [json_name = "ready"];</code>
     * @return The ready.
     */
    @java.lang.Override
    public boolean getReady() {
      return ready_;
    }

    public static final int RESTART_COUNT_FIELD_NUMBER = 5;
    private int restartCount_ = 0;
    /**
     * <pre>
     * RestartCount holds the number of times the container has been restarted.
     * Kubelet makes an effort to always increment the value, but there
     * are cases when the state may be lost due to node restarts and then the value
     * may be reset to 0. The value is never negative.
     * </pre>
     *
     * <code>int32 restart_count = 5 [json_name = "restartCount"];</code>
     * @return The restartCount.
     */
    @java.lang.Override
    public int getRestartCount() {
      return restartCount_;
    }

    public static final int IMAGE_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private volatile java.lang.Object image_ = "";
    /**
     * <pre>
     * Image is the name of container image that the container is running.
     * The container image may not match the image used in the PodSpec,
     * as it may have been resolved by the runtime.
     * More info: https://kubernetes.io/docs/concepts/containers/images.
     * </pre>
     *
     * <code>string image = 6 [json_name = "image"];</code>
     * @return The image.
     */
    @java.lang.Override
    public java.lang.String getImage() {
      java.lang.Object ref = image_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        image_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Image is the name of container image that the container is running.
     * The container image may not match the image used in the PodSpec,
     * as it may have been resolved by the runtime.
     * More info: https://kubernetes.io/docs/concepts/containers/images.
     * </pre>
     *
     * <code>string image = 6 [json_name = "image"];</code>
     * @return The bytes for image.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getImageBytes() {
      java.lang.Object ref = image_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        image_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int IMAGE_ID_FIELD_NUMBER = 7;
    @SuppressWarnings("serial")
    private volatile java.lang.Object imageId_ = "";
    /**
     * <pre>
     * ImageID is the image ID of the container's image. The image ID may not
     * match the image ID of the image used in the PodSpec, as it may have been
     * resolved by the runtime.
     * </pre>
     *
     * <code>string image_id = 7 [json_name = "imageId"];</code>
     * @return The imageId.
     */
    @java.lang.Override
    public java.lang.String getImageId() {
      java.lang.Object ref = imageId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        imageId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * ImageID is the image ID of the container's image. The image ID may not
     * match the image ID of the image used in the PodSpec, as it may have been
     * resolved by the runtime.
     * </pre>
     *
     * <code>string image_id = 7 [json_name = "imageId"];</code>
     * @return The bytes for imageId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getImageIdBytes() {
      java.lang.Object ref = imageId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        imageId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CONTAINER_ID_FIELD_NUMBER = 8;
    @SuppressWarnings("serial")
    private volatile java.lang.Object containerId_ = "";
    /**
     * <pre>
     * ContainerID is the ID of the container in the format '&lt;type&gt;://&lt;container_id&gt;'.
     * Where type is a container runtime identifier, returned from Version call of CRI API
     * (for example "containerd").
     * +optional
     * </pre>
     *
     * <code>string container_id = 8 [json_name = "containerId"];</code>
     * @return The containerId.
     */
    @java.lang.Override
    public java.lang.String getContainerId() {
      java.lang.Object ref = containerId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        containerId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * ContainerID is the ID of the container in the format '&lt;type&gt;://&lt;container_id&gt;'.
     * Where type is a container runtime identifier, returned from Version call of CRI API
     * (for example "containerd").
     * +optional
     * </pre>
     *
     * <code>string container_id = 8 [json_name = "containerId"];</code>
     * @return The bytes for containerId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getContainerIdBytes() {
      java.lang.Object ref = containerId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        containerId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STARTED_FIELD_NUMBER = 9;
    private boolean started_ = false;
    /**
     * <pre>
     * Started indicates whether the container has finished its postStart lifecycle hook
     * and passed its startup probe.
     * Initialized as false, becomes true after startupProbe is considered
     * successful. Resets to false when the container is restarted, or if kubelet
     * loses state temporarily. In both cases, startup probes will run again.
     * Is always true when no startupProbe is defined and container is running and
     * has passed the postStart lifecycle hook.
     * </pre>
     *
     * <code>bool started = 9 [json_name = "started"];</code>
     * @return The started.
     */
    @java.lang.Override
    public boolean getStarted() {
      return started_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(name_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(2, getState());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(3, getLastState());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeBool(4, ready_);
      }
      if (restartCount_ != 0) {
        output.writeInt32(5, restartCount_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(image_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 6, image_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(imageId_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 7, imageId_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(containerId_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 8, containerId_);
      }
      if (started_ != false) {
        output.writeBool(9, started_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(name_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getState());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getLastState());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(4, ready_);
      }
      if (restartCount_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(5, restartCount_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(image_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, image_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(imageId_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(7, imageId_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(containerId_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(8, containerId_);
      }
      if (started_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(9, started_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus)) {
        return super.equals(obj);
      }
      ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus other = (ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus) obj;

      if (!getName()
          .equals(other.getName())) return false;
      if (hasState() != other.hasState()) return false;
      if (hasState()) {
        if (!getState()
            .equals(other.getState())) return false;
      }
      if (hasLastState() != other.hasLastState()) return false;
      if (hasLastState()) {
        if (!getLastState()
            .equals(other.getLastState())) return false;
      }
      if (hasReady() != other.hasReady()) return false;
      if (hasReady()) {
        if (getReady()
            != other.getReady()) return false;
      }
      if (getRestartCount()
          != other.getRestartCount()) return false;
      if (!getImage()
          .equals(other.getImage())) return false;
      if (!getImageId()
          .equals(other.getImageId())) return false;
      if (!getContainerId()
          .equals(other.getContainerId())) return false;
      if (getStarted()
          != other.getStarted()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      if (hasState()) {
        hash = (37 * hash) + STATE_FIELD_NUMBER;
        hash = (53 * hash) + getState().hashCode();
      }
      if (hasLastState()) {
        hash = (37 * hash) + LAST_STATE_FIELD_NUMBER;
        hash = (53 * hash) + getLastState().hashCode();
      }
      if (hasReady()) {
        hash = (37 * hash) + READY_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getReady());
      }
      hash = (37 * hash) + RESTART_COUNT_FIELD_NUMBER;
      hash = (53 * hash) + getRestartCount();
      hash = (37 * hash) + IMAGE_FIELD_NUMBER;
      hash = (53 * hash) + getImage().hashCode();
      hash = (37 * hash) + IMAGE_ID_FIELD_NUMBER;
      hash = (53 * hash) + getImageId().hashCode();
      hash = (37 * hash) + CONTAINER_ID_FIELD_NUMBER;
      hash = (53 * hash) + getContainerId().hashCode();
      hash = (37 * hash) + STARTED_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getStarted());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ContainerStatus contains details for the current status of this container.
     * </pre>
     *
     * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.ContainerStatus}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chalk.pubsub.v1.PodStatusPubSub.ContainerStatus)
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ContainerStatus_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ContainerStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder.class);
      }

      // Construct using ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getStateFieldBuilder();
          getLastStateFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        name_ = "";
        state_ = null;
        if (stateBuilder_ != null) {
          stateBuilder_.dispose();
          stateBuilder_ = null;
        }
        lastState_ = null;
        if (lastStateBuilder_ != null) {
          lastStateBuilder_.dispose();
          lastStateBuilder_ = null;
        }
        ready_ = false;
        restartCount_ = 0;
        image_ = "";
        imageId_ = "";
        containerId_ = "";
        started_ = false;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ContainerStatus_descriptor;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus getDefaultInstanceForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.getDefaultInstance();
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus build() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus buildPartial() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus result = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.name_ = name_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.state_ = stateBuilder_ == null
              ? state_
              : stateBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.lastState_ = lastStateBuilder_ == null
              ? lastState_
              : lastStateBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.ready_ = ready_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.restartCount_ = restartCount_;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.image_ = image_;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.imageId_ = imageId_;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.containerId_ = containerId_;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.started_ = started_;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus) {
          return mergeFrom((ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus other) {
        if (other == ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.getDefaultInstance()) return this;
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasState()) {
          mergeState(other.getState());
        }
        if (other.hasLastState()) {
          mergeLastState(other.getLastState());
        }
        if (other.hasReady()) {
          setReady(other.getReady());
        }
        if (other.getRestartCount() != 0) {
          setRestartCount(other.getRestartCount());
        }
        if (!other.getImage().isEmpty()) {
          image_ = other.image_;
          bitField0_ |= 0x00000020;
          onChanged();
        }
        if (!other.getImageId().isEmpty()) {
          imageId_ = other.imageId_;
          bitField0_ |= 0x00000040;
          onChanged();
        }
        if (!other.getContainerId().isEmpty()) {
          containerId_ = other.containerId_;
          bitField0_ |= 0x00000080;
          onChanged();
        }
        if (other.getStarted() != false) {
          setStarted(other.getStarted());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                name_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getStateFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getLastStateFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 32: {
                ready_ = input.readBool();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              case 40: {
                restartCount_ = input.readInt32();
                bitField0_ |= 0x00000010;
                break;
              } // case 40
              case 50: {
                image_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000020;
                break;
              } // case 50
              case 58: {
                imageId_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000040;
                break;
              } // case 58
              case 66: {
                containerId_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000080;
                break;
              } // case 66
              case 72: {
                started_ = input.readBool();
                bitField0_ |= 0x00000100;
                break;
              } // case 72
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * Name is a DNS_LABEL representing the unique name of the container.
       * Each container in a pod must have a unique name across all container types.
       * Cannot be updated.
       * </pre>
       *
       * <code>string name = 1 [json_name = "name"];</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Name is a DNS_LABEL representing the unique name of the container.
       * Each container in a pod must have a unique name across all container types.
       * Cannot be updated.
       * </pre>
       *
       * <code>string name = 1 [json_name = "name"];</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Name is a DNS_LABEL representing the unique name of the container.
       * Each container in a pod must have a unique name across all container types.
       * Cannot be updated.
       * </pre>
       *
       * <code>string name = 1 [json_name = "name"];</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name is a DNS_LABEL representing the unique name of the container.
       * Each container in a pod must have a unique name across all container types.
       * Cannot be updated.
       * </pre>
       *
       * <code>string name = 1 [json_name = "name"];</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name is a DNS_LABEL representing the unique name of the container.
       * Each container in a pod must have a unique name across all container types.
       * Cannot be updated.
       * </pre>
       *
       * <code>string name = 1 [json_name = "name"];</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState state_;
      private com.google.protobuf.SingleFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateOrBuilder> stateBuilder_;
      /**
       * <pre>
       * State holds details about the container's current condition.
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState state = 2 [json_name = "state"];</code>
       * @return Whether the state field is set.
       */
      public boolean hasState() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * State holds details about the container's current condition.
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState state = 2 [json_name = "state"];</code>
       * @return The state.
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState getState() {
        if (stateBuilder_ == null) {
          return state_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.getDefaultInstance() : state_;
        } else {
          return stateBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * State holds details about the container's current condition.
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState state = 2 [json_name = "state"];</code>
       */
      public Builder setState(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState value) {
        if (stateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          state_ = value;
        } else {
          stateBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * State holds details about the container's current condition.
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState state = 2 [json_name = "state"];</code>
       */
      public Builder setState(
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.Builder builderForValue) {
        if (stateBuilder_ == null) {
          state_ = builderForValue.build();
        } else {
          stateBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * State holds details about the container's current condition.
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState state = 2 [json_name = "state"];</code>
       */
      public Builder mergeState(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState value) {
        if (stateBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            state_ != null &&
            state_ != ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.getDefaultInstance()) {
            getStateBuilder().mergeFrom(value);
          } else {
            state_ = value;
          }
        } else {
          stateBuilder_.mergeFrom(value);
        }
        if (state_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * State holds details about the container's current condition.
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState state = 2 [json_name = "state"];</code>
       */
      public Builder clearState() {
        bitField0_ = (bitField0_ & ~0x00000002);
        state_ = null;
        if (stateBuilder_ != null) {
          stateBuilder_.dispose();
          stateBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * State holds details about the container's current condition.
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState state = 2 [json_name = "state"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.Builder getStateBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getStateFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * State holds details about the container's current condition.
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState state = 2 [json_name = "state"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateOrBuilder getStateOrBuilder() {
        if (stateBuilder_ != null) {
          return stateBuilder_.getMessageOrBuilder();
        } else {
          return state_ == null ?
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.getDefaultInstance() : state_;
        }
      }
      /**
       * <pre>
       * State holds details about the container's current condition.
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState state = 2 [json_name = "state"];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateOrBuilder> 
          getStateFieldBuilder() {
        if (stateBuilder_ == null) {
          stateBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateOrBuilder>(
                  getState(),
                  getParentForChildren(),
                  isClean());
          state_ = null;
        }
        return stateBuilder_;
      }

      private ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState lastState_;
      private com.google.protobuf.SingleFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateOrBuilder> lastStateBuilder_;
      /**
       * <pre>
       * LastTerminationState holds the last termination state of the container to
       * help debug container crashes and restarts. This field is not
       * populated if the container is still running and RestartCount is 0.
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState last_state = 3 [json_name = "lastState"];</code>
       * @return Whether the lastState field is set.
       */
      public boolean hasLastState() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * LastTerminationState holds the last termination state of the container to
       * help debug container crashes and restarts. This field is not
       * populated if the container is still running and RestartCount is 0.
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState last_state = 3 [json_name = "lastState"];</code>
       * @return The lastState.
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState getLastState() {
        if (lastStateBuilder_ == null) {
          return lastState_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.getDefaultInstance() : lastState_;
        } else {
          return lastStateBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * LastTerminationState holds the last termination state of the container to
       * help debug container crashes and restarts. This field is not
       * populated if the container is still running and RestartCount is 0.
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState last_state = 3 [json_name = "lastState"];</code>
       */
      public Builder setLastState(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState value) {
        if (lastStateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          lastState_ = value;
        } else {
          lastStateBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * LastTerminationState holds the last termination state of the container to
       * help debug container crashes and restarts. This field is not
       * populated if the container is still running and RestartCount is 0.
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState last_state = 3 [json_name = "lastState"];</code>
       */
      public Builder setLastState(
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.Builder builderForValue) {
        if (lastStateBuilder_ == null) {
          lastState_ = builderForValue.build();
        } else {
          lastStateBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * LastTerminationState holds the last termination state of the container to
       * help debug container crashes and restarts. This field is not
       * populated if the container is still running and RestartCount is 0.
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState last_state = 3 [json_name = "lastState"];</code>
       */
      public Builder mergeLastState(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState value) {
        if (lastStateBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            lastState_ != null &&
            lastState_ != ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.getDefaultInstance()) {
            getLastStateBuilder().mergeFrom(value);
          } else {
            lastState_ = value;
          }
        } else {
          lastStateBuilder_.mergeFrom(value);
        }
        if (lastState_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * LastTerminationState holds the last termination state of the container to
       * help debug container crashes and restarts. This field is not
       * populated if the container is still running and RestartCount is 0.
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState last_state = 3 [json_name = "lastState"];</code>
       */
      public Builder clearLastState() {
        bitField0_ = (bitField0_ & ~0x00000004);
        lastState_ = null;
        if (lastStateBuilder_ != null) {
          lastStateBuilder_.dispose();
          lastStateBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * LastTerminationState holds the last termination state of the container to
       * help debug container crashes and restarts. This field is not
       * populated if the container is still running and RestartCount is 0.
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState last_state = 3 [json_name = "lastState"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.Builder getLastStateBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getLastStateFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * LastTerminationState holds the last termination state of the container to
       * help debug container crashes and restarts. This field is not
       * populated if the container is still running and RestartCount is 0.
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState last_state = 3 [json_name = "lastState"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateOrBuilder getLastStateOrBuilder() {
        if (lastStateBuilder_ != null) {
          return lastStateBuilder_.getMessageOrBuilder();
        } else {
          return lastState_ == null ?
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.getDefaultInstance() : lastState_;
        }
      }
      /**
       * <pre>
       * LastTerminationState holds the last termination state of the container to
       * help debug container crashes and restarts. This field is not
       * populated if the container is still running and RestartCount is 0.
       * +optional
       * </pre>
       *
       * <code>optional .chalk.pubsub.v1.PodStatusPubSub.ContainerState last_state = 3 [json_name = "lastState"];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateOrBuilder> 
          getLastStateFieldBuilder() {
        if (lastStateBuilder_ == null) {
          lastStateBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerState.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStateOrBuilder>(
                  getLastState(),
                  getParentForChildren(),
                  isClean());
          lastState_ = null;
        }
        return lastStateBuilder_;
      }

      private boolean ready_ ;
      /**
       * <pre>
       * Ready specifies whether the container is currently passing its readiness check.
       * The value will change as readiness probes keep executing. If no readiness
       * probes are specified, this field defaults to true once the container is
       * fully started (see Started field).
       *
       * The value is typically used to determine whether a container is ready to
       * accept traffic.
       * </pre>
       *
       * <code>optional bool ready = 4 [json_name = "ready"];</code>
       * @return Whether the ready field is set.
       */
      @java.lang.Override
      public boolean hasReady() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Ready specifies whether the container is currently passing its readiness check.
       * The value will change as readiness probes keep executing. If no readiness
       * probes are specified, this field defaults to true once the container is
       * fully started (see Started field).
       *
       * The value is typically used to determine whether a container is ready to
       * accept traffic.
       * </pre>
       *
       * <code>optional bool ready = 4 [json_name = "ready"];</code>
       * @return The ready.
       */
      @java.lang.Override
      public boolean getReady() {
        return ready_;
      }
      /**
       * <pre>
       * Ready specifies whether the container is currently passing its readiness check.
       * The value will change as readiness probes keep executing. If no readiness
       * probes are specified, this field defaults to true once the container is
       * fully started (see Started field).
       *
       * The value is typically used to determine whether a container is ready to
       * accept traffic.
       * </pre>
       *
       * <code>optional bool ready = 4 [json_name = "ready"];</code>
       * @param value The ready to set.
       * @return This builder for chaining.
       */
      public Builder setReady(boolean value) {

        ready_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Ready specifies whether the container is currently passing its readiness check.
       * The value will change as readiness probes keep executing. If no readiness
       * probes are specified, this field defaults to true once the container is
       * fully started (see Started field).
       *
       * The value is typically used to determine whether a container is ready to
       * accept traffic.
       * </pre>
       *
       * <code>optional bool ready = 4 [json_name = "ready"];</code>
       * @return This builder for chaining.
       */
      public Builder clearReady() {
        bitField0_ = (bitField0_ & ~0x00000008);
        ready_ = false;
        onChanged();
        return this;
      }

      private int restartCount_ ;
      /**
       * <pre>
       * RestartCount holds the number of times the container has been restarted.
       * Kubelet makes an effort to always increment the value, but there
       * are cases when the state may be lost due to node restarts and then the value
       * may be reset to 0. The value is never negative.
       * </pre>
       *
       * <code>int32 restart_count = 5 [json_name = "restartCount"];</code>
       * @return The restartCount.
       */
      @java.lang.Override
      public int getRestartCount() {
        return restartCount_;
      }
      /**
       * <pre>
       * RestartCount holds the number of times the container has been restarted.
       * Kubelet makes an effort to always increment the value, but there
       * are cases when the state may be lost due to node restarts and then the value
       * may be reset to 0. The value is never negative.
       * </pre>
       *
       * <code>int32 restart_count = 5 [json_name = "restartCount"];</code>
       * @param value The restartCount to set.
       * @return This builder for chaining.
       */
      public Builder setRestartCount(int value) {

        restartCount_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * RestartCount holds the number of times the container has been restarted.
       * Kubelet makes an effort to always increment the value, but there
       * are cases when the state may be lost due to node restarts and then the value
       * may be reset to 0. The value is never negative.
       * </pre>
       *
       * <code>int32 restart_count = 5 [json_name = "restartCount"];</code>
       * @return This builder for chaining.
       */
      public Builder clearRestartCount() {
        bitField0_ = (bitField0_ & ~0x00000010);
        restartCount_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object image_ = "";
      /**
       * <pre>
       * Image is the name of container image that the container is running.
       * The container image may not match the image used in the PodSpec,
       * as it may have been resolved by the runtime.
       * More info: https://kubernetes.io/docs/concepts/containers/images.
       * </pre>
       *
       * <code>string image = 6 [json_name = "image"];</code>
       * @return The image.
       */
      public java.lang.String getImage() {
        java.lang.Object ref = image_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          image_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Image is the name of container image that the container is running.
       * The container image may not match the image used in the PodSpec,
       * as it may have been resolved by the runtime.
       * More info: https://kubernetes.io/docs/concepts/containers/images.
       * </pre>
       *
       * <code>string image = 6 [json_name = "image"];</code>
       * @return The bytes for image.
       */
      public com.google.protobuf.ByteString
          getImageBytes() {
        java.lang.Object ref = image_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          image_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Image is the name of container image that the container is running.
       * The container image may not match the image used in the PodSpec,
       * as it may have been resolved by the runtime.
       * More info: https://kubernetes.io/docs/concepts/containers/images.
       * </pre>
       *
       * <code>string image = 6 [json_name = "image"];</code>
       * @param value The image to set.
       * @return This builder for chaining.
       */
      public Builder setImage(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        image_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Image is the name of container image that the container is running.
       * The container image may not match the image used in the PodSpec,
       * as it may have been resolved by the runtime.
       * More info: https://kubernetes.io/docs/concepts/containers/images.
       * </pre>
       *
       * <code>string image = 6 [json_name = "image"];</code>
       * @return This builder for chaining.
       */
      public Builder clearImage() {
        image_ = getDefaultInstance().getImage();
        bitField0_ = (bitField0_ & ~0x00000020);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Image is the name of container image that the container is running.
       * The container image may not match the image used in the PodSpec,
       * as it may have been resolved by the runtime.
       * More info: https://kubernetes.io/docs/concepts/containers/images.
       * </pre>
       *
       * <code>string image = 6 [json_name = "image"];</code>
       * @param value The bytes for image to set.
       * @return This builder for chaining.
       */
      public Builder setImageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        image_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }

      private java.lang.Object imageId_ = "";
      /**
       * <pre>
       * ImageID is the image ID of the container's image. The image ID may not
       * match the image ID of the image used in the PodSpec, as it may have been
       * resolved by the runtime.
       * </pre>
       *
       * <code>string image_id = 7 [json_name = "imageId"];</code>
       * @return The imageId.
       */
      public java.lang.String getImageId() {
        java.lang.Object ref = imageId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          imageId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * ImageID is the image ID of the container's image. The image ID may not
       * match the image ID of the image used in the PodSpec, as it may have been
       * resolved by the runtime.
       * </pre>
       *
       * <code>string image_id = 7 [json_name = "imageId"];</code>
       * @return The bytes for imageId.
       */
      public com.google.protobuf.ByteString
          getImageIdBytes() {
        java.lang.Object ref = imageId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          imageId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * ImageID is the image ID of the container's image. The image ID may not
       * match the image ID of the image used in the PodSpec, as it may have been
       * resolved by the runtime.
       * </pre>
       *
       * <code>string image_id = 7 [json_name = "imageId"];</code>
       * @param value The imageId to set.
       * @return This builder for chaining.
       */
      public Builder setImageId(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        imageId_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ImageID is the image ID of the container's image. The image ID may not
       * match the image ID of the image used in the PodSpec, as it may have been
       * resolved by the runtime.
       * </pre>
       *
       * <code>string image_id = 7 [json_name = "imageId"];</code>
       * @return This builder for chaining.
       */
      public Builder clearImageId() {
        imageId_ = getDefaultInstance().getImageId();
        bitField0_ = (bitField0_ & ~0x00000040);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ImageID is the image ID of the container's image. The image ID may not
       * match the image ID of the image used in the PodSpec, as it may have been
       * resolved by the runtime.
       * </pre>
       *
       * <code>string image_id = 7 [json_name = "imageId"];</code>
       * @param value The bytes for imageId to set.
       * @return This builder for chaining.
       */
      public Builder setImageIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        imageId_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }

      private java.lang.Object containerId_ = "";
      /**
       * <pre>
       * ContainerID is the ID of the container in the format '&lt;type&gt;://&lt;container_id&gt;'.
       * Where type is a container runtime identifier, returned from Version call of CRI API
       * (for example "containerd").
       * +optional
       * </pre>
       *
       * <code>string container_id = 8 [json_name = "containerId"];</code>
       * @return The containerId.
       */
      public java.lang.String getContainerId() {
        java.lang.Object ref = containerId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          containerId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * ContainerID is the ID of the container in the format '&lt;type&gt;://&lt;container_id&gt;'.
       * Where type is a container runtime identifier, returned from Version call of CRI API
       * (for example "containerd").
       * +optional
       * </pre>
       *
       * <code>string container_id = 8 [json_name = "containerId"];</code>
       * @return The bytes for containerId.
       */
      public com.google.protobuf.ByteString
          getContainerIdBytes() {
        java.lang.Object ref = containerId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          containerId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * ContainerID is the ID of the container in the format '&lt;type&gt;://&lt;container_id&gt;'.
       * Where type is a container runtime identifier, returned from Version call of CRI API
       * (for example "containerd").
       * +optional
       * </pre>
       *
       * <code>string container_id = 8 [json_name = "containerId"];</code>
       * @param value The containerId to set.
       * @return This builder for chaining.
       */
      public Builder setContainerId(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        containerId_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ContainerID is the ID of the container in the format '&lt;type&gt;://&lt;container_id&gt;'.
       * Where type is a container runtime identifier, returned from Version call of CRI API
       * (for example "containerd").
       * +optional
       * </pre>
       *
       * <code>string container_id = 8 [json_name = "containerId"];</code>
       * @return This builder for chaining.
       */
      public Builder clearContainerId() {
        containerId_ = getDefaultInstance().getContainerId();
        bitField0_ = (bitField0_ & ~0x00000080);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ContainerID is the ID of the container in the format '&lt;type&gt;://&lt;container_id&gt;'.
       * Where type is a container runtime identifier, returned from Version call of CRI API
       * (for example "containerd").
       * +optional
       * </pre>
       *
       * <code>string container_id = 8 [json_name = "containerId"];</code>
       * @param value The bytes for containerId to set.
       * @return This builder for chaining.
       */
      public Builder setContainerIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        containerId_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }

      private boolean started_ ;
      /**
       * <pre>
       * Started indicates whether the container has finished its postStart lifecycle hook
       * and passed its startup probe.
       * Initialized as false, becomes true after startupProbe is considered
       * successful. Resets to false when the container is restarted, or if kubelet
       * loses state temporarily. In both cases, startup probes will run again.
       * Is always true when no startupProbe is defined and container is running and
       * has passed the postStart lifecycle hook.
       * </pre>
       *
       * <code>bool started = 9 [json_name = "started"];</code>
       * @return The started.
       */
      @java.lang.Override
      public boolean getStarted() {
        return started_;
      }
      /**
       * <pre>
       * Started indicates whether the container has finished its postStart lifecycle hook
       * and passed its startup probe.
       * Initialized as false, becomes true after startupProbe is considered
       * successful. Resets to false when the container is restarted, or if kubelet
       * loses state temporarily. In both cases, startup probes will run again.
       * Is always true when no startupProbe is defined and container is running and
       * has passed the postStart lifecycle hook.
       * </pre>
       *
       * <code>bool started = 9 [json_name = "started"];</code>
       * @param value The started to set.
       * @return This builder for chaining.
       */
      public Builder setStarted(boolean value) {

        started_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Started indicates whether the container has finished its postStart lifecycle hook
       * and passed its startup probe.
       * Initialized as false, becomes true after startupProbe is considered
       * successful. Resets to false when the container is restarted, or if kubelet
       * loses state temporarily. In both cases, startup probes will run again.
       * Is always true when no startupProbe is defined and container is running and
       * has passed the postStart lifecycle hook.
       * </pre>
       *
       * <code>bool started = 9 [json_name = "started"];</code>
       * @return This builder for chaining.
       */
      public Builder clearStarted() {
        bitField0_ = (bitField0_ & ~0x00000100);
        started_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chalk.pubsub.v1.PodStatusPubSub.ContainerStatus)
    }

    // @@protoc_insertion_point(class_scope:chalk.pubsub.v1.PodStatusPubSub.ContainerStatus)
    private static final ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus();
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ContainerStatus>
        PARSER = new com.google.protobuf.AbstractParser<ContainerStatus>() {
      @java.lang.Override
      public ContainerStatus parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ContainerStatus> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ContainerStatus> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface QuantityOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chalk.pubsub.v1.PodStatusPubSub.Quantity)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional string string = 1 [json_name = "string"];</code>
     * @return Whether the string field is set.
     */
    boolean hasString();
    /**
     * <code>optional string string = 1 [json_name = "string"];</code>
     * @return The string.
     */
    java.lang.String getString();
    /**
     * <code>optional string string = 1 [json_name = "string"];</code>
     * @return The bytes for string.
     */
    com.google.protobuf.ByteString
        getStringBytes();
  }
  /**
   * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.Quantity}
   */
  public static final class Quantity extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chalk.pubsub.v1.PodStatusPubSub.Quantity)
      QuantityOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Quantity.newBuilder() to construct.
    private Quantity(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Quantity() {
      string_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Quantity();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_Quantity_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_Quantity_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity.Builder.class);
    }

    private int bitField0_;
    public static final int STRING_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object string_ = "";
    /**
     * <code>optional string string = 1 [json_name = "string"];</code>
     * @return Whether the string field is set.
     */
    @java.lang.Override
    public boolean hasString() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional string string = 1 [json_name = "string"];</code>
     * @return The string.
     */
    @java.lang.Override
    public java.lang.String getString() {
      java.lang.Object ref = string_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        string_ = s;
        return s;
      }
    }
    /**
     * <code>optional string string = 1 [json_name = "string"];</code>
     * @return The bytes for string.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStringBytes() {
      java.lang.Object ref = string_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        string_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, string_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, string_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity)) {
        return super.equals(obj);
      }
      ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity other = (ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity) obj;

      if (hasString() != other.hasString()) return false;
      if (hasString()) {
        if (!getString()
            .equals(other.getString())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasString()) {
        hash = (37 * hash) + STRING_FIELD_NUMBER;
        hash = (53 * hash) + getString().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.Quantity}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chalk.pubsub.v1.PodStatusPubSub.Quantity)
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.QuantityOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_Quantity_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_Quantity_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity.Builder.class);
      }

      // Construct using ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        string_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_Quantity_descriptor;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity getDefaultInstanceForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity.getDefaultInstance();
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity build() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity buildPartial() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity result = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.string_ = string_;
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity) {
          return mergeFrom((ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity other) {
        if (other == ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity.getDefaultInstance()) return this;
        if (other.hasString()) {
          string_ = other.string_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                string_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object string_ = "";
      /**
       * <code>optional string string = 1 [json_name = "string"];</code>
       * @return Whether the string field is set.
       */
      public boolean hasString() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional string string = 1 [json_name = "string"];</code>
       * @return The string.
       */
      public java.lang.String getString() {
        java.lang.Object ref = string_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          string_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string string = 1 [json_name = "string"];</code>
       * @return The bytes for string.
       */
      public com.google.protobuf.ByteString
          getStringBytes() {
        java.lang.Object ref = string_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          string_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string string = 1 [json_name = "string"];</code>
       * @param value The string to set.
       * @return This builder for chaining.
       */
      public Builder setString(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        string_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>optional string string = 1 [json_name = "string"];</code>
       * @return This builder for chaining.
       */
      public Builder clearString() {
        string_ = getDefaultInstance().getString();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <code>optional string string = 1 [json_name = "string"];</code>
       * @param value The bytes for string to set.
       * @return This builder for chaining.
       */
      public Builder setStringBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        string_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chalk.pubsub.v1.PodStatusPubSub.Quantity)
    }

    // @@protoc_insertion_point(class_scope:chalk.pubsub.v1.PodStatusPubSub.Quantity)
    private static final ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity();
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Quantity>
        PARSER = new com.google.protobuf.AbstractParser<Quantity>() {
      @java.lang.Override
      public Quantity parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Quantity> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Quantity> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ResourceRequirementsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Limits describes the maximum amount of compute resources allowed.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     * +optional
     * </pre>
     *
     * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; limits = 1 [json_name = "limits"];</code>
     */
    int getLimitsCount();
    /**
     * <pre>
     * Limits describes the maximum amount of compute resources allowed.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     * +optional
     * </pre>
     *
     * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; limits = 1 [json_name = "limits"];</code>
     */
    boolean containsLimits(
        java.lang.String key);
    /**
     * Use {@link #getLimitsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity>
    getLimits();
    /**
     * <pre>
     * Limits describes the maximum amount of compute resources allowed.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     * +optional
     * </pre>
     *
     * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; limits = 1 [json_name = "limits"];</code>
     */
    java.util.Map<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity>
    getLimitsMap();
    /**
     * <pre>
     * Limits describes the maximum amount of compute resources allowed.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     * +optional
     * </pre>
     *
     * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; limits = 1 [json_name = "limits"];</code>
     */
    /* nullable */
ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity getLimitsOrDefault(
        java.lang.String key,
        /* nullable */
ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity defaultValue);
    /**
     * <pre>
     * Limits describes the maximum amount of compute resources allowed.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     * +optional
     * </pre>
     *
     * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; limits = 1 [json_name = "limits"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity getLimitsOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * Requests describes the minimum amount of compute resources required.
     * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
     * otherwise to an implementation-defined value. Requests cannot exceed Limits.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     * +optional
     * </pre>
     *
     * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; requests = 2 [json_name = "requests"];</code>
     */
    int getRequestsCount();
    /**
     * <pre>
     * Requests describes the minimum amount of compute resources required.
     * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
     * otherwise to an implementation-defined value. Requests cannot exceed Limits.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     * +optional
     * </pre>
     *
     * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; requests = 2 [json_name = "requests"];</code>
     */
    boolean containsRequests(
        java.lang.String key);
    /**
     * Use {@link #getRequestsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity>
    getRequests();
    /**
     * <pre>
     * Requests describes the minimum amount of compute resources required.
     * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
     * otherwise to an implementation-defined value. Requests cannot exceed Limits.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     * +optional
     * </pre>
     *
     * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; requests = 2 [json_name = "requests"];</code>
     */
    java.util.Map<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity>
    getRequestsMap();
    /**
     * <pre>
     * Requests describes the minimum amount of compute resources required.
     * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
     * otherwise to an implementation-defined value. Requests cannot exceed Limits.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     * +optional
     * </pre>
     *
     * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; requests = 2 [json_name = "requests"];</code>
     */
    /* nullable */
ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity getRequestsOrDefault(
        java.lang.String key,
        /* nullable */
ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity defaultValue);
    /**
     * <pre>
     * Requests describes the minimum amount of compute resources required.
     * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
     * otherwise to an implementation-defined value. Requests cannot exceed Limits.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     * +optional
     * </pre>
     *
     * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; requests = 2 [json_name = "requests"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity getRequestsOrThrow(
        java.lang.String key);
  }
  /**
   * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements}
   */
  public static final class ResourceRequirements extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements)
      ResourceRequirementsOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ResourceRequirements.newBuilder() to construct.
    private ResourceRequirements(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ResourceRequirements() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ResourceRequirements();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ResourceRequirements_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
        int number) {
      switch (number) {
        case 1:
          return internalGetLimits();
        case 2:
          return internalGetRequests();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ResourceRequirements_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements.Builder.class);
    }

    public static final int LIMITS_FIELD_NUMBER = 1;
    private static final class LimitsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity>newDefaultInstance(
                  ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ResourceRequirements_LimitsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity.getDefaultInstance());
    }
    @SuppressWarnings("serial")
    private com.google.protobuf.MapField<
        java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity> limits_;
    private com.google.protobuf.MapField<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity>
    internalGetLimits() {
      if (limits_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            LimitsDefaultEntryHolder.defaultEntry);
      }
      return limits_;
    }
    public int getLimitsCount() {
      return internalGetLimits().getMap().size();
    }
    /**
     * <pre>
     * Limits describes the maximum amount of compute resources allowed.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     * +optional
     * </pre>
     *
     * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; limits = 1 [json_name = "limits"];</code>
     */
    @java.lang.Override
    public boolean containsLimits(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      return internalGetLimits().getMap().containsKey(key);
    }
    /**
     * Use {@link #getLimitsMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity> getLimits() {
      return getLimitsMap();
    }
    /**
     * <pre>
     * Limits describes the maximum amount of compute resources allowed.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     * +optional
     * </pre>
     *
     * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; limits = 1 [json_name = "limits"];</code>
     */
    @java.lang.Override
    public java.util.Map<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity> getLimitsMap() {
      return internalGetLimits().getMap();
    }
    /**
     * <pre>
     * Limits describes the maximum amount of compute resources allowed.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     * +optional
     * </pre>
     *
     * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; limits = 1 [json_name = "limits"];</code>
     */
    @java.lang.Override
    public /* nullable */
ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity getLimitsOrDefault(
        java.lang.String key,
        /* nullable */
ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity defaultValue) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity> map =
          internalGetLimits().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Limits describes the maximum amount of compute resources allowed.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     * +optional
     * </pre>
     *
     * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; limits = 1 [json_name = "limits"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity getLimitsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity> map =
          internalGetLimits().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int REQUESTS_FIELD_NUMBER = 2;
    private static final class RequestsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity>newDefaultInstance(
                  ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ResourceRequirements_RequestsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity.getDefaultInstance());
    }
    @SuppressWarnings("serial")
    private com.google.protobuf.MapField<
        java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity> requests_;
    private com.google.protobuf.MapField<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity>
    internalGetRequests() {
      if (requests_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            RequestsDefaultEntryHolder.defaultEntry);
      }
      return requests_;
    }
    public int getRequestsCount() {
      return internalGetRequests().getMap().size();
    }
    /**
     * <pre>
     * Requests describes the minimum amount of compute resources required.
     * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
     * otherwise to an implementation-defined value. Requests cannot exceed Limits.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     * +optional
     * </pre>
     *
     * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; requests = 2 [json_name = "requests"];</code>
     */
    @java.lang.Override
    public boolean containsRequests(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      return internalGetRequests().getMap().containsKey(key);
    }
    /**
     * Use {@link #getRequestsMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity> getRequests() {
      return getRequestsMap();
    }
    /**
     * <pre>
     * Requests describes the minimum amount of compute resources required.
     * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
     * otherwise to an implementation-defined value. Requests cannot exceed Limits.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     * +optional
     * </pre>
     *
     * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; requests = 2 [json_name = "requests"];</code>
     */
    @java.lang.Override
    public java.util.Map<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity> getRequestsMap() {
      return internalGetRequests().getMap();
    }
    /**
     * <pre>
     * Requests describes the minimum amount of compute resources required.
     * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
     * otherwise to an implementation-defined value. Requests cannot exceed Limits.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     * +optional
     * </pre>
     *
     * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; requests = 2 [json_name = "requests"];</code>
     */
    @java.lang.Override
    public /* nullable */
ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity getRequestsOrDefault(
        java.lang.String key,
        /* nullable */
ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity defaultValue) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity> map =
          internalGetRequests().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Requests describes the minimum amount of compute resources required.
     * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
     * otherwise to an implementation-defined value. Requests cannot exceed Limits.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     * +optional
     * </pre>
     *
     * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; requests = 2 [json_name = "requests"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity getRequestsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity> map =
          internalGetRequests().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetLimits(),
          LimitsDefaultEntryHolder.defaultEntry,
          1);
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetRequests(),
          RequestsDefaultEntryHolder.defaultEntry,
          2);
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (java.util.Map.Entry<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity> entry
           : internalGetLimits().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity>
        limits__ = LimitsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(1, limits__);
      }
      for (java.util.Map.Entry<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity> entry
           : internalGetRequests().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity>
        requests__ = RequestsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, requests__);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements)) {
        return super.equals(obj);
      }
      ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements other = (ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements) obj;

      if (!internalGetLimits().equals(
          other.internalGetLimits())) return false;
      if (!internalGetRequests().equals(
          other.internalGetRequests())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (!internalGetLimits().getMap().isEmpty()) {
        hash = (37 * hash) + LIMITS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetLimits().hashCode();
      }
      if (!internalGetRequests().getMap().isEmpty()) {
        hash = (37 * hash) + REQUESTS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetRequests().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements)
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirementsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ResourceRequirements_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
          int number) {
        switch (number) {
          case 1:
            return internalGetLimits();
          case 2:
            return internalGetRequests();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMutableMapFieldReflection(
          int number) {
        switch (number) {
          case 1:
            return internalGetMutableLimits();
          case 2:
            return internalGetMutableRequests();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ResourceRequirements_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements.Builder.class);
      }

      // Construct using ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        internalGetMutableLimits().clear();
        internalGetMutableRequests().clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_ResourceRequirements_descriptor;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements getDefaultInstanceForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements.getDefaultInstance();
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements build() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements buildPartial() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements result = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.limits_ = internalGetLimits().build(LimitsDefaultEntryHolder.defaultEntry);
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.requests_ = internalGetRequests().build(RequestsDefaultEntryHolder.defaultEntry);
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements) {
          return mergeFrom((ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements other) {
        if (other == ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements.getDefaultInstance()) return this;
        internalGetMutableLimits().mergeFrom(
            other.internalGetLimits());
        bitField0_ |= 0x00000001;
        internalGetMutableRequests().mergeFrom(
            other.internalGetRequests());
        bitField0_ |= 0x00000002;
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                com.google.protobuf.MapEntry<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity>
                limits__ = input.readMessage(
                    LimitsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
                internalGetMutableLimits().ensureBuilderMap().put(
                    limits__.getKey(), limits__.getValue());
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                com.google.protobuf.MapEntry<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity>
                requests__ = input.readMessage(
                    RequestsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
                internalGetMutableRequests().ensureBuilderMap().put(
                    requests__.getKey(), requests__.getValue());
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private static final class LimitsConverter implements com.google.protobuf.MapFieldBuilder.Converter<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.QuantityOrBuilder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity> {
        @java.lang.Override
        public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity build(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.QuantityOrBuilder val) {
          if (val instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity) { return (ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity) val; }
          return ((ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity.Builder) val).build();
        }

        @java.lang.Override
        public com.google.protobuf.MapEntry<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity> defaultEntry() {
          return LimitsDefaultEntryHolder.defaultEntry;
        }
      };
      private static final LimitsConverter limitsConverter = new LimitsConverter();

      private com.google.protobuf.MapFieldBuilder<
          java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.QuantityOrBuilder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity.Builder> limits_;
      private com.google.protobuf.MapFieldBuilder<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.QuantityOrBuilder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity.Builder>
          internalGetLimits() {
        if (limits_ == null) {
          return new com.google.protobuf.MapFieldBuilder<>(limitsConverter);
        }
        return limits_;
      }
      private com.google.protobuf.MapFieldBuilder<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.QuantityOrBuilder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity.Builder>
          internalGetMutableLimits() {
        if (limits_ == null) {
          limits_ = new com.google.protobuf.MapFieldBuilder<>(limitsConverter);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return limits_;
      }
      public int getLimitsCount() {
        return internalGetLimits().ensureBuilderMap().size();
      }
      /**
       * <pre>
       * Limits describes the maximum amount of compute resources allowed.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       * +optional
       * </pre>
       *
       * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; limits = 1 [json_name = "limits"];</code>
       */
      @java.lang.Override
      public boolean containsLimits(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        return internalGetLimits().ensureBuilderMap().containsKey(key);
      }
      /**
       * Use {@link #getLimitsMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity> getLimits() {
        return getLimitsMap();
      }
      /**
       * <pre>
       * Limits describes the maximum amount of compute resources allowed.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       * +optional
       * </pre>
       *
       * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; limits = 1 [json_name = "limits"];</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity> getLimitsMap() {
        return internalGetLimits().getImmutableMap();
      }
      /**
       * <pre>
       * Limits describes the maximum amount of compute resources allowed.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       * +optional
       * </pre>
       *
       * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; limits = 1 [json_name = "limits"];</code>
       */
      @java.lang.Override
      public /* nullable */
ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity getLimitsOrDefault(
          java.lang.String key,
          /* nullable */
ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity defaultValue) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.QuantityOrBuilder> map = internalGetMutableLimits().ensureBuilderMap();
        return map.containsKey(key) ? limitsConverter.build(map.get(key)) : defaultValue;
      }
      /**
       * <pre>
       * Limits describes the maximum amount of compute resources allowed.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       * +optional
       * </pre>
       *
       * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; limits = 1 [json_name = "limits"];</code>
       */
      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity getLimitsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.QuantityOrBuilder> map = internalGetMutableLimits().ensureBuilderMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return limitsConverter.build(map.get(key));
      }
      public Builder clearLimits() {
        bitField0_ = (bitField0_ & ~0x00000001);
        internalGetMutableLimits().clear();
        return this;
      }
      /**
       * <pre>
       * Limits describes the maximum amount of compute resources allowed.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       * +optional
       * </pre>
       *
       * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; limits = 1 [json_name = "limits"];</code>
       */
      public Builder removeLimits(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        internalGetMutableLimits().ensureBuilderMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity>
          getMutableLimits() {
        bitField0_ |= 0x00000001;
        return internalGetMutableLimits().ensureMessageMap();
      }
      /**
       * <pre>
       * Limits describes the maximum amount of compute resources allowed.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       * +optional
       * </pre>
       *
       * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; limits = 1 [json_name = "limits"];</code>
       */
      public Builder putLimits(
          java.lang.String key,
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity value) {
        if (key == null) { throw new NullPointerException("map key"); }
        if (value == null) { throw new NullPointerException("map value"); }
        internalGetMutableLimits().ensureBuilderMap()
            .put(key, value);
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Limits describes the maximum amount of compute resources allowed.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       * +optional
       * </pre>
       *
       * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; limits = 1 [json_name = "limits"];</code>
       */
      public Builder putAllLimits(
          java.util.Map<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity> values) {
        for (java.util.Map.Entry<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity> e : values.entrySet()) {
          if (e.getKey() == null || e.getValue() == null) {
            throw new NullPointerException();
          }
        }
        internalGetMutableLimits().ensureBuilderMap()
            .putAll(values);
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Limits describes the maximum amount of compute resources allowed.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       * +optional
       * </pre>
       *
       * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; limits = 1 [json_name = "limits"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity.Builder putLimitsBuilderIfAbsent(
          java.lang.String key) {
        java.util.Map<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.QuantityOrBuilder> builderMap = internalGetMutableLimits().ensureBuilderMap();
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.QuantityOrBuilder entry = builderMap.get(key);
        if (entry == null) {
          entry = ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity.newBuilder();
          builderMap.put(key, entry);
        }
        if (entry instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity) {
          entry = ((ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity) entry).toBuilder();
          builderMap.put(key, entry);
        }
        return (ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity.Builder) entry;
      }

      private static final class RequestsConverter implements com.google.protobuf.MapFieldBuilder.Converter<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.QuantityOrBuilder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity> {
        @java.lang.Override
        public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity build(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.QuantityOrBuilder val) {
          if (val instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity) { return (ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity) val; }
          return ((ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity.Builder) val).build();
        }

        @java.lang.Override
        public com.google.protobuf.MapEntry<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity> defaultEntry() {
          return RequestsDefaultEntryHolder.defaultEntry;
        }
      };
      private static final RequestsConverter requestsConverter = new RequestsConverter();

      private com.google.protobuf.MapFieldBuilder<
          java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.QuantityOrBuilder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity.Builder> requests_;
      private com.google.protobuf.MapFieldBuilder<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.QuantityOrBuilder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity.Builder>
          internalGetRequests() {
        if (requests_ == null) {
          return new com.google.protobuf.MapFieldBuilder<>(requestsConverter);
        }
        return requests_;
      }
      private com.google.protobuf.MapFieldBuilder<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.QuantityOrBuilder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity.Builder>
          internalGetMutableRequests() {
        if (requests_ == null) {
          requests_ = new com.google.protobuf.MapFieldBuilder<>(requestsConverter);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return requests_;
      }
      public int getRequestsCount() {
        return internalGetRequests().ensureBuilderMap().size();
      }
      /**
       * <pre>
       * Requests describes the minimum amount of compute resources required.
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value. Requests cannot exceed Limits.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       * +optional
       * </pre>
       *
       * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; requests = 2 [json_name = "requests"];</code>
       */
      @java.lang.Override
      public boolean containsRequests(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        return internalGetRequests().ensureBuilderMap().containsKey(key);
      }
      /**
       * Use {@link #getRequestsMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity> getRequests() {
        return getRequestsMap();
      }
      /**
       * <pre>
       * Requests describes the minimum amount of compute resources required.
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value. Requests cannot exceed Limits.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       * +optional
       * </pre>
       *
       * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; requests = 2 [json_name = "requests"];</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity> getRequestsMap() {
        return internalGetRequests().getImmutableMap();
      }
      /**
       * <pre>
       * Requests describes the minimum amount of compute resources required.
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value. Requests cannot exceed Limits.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       * +optional
       * </pre>
       *
       * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; requests = 2 [json_name = "requests"];</code>
       */
      @java.lang.Override
      public /* nullable */
ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity getRequestsOrDefault(
          java.lang.String key,
          /* nullable */
ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity defaultValue) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.QuantityOrBuilder> map = internalGetMutableRequests().ensureBuilderMap();
        return map.containsKey(key) ? requestsConverter.build(map.get(key)) : defaultValue;
      }
      /**
       * <pre>
       * Requests describes the minimum amount of compute resources required.
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value. Requests cannot exceed Limits.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       * +optional
       * </pre>
       *
       * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; requests = 2 [json_name = "requests"];</code>
       */
      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity getRequestsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.QuantityOrBuilder> map = internalGetMutableRequests().ensureBuilderMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return requestsConverter.build(map.get(key));
      }
      public Builder clearRequests() {
        bitField0_ = (bitField0_ & ~0x00000002);
        internalGetMutableRequests().clear();
        return this;
      }
      /**
       * <pre>
       * Requests describes the minimum amount of compute resources required.
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value. Requests cannot exceed Limits.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       * +optional
       * </pre>
       *
       * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; requests = 2 [json_name = "requests"];</code>
       */
      public Builder removeRequests(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        internalGetMutableRequests().ensureBuilderMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity>
          getMutableRequests() {
        bitField0_ |= 0x00000002;
        return internalGetMutableRequests().ensureMessageMap();
      }
      /**
       * <pre>
       * Requests describes the minimum amount of compute resources required.
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value. Requests cannot exceed Limits.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       * +optional
       * </pre>
       *
       * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; requests = 2 [json_name = "requests"];</code>
       */
      public Builder putRequests(
          java.lang.String key,
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity value) {
        if (key == null) { throw new NullPointerException("map key"); }
        if (value == null) { throw new NullPointerException("map value"); }
        internalGetMutableRequests().ensureBuilderMap()
            .put(key, value);
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Requests describes the minimum amount of compute resources required.
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value. Requests cannot exceed Limits.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       * +optional
       * </pre>
       *
       * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; requests = 2 [json_name = "requests"];</code>
       */
      public Builder putAllRequests(
          java.util.Map<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity> values) {
        for (java.util.Map.Entry<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity> e : values.entrySet()) {
          if (e.getKey() == null || e.getValue() == null) {
            throw new NullPointerException();
          }
        }
        internalGetMutableRequests().ensureBuilderMap()
            .putAll(values);
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Requests describes the minimum amount of compute resources required.
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value. Requests cannot exceed Limits.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       * +optional
       * </pre>
       *
       * <code>map&lt;string, .chalk.pubsub.v1.PodStatusPubSub.Quantity&gt; requests = 2 [json_name = "requests"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity.Builder putRequestsBuilderIfAbsent(
          java.lang.String key) {
        java.util.Map<java.lang.String, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.QuantityOrBuilder> builderMap = internalGetMutableRequests().ensureBuilderMap();
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.QuantityOrBuilder entry = builderMap.get(key);
        if (entry == null) {
          entry = ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity.newBuilder();
          builderMap.put(key, entry);
        }
        if (entry instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity) {
          entry = ((ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity) entry).toBuilder();
          builderMap.put(key, entry);
        }
        return (ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Quantity.Builder) entry;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements)
    }

    // @@protoc_insertion_point(class_scope:chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements)
    private static final ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements();
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ResourceRequirements>
        PARSER = new com.google.protobuf.AbstractParser<ResourceRequirements>() {
      @java.lang.Override
      public ResourceRequirements parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ResourceRequirements> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ResourceRequirements> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ResourceRequirements getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PodConditionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chalk.pubsub.v1.PodStatusPubSub.PodCondition)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Type is the type of the condition.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
     * </pre>
     *
     * <code>string type = 1 [json_name = "type"];</code>
     * @return The type.
     */
    java.lang.String getType();
    /**
     * <pre>
     * Type is the type of the condition.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
     * </pre>
     *
     * <code>string type = 1 [json_name = "type"];</code>
     * @return The bytes for type.
     */
    com.google.protobuf.ByteString
        getTypeBytes();

    /**
     * <pre>
     * Status is the status of the condition.
     * Can be True, False, Unknown.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
     * </pre>
     *
     * <code>string status = 2 [json_name = "status"];</code>
     * @return The status.
     */
    java.lang.String getStatus();
    /**
     * <pre>
     * Status is the status of the condition.
     * Can be True, False, Unknown.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
     * </pre>
     *
     * <code>string status = 2 [json_name = "status"];</code>
     * @return The bytes for status.
     */
    com.google.protobuf.ByteString
        getStatusBytes();

    /**
     * <pre>
     * Last time we probed the condition.
     * +optional
     * </pre>
     *
     * <code>int64 last_probe_time = 3 [json_name = "lastProbeTime", (.gen_bq_schema.bigquery) = { ... }</code>
     * @return The lastProbeTime.
     */
    long getLastProbeTime();

    /**
     * <pre>
     * Last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>int64 last_transition_time = 4 [json_name = "lastTransitionTime", (.gen_bq_schema.bigquery) = { ... }</code>
     * @return The lastTransitionTime.
     */
    long getLastTransitionTime();

    /**
     * <pre>
     * Unique, one-word, CamelCase reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 5 [json_name = "reason"];</code>
     * @return Whether the reason field is set.
     */
    boolean hasReason();
    /**
     * <pre>
     * Unique, one-word, CamelCase reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 5 [json_name = "reason"];</code>
     * @return The reason.
     */
    java.lang.String getReason();
    /**
     * <pre>
     * Unique, one-word, CamelCase reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 5 [json_name = "reason"];</code>
     * @return The bytes for reason.
     */
    com.google.protobuf.ByteString
        getReasonBytes();

    /**
     * <pre>
     * Human-readable message indicating details about last transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 6 [json_name = "message"];</code>
     * @return Whether the message field is set.
     */
    boolean hasMessage();
    /**
     * <pre>
     * Human-readable message indicating details about last transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 6 [json_name = "message"];</code>
     * @return The message.
     */
    java.lang.String getMessage();
    /**
     * <pre>
     * Human-readable message indicating details about last transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 6 [json_name = "message"];</code>
     * @return The bytes for message.
     */
    com.google.protobuf.ByteString
        getMessageBytes();
  }
  /**
   * <pre>
   * PodCondition contains details for the current condition of this pod.
   * </pre>
   *
   * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.PodCondition}
   */
  public static final class PodCondition extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chalk.pubsub.v1.PodStatusPubSub.PodCondition)
      PodConditionOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use PodCondition.newBuilder() to construct.
    private PodCondition(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private PodCondition() {
      type_ = "";
      status_ = "";
      reason_ = "";
      message_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new PodCondition();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_PodCondition_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_PodCondition_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition.Builder.class);
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object type_ = "";
    /**
     * <pre>
     * Type is the type of the condition.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
     * </pre>
     *
     * <code>string type = 1 [json_name = "type"];</code>
     * @return The type.
     */
    @java.lang.Override
    public java.lang.String getType() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        type_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Type is the type of the condition.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
     * </pre>
     *
     * <code>string type = 1 [json_name = "type"];</code>
     * @return The bytes for type.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTypeBytes() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STATUS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object status_ = "";
    /**
     * <pre>
     * Status is the status of the condition.
     * Can be True, False, Unknown.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
     * </pre>
     *
     * <code>string status = 2 [json_name = "status"];</code>
     * @return The status.
     */
    @java.lang.Override
    public java.lang.String getStatus() {
      java.lang.Object ref = status_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        status_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Status is the status of the condition.
     * Can be True, False, Unknown.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
     * </pre>
     *
     * <code>string status = 2 [json_name = "status"];</code>
     * @return The bytes for status.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStatusBytes() {
      java.lang.Object ref = status_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        status_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int LAST_PROBE_TIME_FIELD_NUMBER = 3;
    private long lastProbeTime_ = 0L;
    /**
     * <pre>
     * Last time we probed the condition.
     * +optional
     * </pre>
     *
     * <code>int64 last_probe_time = 3 [json_name = "lastProbeTime", (.gen_bq_schema.bigquery) = { ... }</code>
     * @return The lastProbeTime.
     */
    @java.lang.Override
    public long getLastProbeTime() {
      return lastProbeTime_;
    }

    public static final int LAST_TRANSITION_TIME_FIELD_NUMBER = 4;
    private long lastTransitionTime_ = 0L;
    /**
     * <pre>
     * Last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>int64 last_transition_time = 4 [json_name = "lastTransitionTime", (.gen_bq_schema.bigquery) = { ... }</code>
     * @return The lastTransitionTime.
     */
    @java.lang.Override
    public long getLastTransitionTime() {
      return lastTransitionTime_;
    }

    public static final int REASON_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private volatile java.lang.Object reason_ = "";
    /**
     * <pre>
     * Unique, one-word, CamelCase reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 5 [json_name = "reason"];</code>
     * @return Whether the reason field is set.
     */
    @java.lang.Override
    public boolean hasReason() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Unique, one-word, CamelCase reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 5 [json_name = "reason"];</code>
     * @return The reason.
     */
    @java.lang.Override
    public java.lang.String getReason() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        reason_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Unique, one-word, CamelCase reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 5 [json_name = "reason"];</code>
     * @return The bytes for reason.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getReasonBytes() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        reason_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MESSAGE_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private volatile java.lang.Object message_ = "";
    /**
     * <pre>
     * Human-readable message indicating details about last transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 6 [json_name = "message"];</code>
     * @return Whether the message field is set.
     */
    @java.lang.Override
    public boolean hasMessage() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Human-readable message indicating details about last transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 6 [json_name = "message"];</code>
     * @return The message.
     */
    @java.lang.Override
    public java.lang.String getMessage() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        message_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Human-readable message indicating details about last transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 6 [json_name = "message"];</code>
     * @return The bytes for message.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getMessageBytes() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        message_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(type_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, type_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(status_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, status_);
      }
      if (lastProbeTime_ != 0L) {
        output.writeInt64(3, lastProbeTime_);
      }
      if (lastTransitionTime_ != 0L) {
        output.writeInt64(4, lastTransitionTime_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, reason_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 6, message_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(type_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, type_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(status_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, status_);
      }
      if (lastProbeTime_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(3, lastProbeTime_);
      }
      if (lastTransitionTime_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(4, lastTransitionTime_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, reason_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, message_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition)) {
        return super.equals(obj);
      }
      ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition other = (ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition) obj;

      if (!getType()
          .equals(other.getType())) return false;
      if (!getStatus()
          .equals(other.getStatus())) return false;
      if (getLastProbeTime()
          != other.getLastProbeTime()) return false;
      if (getLastTransitionTime()
          != other.getLastTransitionTime()) return false;
      if (hasReason() != other.hasReason()) return false;
      if (hasReason()) {
        if (!getReason()
            .equals(other.getReason())) return false;
      }
      if (hasMessage() != other.hasMessage()) return false;
      if (hasMessage()) {
        if (!getMessage()
            .equals(other.getMessage())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + TYPE_FIELD_NUMBER;
      hash = (53 * hash) + getType().hashCode();
      hash = (37 * hash) + STATUS_FIELD_NUMBER;
      hash = (53 * hash) + getStatus().hashCode();
      hash = (37 * hash) + LAST_PROBE_TIME_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getLastProbeTime());
      hash = (37 * hash) + LAST_TRANSITION_TIME_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getLastTransitionTime());
      if (hasReason()) {
        hash = (37 * hash) + REASON_FIELD_NUMBER;
        hash = (53 * hash) + getReason().hashCode();
      }
      if (hasMessage()) {
        hash = (37 * hash) + MESSAGE_FIELD_NUMBER;
        hash = (53 * hash) + getMessage().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * PodCondition contains details for the current condition of this pod.
     * </pre>
     *
     * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.PodCondition}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chalk.pubsub.v1.PodStatusPubSub.PodCondition)
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodConditionOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_PodCondition_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_PodCondition_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition.Builder.class);
      }

      // Construct using ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        type_ = "";
        status_ = "";
        lastProbeTime_ = 0L;
        lastTransitionTime_ = 0L;
        reason_ = "";
        message_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_PodCondition_descriptor;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition getDefaultInstanceForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition.getDefaultInstance();
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition build() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition buildPartial() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition result = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.type_ = type_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.status_ = status_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.lastProbeTime_ = lastProbeTime_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.lastTransitionTime_ = lastTransitionTime_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.reason_ = reason_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.message_ = message_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition) {
          return mergeFrom((ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition other) {
        if (other == ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition.getDefaultInstance()) return this;
        if (!other.getType().isEmpty()) {
          type_ = other.type_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (!other.getStatus().isEmpty()) {
          status_ = other.status_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.getLastProbeTime() != 0L) {
          setLastProbeTime(other.getLastProbeTime());
        }
        if (other.getLastTransitionTime() != 0L) {
          setLastTransitionTime(other.getLastTransitionTime());
        }
        if (other.hasReason()) {
          reason_ = other.reason_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        if (other.hasMessage()) {
          message_ = other.message_;
          bitField0_ |= 0x00000020;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                type_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                status_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 24: {
                lastProbeTime_ = input.readInt64();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 32: {
                lastTransitionTime_ = input.readInt64();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              case 42: {
                reason_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000010;
                break;
              } // case 42
              case 50: {
                message_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000020;
                break;
              } // case 50
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object type_ = "";
      /**
       * <pre>
       * Type is the type of the condition.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * </pre>
       *
       * <code>string type = 1 [json_name = "type"];</code>
       * @return The type.
       */
      public java.lang.String getType() {
        java.lang.Object ref = type_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          type_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Type is the type of the condition.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * </pre>
       *
       * <code>string type = 1 [json_name = "type"];</code>
       * @return The bytes for type.
       */
      public com.google.protobuf.ByteString
          getTypeBytes() {
        java.lang.Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Type is the type of the condition.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * </pre>
       *
       * <code>string type = 1 [json_name = "type"];</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        type_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type is the type of the condition.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * </pre>
       *
       * <code>string type = 1 [json_name = "type"];</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        type_ = getDefaultInstance().getType();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type is the type of the condition.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * </pre>
       *
       * <code>string type = 1 [json_name = "type"];</code>
       * @param value The bytes for type to set.
       * @return This builder for chaining.
       */
      public Builder setTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        type_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object status_ = "";
      /**
       * <pre>
       * Status is the status of the condition.
       * Can be True, False, Unknown.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * </pre>
       *
       * <code>string status = 2 [json_name = "status"];</code>
       * @return The status.
       */
      public java.lang.String getStatus() {
        java.lang.Object ref = status_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          status_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Status is the status of the condition.
       * Can be True, False, Unknown.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * </pre>
       *
       * <code>string status = 2 [json_name = "status"];</code>
       * @return The bytes for status.
       */
      public com.google.protobuf.ByteString
          getStatusBytes() {
        java.lang.Object ref = status_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          status_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Status is the status of the condition.
       * Can be True, False, Unknown.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * </pre>
       *
       * <code>string status = 2 [json_name = "status"];</code>
       * @param value The status to set.
       * @return This builder for chaining.
       */
      public Builder setStatus(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        status_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Status is the status of the condition.
       * Can be True, False, Unknown.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * </pre>
       *
       * <code>string status = 2 [json_name = "status"];</code>
       * @return This builder for chaining.
       */
      public Builder clearStatus() {
        status_ = getDefaultInstance().getStatus();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Status is the status of the condition.
       * Can be True, False, Unknown.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * </pre>
       *
       * <code>string status = 2 [json_name = "status"];</code>
       * @param value The bytes for status to set.
       * @return This builder for chaining.
       */
      public Builder setStatusBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        status_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private long lastProbeTime_ ;
      /**
       * <pre>
       * Last time we probed the condition.
       * +optional
       * </pre>
       *
       * <code>int64 last_probe_time = 3 [json_name = "lastProbeTime", (.gen_bq_schema.bigquery) = { ... }</code>
       * @return The lastProbeTime.
       */
      @java.lang.Override
      public long getLastProbeTime() {
        return lastProbeTime_;
      }
      /**
       * <pre>
       * Last time we probed the condition.
       * +optional
       * </pre>
       *
       * <code>int64 last_probe_time = 3 [json_name = "lastProbeTime", (.gen_bq_schema.bigquery) = { ... }</code>
       * @param value The lastProbeTime to set.
       * @return This builder for chaining.
       */
      public Builder setLastProbeTime(long value) {

        lastProbeTime_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Last time we probed the condition.
       * +optional
       * </pre>
       *
       * <code>int64 last_probe_time = 3 [json_name = "lastProbeTime", (.gen_bq_schema.bigquery) = { ... }</code>
       * @return This builder for chaining.
       */
      public Builder clearLastProbeTime() {
        bitField0_ = (bitField0_ & ~0x00000004);
        lastProbeTime_ = 0L;
        onChanged();
        return this;
      }

      private long lastTransitionTime_ ;
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>int64 last_transition_time = 4 [json_name = "lastTransitionTime", (.gen_bq_schema.bigquery) = { ... }</code>
       * @return The lastTransitionTime.
       */
      @java.lang.Override
      public long getLastTransitionTime() {
        return lastTransitionTime_;
      }
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>int64 last_transition_time = 4 [json_name = "lastTransitionTime", (.gen_bq_schema.bigquery) = { ... }</code>
       * @param value The lastTransitionTime to set.
       * @return This builder for chaining.
       */
      public Builder setLastTransitionTime(long value) {

        lastTransitionTime_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>int64 last_transition_time = 4 [json_name = "lastTransitionTime", (.gen_bq_schema.bigquery) = { ... }</code>
       * @return This builder for chaining.
       */
      public Builder clearLastTransitionTime() {
        bitField0_ = (bitField0_ & ~0x00000008);
        lastTransitionTime_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object reason_ = "";
      /**
       * <pre>
       * Unique, one-word, CamelCase reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 5 [json_name = "reason"];</code>
       * @return Whether the reason field is set.
       */
      public boolean hasReason() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Unique, one-word, CamelCase reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 5 [json_name = "reason"];</code>
       * @return The reason.
       */
      public java.lang.String getReason() {
        java.lang.Object ref = reason_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          reason_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Unique, one-word, CamelCase reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 5 [json_name = "reason"];</code>
       * @return The bytes for reason.
       */
      public com.google.protobuf.ByteString
          getReasonBytes() {
        java.lang.Object ref = reason_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          reason_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Unique, one-word, CamelCase reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 5 [json_name = "reason"];</code>
       * @param value The reason to set.
       * @return This builder for chaining.
       */
      public Builder setReason(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        reason_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Unique, one-word, CamelCase reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 5 [json_name = "reason"];</code>
       * @return This builder for chaining.
       */
      public Builder clearReason() {
        reason_ = getDefaultInstance().getReason();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Unique, one-word, CamelCase reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 5 [json_name = "reason"];</code>
       * @param value The bytes for reason to set.
       * @return This builder for chaining.
       */
      public Builder setReasonBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        reason_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      private java.lang.Object message_ = "";
      /**
       * <pre>
       * Human-readable message indicating details about last transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 6 [json_name = "message"];</code>
       * @return Whether the message field is set.
       */
      public boolean hasMessage() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Human-readable message indicating details about last transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 6 [json_name = "message"];</code>
       * @return The message.
       */
      public java.lang.String getMessage() {
        java.lang.Object ref = message_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          message_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Human-readable message indicating details about last transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 6 [json_name = "message"];</code>
       * @return The bytes for message.
       */
      public com.google.protobuf.ByteString
          getMessageBytes() {
        java.lang.Object ref = message_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          message_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Human-readable message indicating details about last transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 6 [json_name = "message"];</code>
       * @param value The message to set.
       * @return This builder for chaining.
       */
      public Builder setMessage(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        message_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Human-readable message indicating details about last transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 6 [json_name = "message"];</code>
       * @return This builder for chaining.
       */
      public Builder clearMessage() {
        message_ = getDefaultInstance().getMessage();
        bitField0_ = (bitField0_ & ~0x00000020);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Human-readable message indicating details about last transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 6 [json_name = "message"];</code>
       * @param value The bytes for message to set.
       * @return This builder for chaining.
       */
      public Builder setMessageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        message_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chalk.pubsub.v1.PodStatusPubSub.PodCondition)
    }

    // @@protoc_insertion_point(class_scope:chalk.pubsub.v1.PodStatusPubSub.PodCondition)
    private static final ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition();
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<PodCondition>
        PARSER = new com.google.protobuf.AbstractParser<PodCondition>() {
      @java.lang.Override
      public PodCondition parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<PodCondition> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PodCondition> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface HostIPOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chalk.pubsub.v1.PodStatusPubSub.HostIP)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * IP is the IP address assigned to the host
     * </pre>
     *
     * <code>optional string ip = 1 [json_name = "ip"];</code>
     * @return Whether the ip field is set.
     */
    boolean hasIp();
    /**
     * <pre>
     * IP is the IP address assigned to the host
     * </pre>
     *
     * <code>optional string ip = 1 [json_name = "ip"];</code>
     * @return The ip.
     */
    java.lang.String getIp();
    /**
     * <pre>
     * IP is the IP address assigned to the host
     * </pre>
     *
     * <code>optional string ip = 1 [json_name = "ip"];</code>
     * @return The bytes for ip.
     */
    com.google.protobuf.ByteString
        getIpBytes();
  }
  /**
   * <pre>
   * HostIP represents a single IP address allocated to the host.
   * </pre>
   *
   * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.HostIP}
   */
  public static final class HostIP extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chalk.pubsub.v1.PodStatusPubSub.HostIP)
      HostIPOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use HostIP.newBuilder() to construct.
    private HostIP(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private HostIP() {
      ip_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new HostIP();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_HostIP_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_HostIP_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP.Builder.class);
    }

    private int bitField0_;
    public static final int IP_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object ip_ = "";
    /**
     * <pre>
     * IP is the IP address assigned to the host
     * </pre>
     *
     * <code>optional string ip = 1 [json_name = "ip"];</code>
     * @return Whether the ip field is set.
     */
    @java.lang.Override
    public boolean hasIp() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * IP is the IP address assigned to the host
     * </pre>
     *
     * <code>optional string ip = 1 [json_name = "ip"];</code>
     * @return The ip.
     */
    @java.lang.Override
    public java.lang.String getIp() {
      java.lang.Object ref = ip_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        ip_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * IP is the IP address assigned to the host
     * </pre>
     *
     * <code>optional string ip = 1 [json_name = "ip"];</code>
     * @return The bytes for ip.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getIpBytes() {
      java.lang.Object ref = ip_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        ip_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, ip_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, ip_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP)) {
        return super.equals(obj);
      }
      ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP other = (ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP) obj;

      if (hasIp() != other.hasIp()) return false;
      if (hasIp()) {
        if (!getIp()
            .equals(other.getIp())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasIp()) {
        hash = (37 * hash) + IP_FIELD_NUMBER;
        hash = (53 * hash) + getIp().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * HostIP represents a single IP address allocated to the host.
     * </pre>
     *
     * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.HostIP}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chalk.pubsub.v1.PodStatusPubSub.HostIP)
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIPOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_HostIP_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_HostIP_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP.Builder.class);
      }

      // Construct using ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        ip_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_HostIP_descriptor;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP getDefaultInstanceForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP.getDefaultInstance();
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP build() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP buildPartial() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP result = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.ip_ = ip_;
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP) {
          return mergeFrom((ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP other) {
        if (other == ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP.getDefaultInstance()) return this;
        if (other.hasIp()) {
          ip_ = other.ip_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                ip_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object ip_ = "";
      /**
       * <pre>
       * IP is the IP address assigned to the host
       * </pre>
       *
       * <code>optional string ip = 1 [json_name = "ip"];</code>
       * @return Whether the ip field is set.
       */
      public boolean hasIp() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * IP is the IP address assigned to the host
       * </pre>
       *
       * <code>optional string ip = 1 [json_name = "ip"];</code>
       * @return The ip.
       */
      public java.lang.String getIp() {
        java.lang.Object ref = ip_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          ip_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * IP is the IP address assigned to the host
       * </pre>
       *
       * <code>optional string ip = 1 [json_name = "ip"];</code>
       * @return The bytes for ip.
       */
      public com.google.protobuf.ByteString
          getIpBytes() {
        java.lang.Object ref = ip_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          ip_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * IP is the IP address assigned to the host
       * </pre>
       *
       * <code>optional string ip = 1 [json_name = "ip"];</code>
       * @param value The ip to set.
       * @return This builder for chaining.
       */
      public Builder setIp(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ip_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * IP is the IP address assigned to the host
       * </pre>
       *
       * <code>optional string ip = 1 [json_name = "ip"];</code>
       * @return This builder for chaining.
       */
      public Builder clearIp() {
        ip_ = getDefaultInstance().getIp();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * IP is the IP address assigned to the host
       * </pre>
       *
       * <code>optional string ip = 1 [json_name = "ip"];</code>
       * @param value The bytes for ip to set.
       * @return This builder for chaining.
       */
      public Builder setIpBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        ip_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chalk.pubsub.v1.PodStatusPubSub.HostIP)
    }

    // @@protoc_insertion_point(class_scope:chalk.pubsub.v1.PodStatusPubSub.HostIP)
    private static final ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP();
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<HostIP>
        PARSER = new com.google.protobuf.AbstractParser<HostIP>() {
      @java.lang.Override
      public HostIP parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<HostIP> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<HostIP> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PodStatusOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chalk.pubsub.v1.PodStatusPubSub.PodStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
     * The conditions array, the reason and message fields, and the individual container status
     * arrays contain more detail about the pod's status.
     * There are five possible phase values:
     *
     * Pending: The pod has been accepted by the Kubernetes system, but one or more of the
     * container images has not been created. This includes time before being scheduled as
     * well as time spent downloading images over the network, which could take a while.
     * Running: The pod has been bound to a node, and all of the containers have been created.
     * At least one container is still running, or is in the process of starting or restarting.
     * Succeeded: All containers in the pod have terminated in success, and will not be restarted.
     * Failed: All containers in the pod have terminated, and at least one container has
     * terminated in failure. The container either exited with non-zero status or was terminated
     * by the system.
     * Unknown: For some reason the state of the pod could not be obtained, typically due to an
     * error in communicating with the host of the pod.
     *
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
     * +optional
     * </pre>
     *
     * <code>optional string phase = 1 [json_name = "phase"];</code>
     * @return Whether the phase field is set.
     */
    boolean hasPhase();
    /**
     * <pre>
     * The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
     * The conditions array, the reason and message fields, and the individual container status
     * arrays contain more detail about the pod's status.
     * There are five possible phase values:
     *
     * Pending: The pod has been accepted by the Kubernetes system, but one or more of the
     * container images has not been created. This includes time before being scheduled as
     * well as time spent downloading images over the network, which could take a while.
     * Running: The pod has been bound to a node, and all of the containers have been created.
     * At least one container is still running, or is in the process of starting or restarting.
     * Succeeded: All containers in the pod have terminated in success, and will not be restarted.
     * Failed: All containers in the pod have terminated, and at least one container has
     * terminated in failure. The container either exited with non-zero status or was terminated
     * by the system.
     * Unknown: For some reason the state of the pod could not be obtained, typically due to an
     * error in communicating with the host of the pod.
     *
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
     * +optional
     * </pre>
     *
     * <code>optional string phase = 1 [json_name = "phase"];</code>
     * @return The phase.
     */
    java.lang.String getPhase();
    /**
     * <pre>
     * The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
     * The conditions array, the reason and message fields, and the individual container status
     * arrays contain more detail about the pod's status.
     * There are five possible phase values:
     *
     * Pending: The pod has been accepted by the Kubernetes system, but one or more of the
     * container images has not been created. This includes time before being scheduled as
     * well as time spent downloading images over the network, which could take a while.
     * Running: The pod has been bound to a node, and all of the containers have been created.
     * At least one container is still running, or is in the process of starting or restarting.
     * Succeeded: All containers in the pod have terminated in success, and will not be restarted.
     * Failed: All containers in the pod have terminated, and at least one container has
     * terminated in failure. The container either exited with non-zero status or was terminated
     * by the system.
     * Unknown: For some reason the state of the pod could not be obtained, typically due to an
     * error in communicating with the host of the pod.
     *
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
     * +optional
     * </pre>
     *
     * <code>optional string phase = 1 [json_name = "phase"];</code>
     * @return The bytes for phase.
     */
    com.google.protobuf.ByteString
        getPhaseBytes();

    /**
     * <pre>
     * Current service state of pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
     */
    java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition> 
        getConditionsList();
    /**
     * <pre>
     * Current service state of pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition getConditions(int index);
    /**
     * <pre>
     * Current service state of pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
     */
    int getConditionsCount();
    /**
     * <pre>
     * Current service state of pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
     */
    java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodConditionOrBuilder> 
        getConditionsOrBuilderList();
    /**
     * <pre>
     * Current service state of pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodConditionOrBuilder getConditionsOrBuilder(
        int index);

    /**
     * <pre>
     * A human readable message indicating details about why the pod is in this condition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 3 [json_name = "message"];</code>
     * @return Whether the message field is set.
     */
    boolean hasMessage();
    /**
     * <pre>
     * A human readable message indicating details about why the pod is in this condition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 3 [json_name = "message"];</code>
     * @return The message.
     */
    java.lang.String getMessage();
    /**
     * <pre>
     * A human readable message indicating details about why the pod is in this condition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 3 [json_name = "message"];</code>
     * @return The bytes for message.
     */
    com.google.protobuf.ByteString
        getMessageBytes();

    /**
     * <pre>
     * A brief CamelCase message indicating details about why the pod is in this state.
     * e.g. 'Evicted'
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4 [json_name = "reason"];</code>
     * @return Whether the reason field is set.
     */
    boolean hasReason();
    /**
     * <pre>
     * A brief CamelCase message indicating details about why the pod is in this state.
     * e.g. 'Evicted'
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4 [json_name = "reason"];</code>
     * @return The reason.
     */
    java.lang.String getReason();
    /**
     * <pre>
     * A brief CamelCase message indicating details about why the pod is in this state.
     * e.g. 'Evicted'
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4 [json_name = "reason"];</code>
     * @return The bytes for reason.
     */
    com.google.protobuf.ByteString
        getReasonBytes();

    /**
     * <pre>
     * nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be
     * scheduled right away as preemption victims receive their graceful termination periods.
     * This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide
     * to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to
     * give the resources on this node to a higher priority pod that is created after preemption.
     * As a result, this field may be different than PodSpec.nodeName when the pod is
     * scheduled.
     * +optional
     * </pre>
     *
     * <code>optional string nominated_node_name = 11 [json_name = "nominatedNodeName"];</code>
     * @return Whether the nominatedNodeName field is set.
     */
    boolean hasNominatedNodeName();
    /**
     * <pre>
     * nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be
     * scheduled right away as preemption victims receive their graceful termination periods.
     * This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide
     * to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to
     * give the resources on this node to a higher priority pod that is created after preemption.
     * As a result, this field may be different than PodSpec.nodeName when the pod is
     * scheduled.
     * +optional
     * </pre>
     *
     * <code>optional string nominated_node_name = 11 [json_name = "nominatedNodeName"];</code>
     * @return The nominatedNodeName.
     */
    java.lang.String getNominatedNodeName();
    /**
     * <pre>
     * nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be
     * scheduled right away as preemption victims receive their graceful termination periods.
     * This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide
     * to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to
     * give the resources on this node to a higher priority pod that is created after preemption.
     * As a result, this field may be different than PodSpec.nodeName when the pod is
     * scheduled.
     * +optional
     * </pre>
     *
     * <code>optional string nominated_node_name = 11 [json_name = "nominatedNodeName"];</code>
     * @return The bytes for nominatedNodeName.
     */
    com.google.protobuf.ByteString
        getNominatedNodeNameBytes();

    /**
     * <pre>
     * hostIP holds the IP address of the host to which the pod is assigned. Empty if the pod has not started yet.
     * A pod can be assigned to a node that has a problem in kubelet which in turns mean that HostIP will
     * not be updated even if there is a node is assigned to pod
     * +optional
     * </pre>
     *
     * <code>optional string host_ip = 5 [json_name = "hostIp"];</code>
     * @return Whether the hostIp field is set.
     */
    boolean hasHostIp();
    /**
     * <pre>
     * hostIP holds the IP address of the host to which the pod is assigned. Empty if the pod has not started yet.
     * A pod can be assigned to a node that has a problem in kubelet which in turns mean that HostIP will
     * not be updated even if there is a node is assigned to pod
     * +optional
     * </pre>
     *
     * <code>optional string host_ip = 5 [json_name = "hostIp"];</code>
     * @return The hostIp.
     */
    java.lang.String getHostIp();
    /**
     * <pre>
     * hostIP holds the IP address of the host to which the pod is assigned. Empty if the pod has not started yet.
     * A pod can be assigned to a node that has a problem in kubelet which in turns mean that HostIP will
     * not be updated even if there is a node is assigned to pod
     * +optional
     * </pre>
     *
     * <code>optional string host_ip = 5 [json_name = "hostIp"];</code>
     * @return The bytes for hostIp.
     */
    com.google.protobuf.ByteString
        getHostIpBytes();

    /**
     * <pre>
     * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
     * match the hostIP field. This list is empty if the pod has not started yet.
     * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
     * not be updated even if there is a node is assigned to this pod.
     * +optional
     * +patchStrategy=merge
     * +patchMergeKey=ip
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
     */
    java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP> 
        getHostIpsList();
    /**
     * <pre>
     * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
     * match the hostIP field. This list is empty if the pod has not started yet.
     * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
     * not be updated even if there is a node is assigned to this pod.
     * +optional
     * +patchStrategy=merge
     * +patchMergeKey=ip
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP getHostIps(int index);
    /**
     * <pre>
     * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
     * match the hostIP field. This list is empty if the pod has not started yet.
     * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
     * not be updated even if there is a node is assigned to this pod.
     * +optional
     * +patchStrategy=merge
     * +patchMergeKey=ip
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
     */
    int getHostIpsCount();
    /**
     * <pre>
     * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
     * match the hostIP field. This list is empty if the pod has not started yet.
     * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
     * not be updated even if there is a node is assigned to this pod.
     * +optional
     * +patchStrategy=merge
     * +patchMergeKey=ip
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
     */
    java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIPOrBuilder> 
        getHostIpsOrBuilderList();
    /**
     * <pre>
     * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
     * match the hostIP field. This list is empty if the pod has not started yet.
     * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
     * not be updated even if there is a node is assigned to this pod.
     * +optional
     * +patchStrategy=merge
     * +patchMergeKey=ip
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIPOrBuilder getHostIpsOrBuilder(
        int index);

    /**
     * <pre>
     * podIP address allocated to the pod. Routable at least within the cluster.
     * Empty if not yet allocated.
     * +optional
     * </pre>
     *
     * <code>optional string pod_ip = 6 [json_name = "podIp"];</code>
     * @return Whether the podIp field is set.
     */
    boolean hasPodIp();
    /**
     * <pre>
     * podIP address allocated to the pod. Routable at least within the cluster.
     * Empty if not yet allocated.
     * +optional
     * </pre>
     *
     * <code>optional string pod_ip = 6 [json_name = "podIp"];</code>
     * @return The podIp.
     */
    java.lang.String getPodIp();
    /**
     * <pre>
     * podIP address allocated to the pod. Routable at least within the cluster.
     * Empty if not yet allocated.
     * +optional
     * </pre>
     *
     * <code>optional string pod_ip = 6 [json_name = "podIp"];</code>
     * @return The bytes for podIp.
     */
    com.google.protobuf.ByteString
        getPodIpBytes();

    /**
     * <pre>
     * RFC 3339 date and time at which the object was acknowledged by the Kubelet.
     * This is before the Kubelet pulled the container image(s) for the pod.
     * +optional
     * </pre>
     *
     * <code>optional int64 start_time = 7 [json_name = "startTime", (.gen_bq_schema.bigquery) = { ... }</code>
     * @return Whether the startTime field is set.
     */
    boolean hasStartTime();
    /**
     * <pre>
     * RFC 3339 date and time at which the object was acknowledged by the Kubelet.
     * This is before the Kubelet pulled the container image(s) for the pod.
     * +optional
     * </pre>
     *
     * <code>optional int64 start_time = 7 [json_name = "startTime", (.gen_bq_schema.bigquery) = { ... }</code>
     * @return The startTime.
     */
    long getStartTime();

    /**
     * <pre>
     * The list has one entry per init container in the manifest. The most recent successful
     * init container will have ready = true, the most recently started container will have
     * startTime set.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
     */
    java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus> 
        getInitContainerStatusesList();
    /**
     * <pre>
     * The list has one entry per init container in the manifest. The most recent successful
     * init container will have ready = true, the most recently started container will have
     * startTime set.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus getInitContainerStatuses(int index);
    /**
     * <pre>
     * The list has one entry per init container in the manifest. The most recent successful
     * init container will have ready = true, the most recently started container will have
     * startTime set.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
     */
    int getInitContainerStatusesCount();
    /**
     * <pre>
     * The list has one entry per init container in the manifest. The most recent successful
     * init container will have ready = true, the most recently started container will have
     * startTime set.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
     */
    java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder> 
        getInitContainerStatusesOrBuilderList();
    /**
     * <pre>
     * The list has one entry per init container in the manifest. The most recent successful
     * init container will have ready = true, the most recently started container will have
     * startTime set.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder getInitContainerStatusesOrBuilder(
        int index);

    /**
     * <pre>
     * The list has one entry per container in the manifest.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
     */
    java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus> 
        getContainerStatusesList();
    /**
     * <pre>
     * The list has one entry per container in the manifest.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus getContainerStatuses(int index);
    /**
     * <pre>
     * The list has one entry per container in the manifest.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
     */
    int getContainerStatusesCount();
    /**
     * <pre>
     * The list has one entry per container in the manifest.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
     */
    java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder> 
        getContainerStatusesOrBuilderList();
    /**
     * <pre>
     * The list has one entry per container in the manifest.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder getContainerStatusesOrBuilder(
        int index);

    /**
     * <pre>
     * The Quality of Service (QOS) classification assigned to the pod based on resource requirements
     * See PodQOSClass type for available QOS classes
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#quality-of-service-classes
     * +optional
     * </pre>
     *
     * <code>optional string qos_class = 9 [json_name = "qosClass"];</code>
     * @return Whether the qosClass field is set.
     */
    boolean hasQosClass();
    /**
     * <pre>
     * The Quality of Service (QOS) classification assigned to the pod based on resource requirements
     * See PodQOSClass type for available QOS classes
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#quality-of-service-classes
     * +optional
     * </pre>
     *
     * <code>optional string qos_class = 9 [json_name = "qosClass"];</code>
     * @return The qosClass.
     */
    java.lang.String getQosClass();
    /**
     * <pre>
     * The Quality of Service (QOS) classification assigned to the pod based on resource requirements
     * See PodQOSClass type for available QOS classes
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#quality-of-service-classes
     * +optional
     * </pre>
     *
     * <code>optional string qos_class = 9 [json_name = "qosClass"];</code>
     * @return The bytes for qosClass.
     */
    com.google.protobuf.ByteString
        getQosClassBytes();

    /**
     * <pre>
     * Status for any ephemeral containers that have run in this pod.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
     */
    java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus> 
        getEphemeralContainerStatusesList();
    /**
     * <pre>
     * Status for any ephemeral containers that have run in this pod.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus getEphemeralContainerStatuses(int index);
    /**
     * <pre>
     * Status for any ephemeral containers that have run in this pod.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
     */
    int getEphemeralContainerStatusesCount();
    /**
     * <pre>
     * Status for any ephemeral containers that have run in this pod.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
     */
    java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder> 
        getEphemeralContainerStatusesOrBuilderList();
    /**
     * <pre>
     * Status for any ephemeral containers that have run in this pod.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
     */
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder getEphemeralContainerStatusesOrBuilder(
        int index);

    /**
     * <pre>
     * Status of resources resize desired for pod's containers.
     * It is empty if no resources resize is pending.
     * Any changes to container resources will automatically set this to "Proposed"
     * +featureGate=InPlacePodVerticalScaling
     * +optional
     * </pre>
     *
     * <code>optional string resize = 14 [json_name = "resize"];</code>
     * @return Whether the resize field is set.
     */
    boolean hasResize();
    /**
     * <pre>
     * Status of resources resize desired for pod's containers.
     * It is empty if no resources resize is pending.
     * Any changes to container resources will automatically set this to "Proposed"
     * +featureGate=InPlacePodVerticalScaling
     * +optional
     * </pre>
     *
     * <code>optional string resize = 14 [json_name = "resize"];</code>
     * @return The resize.
     */
    java.lang.String getResize();
    /**
     * <pre>
     * Status of resources resize desired for pod's containers.
     * It is empty if no resources resize is pending.
     * Any changes to container resources will automatically set this to "Proposed"
     * +featureGate=InPlacePodVerticalScaling
     * +optional
     * </pre>
     *
     * <code>optional string resize = 14 [json_name = "resize"];</code>
     * @return The bytes for resize.
     */
    com.google.protobuf.ByteString
        getResizeBytes();
  }
  /**
   * <pre>
   * PodStatus represents information about the status of a pod. Status may trail the actual
   * state of a system, especially if the node that hosts the pod cannot contact the control
   * plane.
   * </pre>
   *
   * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.PodStatus}
   */
  public static final class PodStatus extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chalk.pubsub.v1.PodStatusPubSub.PodStatus)
      PodStatusOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use PodStatus.newBuilder() to construct.
    private PodStatus(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private PodStatus() {
      phase_ = "";
      conditions_ = java.util.Collections.emptyList();
      message_ = "";
      reason_ = "";
      nominatedNodeName_ = "";
      hostIp_ = "";
      hostIps_ = java.util.Collections.emptyList();
      podIp_ = "";
      initContainerStatuses_ = java.util.Collections.emptyList();
      containerStatuses_ = java.util.Collections.emptyList();
      qosClass_ = "";
      ephemeralContainerStatuses_ = java.util.Collections.emptyList();
      resize_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new PodStatus();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_PodStatus_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_PodStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus.Builder.class);
    }

    private int bitField0_;
    public static final int PHASE_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object phase_ = "";
    /**
     * <pre>
     * The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
     * The conditions array, the reason and message fields, and the individual container status
     * arrays contain more detail about the pod's status.
     * There are five possible phase values:
     *
     * Pending: The pod has been accepted by the Kubernetes system, but one or more of the
     * container images has not been created. This includes time before being scheduled as
     * well as time spent downloading images over the network, which could take a while.
     * Running: The pod has been bound to a node, and all of the containers have been created.
     * At least one container is still running, or is in the process of starting or restarting.
     * Succeeded: All containers in the pod have terminated in success, and will not be restarted.
     * Failed: All containers in the pod have terminated, and at least one container has
     * terminated in failure. The container either exited with non-zero status or was terminated
     * by the system.
     * Unknown: For some reason the state of the pod could not be obtained, typically due to an
     * error in communicating with the host of the pod.
     *
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
     * +optional
     * </pre>
     *
     * <code>optional string phase = 1 [json_name = "phase"];</code>
     * @return Whether the phase field is set.
     */
    @java.lang.Override
    public boolean hasPhase() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
     * The conditions array, the reason and message fields, and the individual container status
     * arrays contain more detail about the pod's status.
     * There are five possible phase values:
     *
     * Pending: The pod has been accepted by the Kubernetes system, but one or more of the
     * container images has not been created. This includes time before being scheduled as
     * well as time spent downloading images over the network, which could take a while.
     * Running: The pod has been bound to a node, and all of the containers have been created.
     * At least one container is still running, or is in the process of starting or restarting.
     * Succeeded: All containers in the pod have terminated in success, and will not be restarted.
     * Failed: All containers in the pod have terminated, and at least one container has
     * terminated in failure. The container either exited with non-zero status or was terminated
     * by the system.
     * Unknown: For some reason the state of the pod could not be obtained, typically due to an
     * error in communicating with the host of the pod.
     *
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
     * +optional
     * </pre>
     *
     * <code>optional string phase = 1 [json_name = "phase"];</code>
     * @return The phase.
     */
    @java.lang.Override
    public java.lang.String getPhase() {
      java.lang.Object ref = phase_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        phase_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
     * The conditions array, the reason and message fields, and the individual container status
     * arrays contain more detail about the pod's status.
     * There are five possible phase values:
     *
     * Pending: The pod has been accepted by the Kubernetes system, but one or more of the
     * container images has not been created. This includes time before being scheduled as
     * well as time spent downloading images over the network, which could take a while.
     * Running: The pod has been bound to a node, and all of the containers have been created.
     * At least one container is still running, or is in the process of starting or restarting.
     * Succeeded: All containers in the pod have terminated in success, and will not be restarted.
     * Failed: All containers in the pod have terminated, and at least one container has
     * terminated in failure. The container either exited with non-zero status or was terminated
     * by the system.
     * Unknown: For some reason the state of the pod could not be obtained, typically due to an
     * error in communicating with the host of the pod.
     *
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
     * +optional
     * </pre>
     *
     * <code>optional string phase = 1 [json_name = "phase"];</code>
     * @return The bytes for phase.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPhaseBytes() {
      java.lang.Object ref = phase_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        phase_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CONDITIONS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition> conditions_;
    /**
     * <pre>
     * Current service state of pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
     */
    @java.lang.Override
    public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition> getConditionsList() {
      return conditions_;
    }
    /**
     * <pre>
     * Current service state of pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
     */
    @java.lang.Override
    public java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodConditionOrBuilder> 
        getConditionsOrBuilderList() {
      return conditions_;
    }
    /**
     * <pre>
     * Current service state of pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
     */
    @java.lang.Override
    public int getConditionsCount() {
      return conditions_.size();
    }
    /**
     * <pre>
     * Current service state of pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition getConditions(int index) {
      return conditions_.get(index);
    }
    /**
     * <pre>
     * Current service state of pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodConditionOrBuilder getConditionsOrBuilder(
        int index) {
      return conditions_.get(index);
    }

    public static final int MESSAGE_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object message_ = "";
    /**
     * <pre>
     * A human readable message indicating details about why the pod is in this condition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 3 [json_name = "message"];</code>
     * @return Whether the message field is set.
     */
    @java.lang.Override
    public boolean hasMessage() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * A human readable message indicating details about why the pod is in this condition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 3 [json_name = "message"];</code>
     * @return The message.
     */
    @java.lang.Override
    public java.lang.String getMessage() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        message_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * A human readable message indicating details about why the pod is in this condition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 3 [json_name = "message"];</code>
     * @return The bytes for message.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getMessageBytes() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        message_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int REASON_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object reason_ = "";
    /**
     * <pre>
     * A brief CamelCase message indicating details about why the pod is in this state.
     * e.g. 'Evicted'
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4 [json_name = "reason"];</code>
     * @return Whether the reason field is set.
     */
    @java.lang.Override
    public boolean hasReason() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * A brief CamelCase message indicating details about why the pod is in this state.
     * e.g. 'Evicted'
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4 [json_name = "reason"];</code>
     * @return The reason.
     */
    @java.lang.Override
    public java.lang.String getReason() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        reason_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * A brief CamelCase message indicating details about why the pod is in this state.
     * e.g. 'Evicted'
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4 [json_name = "reason"];</code>
     * @return The bytes for reason.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getReasonBytes() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        reason_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NOMINATED_NODE_NAME_FIELD_NUMBER = 11;
    @SuppressWarnings("serial")
    private volatile java.lang.Object nominatedNodeName_ = "";
    /**
     * <pre>
     * nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be
     * scheduled right away as preemption victims receive their graceful termination periods.
     * This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide
     * to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to
     * give the resources on this node to a higher priority pod that is created after preemption.
     * As a result, this field may be different than PodSpec.nodeName when the pod is
     * scheduled.
     * +optional
     * </pre>
     *
     * <code>optional string nominated_node_name = 11 [json_name = "nominatedNodeName"];</code>
     * @return Whether the nominatedNodeName field is set.
     */
    @java.lang.Override
    public boolean hasNominatedNodeName() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be
     * scheduled right away as preemption victims receive their graceful termination periods.
     * This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide
     * to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to
     * give the resources on this node to a higher priority pod that is created after preemption.
     * As a result, this field may be different than PodSpec.nodeName when the pod is
     * scheduled.
     * +optional
     * </pre>
     *
     * <code>optional string nominated_node_name = 11 [json_name = "nominatedNodeName"];</code>
     * @return The nominatedNodeName.
     */
    @java.lang.Override
    public java.lang.String getNominatedNodeName() {
      java.lang.Object ref = nominatedNodeName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        nominatedNodeName_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be
     * scheduled right away as preemption victims receive their graceful termination periods.
     * This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide
     * to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to
     * give the resources on this node to a higher priority pod that is created after preemption.
     * As a result, this field may be different than PodSpec.nodeName when the pod is
     * scheduled.
     * +optional
     * </pre>
     *
     * <code>optional string nominated_node_name = 11 [json_name = "nominatedNodeName"];</code>
     * @return The bytes for nominatedNodeName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNominatedNodeNameBytes() {
      java.lang.Object ref = nominatedNodeName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        nominatedNodeName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int HOST_IP_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private volatile java.lang.Object hostIp_ = "";
    /**
     * <pre>
     * hostIP holds the IP address of the host to which the pod is assigned. Empty if the pod has not started yet.
     * A pod can be assigned to a node that has a problem in kubelet which in turns mean that HostIP will
     * not be updated even if there is a node is assigned to pod
     * +optional
     * </pre>
     *
     * <code>optional string host_ip = 5 [json_name = "hostIp"];</code>
     * @return Whether the hostIp field is set.
     */
    @java.lang.Override
    public boolean hasHostIp() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * hostIP holds the IP address of the host to which the pod is assigned. Empty if the pod has not started yet.
     * A pod can be assigned to a node that has a problem in kubelet which in turns mean that HostIP will
     * not be updated even if there is a node is assigned to pod
     * +optional
     * </pre>
     *
     * <code>optional string host_ip = 5 [json_name = "hostIp"];</code>
     * @return The hostIp.
     */
    @java.lang.Override
    public java.lang.String getHostIp() {
      java.lang.Object ref = hostIp_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        hostIp_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * hostIP holds the IP address of the host to which the pod is assigned. Empty if the pod has not started yet.
     * A pod can be assigned to a node that has a problem in kubelet which in turns mean that HostIP will
     * not be updated even if there is a node is assigned to pod
     * +optional
     * </pre>
     *
     * <code>optional string host_ip = 5 [json_name = "hostIp"];</code>
     * @return The bytes for hostIp.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getHostIpBytes() {
      java.lang.Object ref = hostIp_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        hostIp_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int HOST_IPS_FIELD_NUMBER = 16;
    @SuppressWarnings("serial")
    private java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP> hostIps_;
    /**
     * <pre>
     * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
     * match the hostIP field. This list is empty if the pod has not started yet.
     * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
     * not be updated even if there is a node is assigned to this pod.
     * +optional
     * +patchStrategy=merge
     * +patchMergeKey=ip
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
     */
    @java.lang.Override
    public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP> getHostIpsList() {
      return hostIps_;
    }
    /**
     * <pre>
     * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
     * match the hostIP field. This list is empty if the pod has not started yet.
     * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
     * not be updated even if there is a node is assigned to this pod.
     * +optional
     * +patchStrategy=merge
     * +patchMergeKey=ip
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
     */
    @java.lang.Override
    public java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIPOrBuilder> 
        getHostIpsOrBuilderList() {
      return hostIps_;
    }
    /**
     * <pre>
     * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
     * match the hostIP field. This list is empty if the pod has not started yet.
     * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
     * not be updated even if there is a node is assigned to this pod.
     * +optional
     * +patchStrategy=merge
     * +patchMergeKey=ip
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
     */
    @java.lang.Override
    public int getHostIpsCount() {
      return hostIps_.size();
    }
    /**
     * <pre>
     * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
     * match the hostIP field. This list is empty if the pod has not started yet.
     * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
     * not be updated even if there is a node is assigned to this pod.
     * +optional
     * +patchStrategy=merge
     * +patchMergeKey=ip
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP getHostIps(int index) {
      return hostIps_.get(index);
    }
    /**
     * <pre>
     * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
     * match the hostIP field. This list is empty if the pod has not started yet.
     * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
     * not be updated even if there is a node is assigned to this pod.
     * +optional
     * +patchStrategy=merge
     * +patchMergeKey=ip
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIPOrBuilder getHostIpsOrBuilder(
        int index) {
      return hostIps_.get(index);
    }

    public static final int POD_IP_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private volatile java.lang.Object podIp_ = "";
    /**
     * <pre>
     * podIP address allocated to the pod. Routable at least within the cluster.
     * Empty if not yet allocated.
     * +optional
     * </pre>
     *
     * <code>optional string pod_ip = 6 [json_name = "podIp"];</code>
     * @return Whether the podIp field is set.
     */
    @java.lang.Override
    public boolean hasPodIp() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * podIP address allocated to the pod. Routable at least within the cluster.
     * Empty if not yet allocated.
     * +optional
     * </pre>
     *
     * <code>optional string pod_ip = 6 [json_name = "podIp"];</code>
     * @return The podIp.
     */
    @java.lang.Override
    public java.lang.String getPodIp() {
      java.lang.Object ref = podIp_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        podIp_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * podIP address allocated to the pod. Routable at least within the cluster.
     * Empty if not yet allocated.
     * +optional
     * </pre>
     *
     * <code>optional string pod_ip = 6 [json_name = "podIp"];</code>
     * @return The bytes for podIp.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPodIpBytes() {
      java.lang.Object ref = podIp_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        podIp_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int START_TIME_FIELD_NUMBER = 7;
    private long startTime_ = 0L;
    /**
     * <pre>
     * RFC 3339 date and time at which the object was acknowledged by the Kubelet.
     * This is before the Kubelet pulled the container image(s) for the pod.
     * +optional
     * </pre>
     *
     * <code>optional int64 start_time = 7 [json_name = "startTime", (.gen_bq_schema.bigquery) = { ... }</code>
     * @return Whether the startTime field is set.
     */
    @java.lang.Override
    public boolean hasStartTime() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * RFC 3339 date and time at which the object was acknowledged by the Kubelet.
     * This is before the Kubelet pulled the container image(s) for the pod.
     * +optional
     * </pre>
     *
     * <code>optional int64 start_time = 7 [json_name = "startTime", (.gen_bq_schema.bigquery) = { ... }</code>
     * @return The startTime.
     */
    @java.lang.Override
    public long getStartTime() {
      return startTime_;
    }

    public static final int INIT_CONTAINER_STATUSES_FIELD_NUMBER = 10;
    @SuppressWarnings("serial")
    private java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus> initContainerStatuses_;
    /**
     * <pre>
     * The list has one entry per init container in the manifest. The most recent successful
     * init container will have ready = true, the most recently started container will have
     * startTime set.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
     */
    @java.lang.Override
    public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus> getInitContainerStatusesList() {
      return initContainerStatuses_;
    }
    /**
     * <pre>
     * The list has one entry per init container in the manifest. The most recent successful
     * init container will have ready = true, the most recently started container will have
     * startTime set.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
     */
    @java.lang.Override
    public java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder> 
        getInitContainerStatusesOrBuilderList() {
      return initContainerStatuses_;
    }
    /**
     * <pre>
     * The list has one entry per init container in the manifest. The most recent successful
     * init container will have ready = true, the most recently started container will have
     * startTime set.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
     */
    @java.lang.Override
    public int getInitContainerStatusesCount() {
      return initContainerStatuses_.size();
    }
    /**
     * <pre>
     * The list has one entry per init container in the manifest. The most recent successful
     * init container will have ready = true, the most recently started container will have
     * startTime set.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus getInitContainerStatuses(int index) {
      return initContainerStatuses_.get(index);
    }
    /**
     * <pre>
     * The list has one entry per init container in the manifest. The most recent successful
     * init container will have ready = true, the most recently started container will have
     * startTime set.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder getInitContainerStatusesOrBuilder(
        int index) {
      return initContainerStatuses_.get(index);
    }

    public static final int CONTAINER_STATUSES_FIELD_NUMBER = 8;
    @SuppressWarnings("serial")
    private java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus> containerStatuses_;
    /**
     * <pre>
     * The list has one entry per container in the manifest.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
     */
    @java.lang.Override
    public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus> getContainerStatusesList() {
      return containerStatuses_;
    }
    /**
     * <pre>
     * The list has one entry per container in the manifest.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
     */
    @java.lang.Override
    public java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder> 
        getContainerStatusesOrBuilderList() {
      return containerStatuses_;
    }
    /**
     * <pre>
     * The list has one entry per container in the manifest.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
     */
    @java.lang.Override
    public int getContainerStatusesCount() {
      return containerStatuses_.size();
    }
    /**
     * <pre>
     * The list has one entry per container in the manifest.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus getContainerStatuses(int index) {
      return containerStatuses_.get(index);
    }
    /**
     * <pre>
     * The list has one entry per container in the manifest.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder getContainerStatusesOrBuilder(
        int index) {
      return containerStatuses_.get(index);
    }

    public static final int QOS_CLASS_FIELD_NUMBER = 9;
    @SuppressWarnings("serial")
    private volatile java.lang.Object qosClass_ = "";
    /**
     * <pre>
     * The Quality of Service (QOS) classification assigned to the pod based on resource requirements
     * See PodQOSClass type for available QOS classes
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#quality-of-service-classes
     * +optional
     * </pre>
     *
     * <code>optional string qos_class = 9 [json_name = "qosClass"];</code>
     * @return Whether the qosClass field is set.
     */
    @java.lang.Override
    public boolean hasQosClass() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * The Quality of Service (QOS) classification assigned to the pod based on resource requirements
     * See PodQOSClass type for available QOS classes
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#quality-of-service-classes
     * +optional
     * </pre>
     *
     * <code>optional string qos_class = 9 [json_name = "qosClass"];</code>
     * @return The qosClass.
     */
    @java.lang.Override
    public java.lang.String getQosClass() {
      java.lang.Object ref = qosClass_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        qosClass_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The Quality of Service (QOS) classification assigned to the pod based on resource requirements
     * See PodQOSClass type for available QOS classes
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#quality-of-service-classes
     * +optional
     * </pre>
     *
     * <code>optional string qos_class = 9 [json_name = "qosClass"];</code>
     * @return The bytes for qosClass.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getQosClassBytes() {
      java.lang.Object ref = qosClass_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        qosClass_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int EPHEMERAL_CONTAINER_STATUSES_FIELD_NUMBER = 13;
    @SuppressWarnings("serial")
    private java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus> ephemeralContainerStatuses_;
    /**
     * <pre>
     * Status for any ephemeral containers that have run in this pod.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
     */
    @java.lang.Override
    public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus> getEphemeralContainerStatusesList() {
      return ephemeralContainerStatuses_;
    }
    /**
     * <pre>
     * Status for any ephemeral containers that have run in this pod.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
     */
    @java.lang.Override
    public java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder> 
        getEphemeralContainerStatusesOrBuilderList() {
      return ephemeralContainerStatuses_;
    }
    /**
     * <pre>
     * Status for any ephemeral containers that have run in this pod.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
     */
    @java.lang.Override
    public int getEphemeralContainerStatusesCount() {
      return ephemeralContainerStatuses_.size();
    }
    /**
     * <pre>
     * Status for any ephemeral containers that have run in this pod.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus getEphemeralContainerStatuses(int index) {
      return ephemeralContainerStatuses_.get(index);
    }
    /**
     * <pre>
     * Status for any ephemeral containers that have run in this pod.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
     */
    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder getEphemeralContainerStatusesOrBuilder(
        int index) {
      return ephemeralContainerStatuses_.get(index);
    }

    public static final int RESIZE_FIELD_NUMBER = 14;
    @SuppressWarnings("serial")
    private volatile java.lang.Object resize_ = "";
    /**
     * <pre>
     * Status of resources resize desired for pod's containers.
     * It is empty if no resources resize is pending.
     * Any changes to container resources will automatically set this to "Proposed"
     * +featureGate=InPlacePodVerticalScaling
     * +optional
     * </pre>
     *
     * <code>optional string resize = 14 [json_name = "resize"];</code>
     * @return Whether the resize field is set.
     */
    @java.lang.Override
    public boolean hasResize() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Status of resources resize desired for pod's containers.
     * It is empty if no resources resize is pending.
     * Any changes to container resources will automatically set this to "Proposed"
     * +featureGate=InPlacePodVerticalScaling
     * +optional
     * </pre>
     *
     * <code>optional string resize = 14 [json_name = "resize"];</code>
     * @return The resize.
     */
    @java.lang.Override
    public java.lang.String getResize() {
      java.lang.Object ref = resize_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        resize_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Status of resources resize desired for pod's containers.
     * It is empty if no resources resize is pending.
     * Any changes to container resources will automatically set this to "Proposed"
     * +featureGate=InPlacePodVerticalScaling
     * +optional
     * </pre>
     *
     * <code>optional string resize = 14 [json_name = "resize"];</code>
     * @return The bytes for resize.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getResizeBytes() {
      java.lang.Object ref = resize_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        resize_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, phase_);
      }
      for (int i = 0; i < conditions_.size(); i++) {
        output.writeMessage(2, conditions_.get(i));
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, message_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, reason_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, hostIp_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 6, podIp_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeInt64(7, startTime_);
      }
      for (int i = 0; i < containerStatuses_.size(); i++) {
        output.writeMessage(8, containerStatuses_.get(i));
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 9, qosClass_);
      }
      for (int i = 0; i < initContainerStatuses_.size(); i++) {
        output.writeMessage(10, initContainerStatuses_.get(i));
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 11, nominatedNodeName_);
      }
      for (int i = 0; i < ephemeralContainerStatuses_.size(); i++) {
        output.writeMessage(13, ephemeralContainerStatuses_.get(i));
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 14, resize_);
      }
      for (int i = 0; i < hostIps_.size(); i++) {
        output.writeMessage(16, hostIps_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, phase_);
      }
      for (int i = 0; i < conditions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, conditions_.get(i));
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, message_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, reason_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, hostIp_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, podIp_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(7, startTime_);
      }
      for (int i = 0; i < containerStatuses_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, containerStatuses_.get(i));
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(9, qosClass_);
      }
      for (int i = 0; i < initContainerStatuses_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(10, initContainerStatuses_.get(i));
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(11, nominatedNodeName_);
      }
      for (int i = 0; i < ephemeralContainerStatuses_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(13, ephemeralContainerStatuses_.get(i));
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(14, resize_);
      }
      for (int i = 0; i < hostIps_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(16, hostIps_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus)) {
        return super.equals(obj);
      }
      ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus other = (ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus) obj;

      if (hasPhase() != other.hasPhase()) return false;
      if (hasPhase()) {
        if (!getPhase()
            .equals(other.getPhase())) return false;
      }
      if (!getConditionsList()
          .equals(other.getConditionsList())) return false;
      if (hasMessage() != other.hasMessage()) return false;
      if (hasMessage()) {
        if (!getMessage()
            .equals(other.getMessage())) return false;
      }
      if (hasReason() != other.hasReason()) return false;
      if (hasReason()) {
        if (!getReason()
            .equals(other.getReason())) return false;
      }
      if (hasNominatedNodeName() != other.hasNominatedNodeName()) return false;
      if (hasNominatedNodeName()) {
        if (!getNominatedNodeName()
            .equals(other.getNominatedNodeName())) return false;
      }
      if (hasHostIp() != other.hasHostIp()) return false;
      if (hasHostIp()) {
        if (!getHostIp()
            .equals(other.getHostIp())) return false;
      }
      if (!getHostIpsList()
          .equals(other.getHostIpsList())) return false;
      if (hasPodIp() != other.hasPodIp()) return false;
      if (hasPodIp()) {
        if (!getPodIp()
            .equals(other.getPodIp())) return false;
      }
      if (hasStartTime() != other.hasStartTime()) return false;
      if (hasStartTime()) {
        if (getStartTime()
            != other.getStartTime()) return false;
      }
      if (!getInitContainerStatusesList()
          .equals(other.getInitContainerStatusesList())) return false;
      if (!getContainerStatusesList()
          .equals(other.getContainerStatusesList())) return false;
      if (hasQosClass() != other.hasQosClass()) return false;
      if (hasQosClass()) {
        if (!getQosClass()
            .equals(other.getQosClass())) return false;
      }
      if (!getEphemeralContainerStatusesList()
          .equals(other.getEphemeralContainerStatusesList())) return false;
      if (hasResize() != other.hasResize()) return false;
      if (hasResize()) {
        if (!getResize()
            .equals(other.getResize())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasPhase()) {
        hash = (37 * hash) + PHASE_FIELD_NUMBER;
        hash = (53 * hash) + getPhase().hashCode();
      }
      if (getConditionsCount() > 0) {
        hash = (37 * hash) + CONDITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getConditionsList().hashCode();
      }
      if (hasMessage()) {
        hash = (37 * hash) + MESSAGE_FIELD_NUMBER;
        hash = (53 * hash) + getMessage().hashCode();
      }
      if (hasReason()) {
        hash = (37 * hash) + REASON_FIELD_NUMBER;
        hash = (53 * hash) + getReason().hashCode();
      }
      if (hasNominatedNodeName()) {
        hash = (37 * hash) + NOMINATED_NODE_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getNominatedNodeName().hashCode();
      }
      if (hasHostIp()) {
        hash = (37 * hash) + HOST_IP_FIELD_NUMBER;
        hash = (53 * hash) + getHostIp().hashCode();
      }
      if (getHostIpsCount() > 0) {
        hash = (37 * hash) + HOST_IPS_FIELD_NUMBER;
        hash = (53 * hash) + getHostIpsList().hashCode();
      }
      if (hasPodIp()) {
        hash = (37 * hash) + POD_IP_FIELD_NUMBER;
        hash = (53 * hash) + getPodIp().hashCode();
      }
      if (hasStartTime()) {
        hash = (37 * hash) + START_TIME_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getStartTime());
      }
      if (getInitContainerStatusesCount() > 0) {
        hash = (37 * hash) + INIT_CONTAINER_STATUSES_FIELD_NUMBER;
        hash = (53 * hash) + getInitContainerStatusesList().hashCode();
      }
      if (getContainerStatusesCount() > 0) {
        hash = (37 * hash) + CONTAINER_STATUSES_FIELD_NUMBER;
        hash = (53 * hash) + getContainerStatusesList().hashCode();
      }
      if (hasQosClass()) {
        hash = (37 * hash) + QOS_CLASS_FIELD_NUMBER;
        hash = (53 * hash) + getQosClass().hashCode();
      }
      if (getEphemeralContainerStatusesCount() > 0) {
        hash = (37 * hash) + EPHEMERAL_CONTAINER_STATUSES_FIELD_NUMBER;
        hash = (53 * hash) + getEphemeralContainerStatusesList().hashCode();
      }
      if (hasResize()) {
        hash = (37 * hash) + RESIZE_FIELD_NUMBER;
        hash = (53 * hash) + getResize().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * PodStatus represents information about the status of a pod. Status may trail the actual
     * state of a system, especially if the node that hosts the pod cannot contact the control
     * plane.
     * </pre>
     *
     * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub.PodStatus}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chalk.pubsub.v1.PodStatusPubSub.PodStatus)
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_PodStatus_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_PodStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus.Builder.class);
      }

      // Construct using ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        phase_ = "";
        if (conditionsBuilder_ == null) {
          conditions_ = java.util.Collections.emptyList();
        } else {
          conditions_ = null;
          conditionsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        message_ = "";
        reason_ = "";
        nominatedNodeName_ = "";
        hostIp_ = "";
        if (hostIpsBuilder_ == null) {
          hostIps_ = java.util.Collections.emptyList();
        } else {
          hostIps_ = null;
          hostIpsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        podIp_ = "";
        startTime_ = 0L;
        if (initContainerStatusesBuilder_ == null) {
          initContainerStatuses_ = java.util.Collections.emptyList();
        } else {
          initContainerStatuses_ = null;
          initContainerStatusesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000200);
        if (containerStatusesBuilder_ == null) {
          containerStatuses_ = java.util.Collections.emptyList();
        } else {
          containerStatuses_ = null;
          containerStatusesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000400);
        qosClass_ = "";
        if (ephemeralContainerStatusesBuilder_ == null) {
          ephemeralContainerStatuses_ = java.util.Collections.emptyList();
        } else {
          ephemeralContainerStatuses_ = null;
          ephemeralContainerStatusesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00001000);
        resize_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_PodStatus_descriptor;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus getDefaultInstanceForType() {
        return ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus.getDefaultInstance();
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus build() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus buildPartial() {
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus result = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus result) {
        if (conditionsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            conditions_ = java.util.Collections.unmodifiableList(conditions_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.conditions_ = conditions_;
        } else {
          result.conditions_ = conditionsBuilder_.build();
        }
        if (hostIpsBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0)) {
            hostIps_ = java.util.Collections.unmodifiableList(hostIps_);
            bitField0_ = (bitField0_ & ~0x00000040);
          }
          result.hostIps_ = hostIps_;
        } else {
          result.hostIps_ = hostIpsBuilder_.build();
        }
        if (initContainerStatusesBuilder_ == null) {
          if (((bitField0_ & 0x00000200) != 0)) {
            initContainerStatuses_ = java.util.Collections.unmodifiableList(initContainerStatuses_);
            bitField0_ = (bitField0_ & ~0x00000200);
          }
          result.initContainerStatuses_ = initContainerStatuses_;
        } else {
          result.initContainerStatuses_ = initContainerStatusesBuilder_.build();
        }
        if (containerStatusesBuilder_ == null) {
          if (((bitField0_ & 0x00000400) != 0)) {
            containerStatuses_ = java.util.Collections.unmodifiableList(containerStatuses_);
            bitField0_ = (bitField0_ & ~0x00000400);
          }
          result.containerStatuses_ = containerStatuses_;
        } else {
          result.containerStatuses_ = containerStatusesBuilder_.build();
        }
        if (ephemeralContainerStatusesBuilder_ == null) {
          if (((bitField0_ & 0x00001000) != 0)) {
            ephemeralContainerStatuses_ = java.util.Collections.unmodifiableList(ephemeralContainerStatuses_);
            bitField0_ = (bitField0_ & ~0x00001000);
          }
          result.ephemeralContainerStatuses_ = ephemeralContainerStatuses_;
        } else {
          result.ephemeralContainerStatuses_ = ephemeralContainerStatusesBuilder_.build();
        }
      }

      private void buildPartial0(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.phase_ = phase_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.message_ = message_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.reason_ = reason_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.nominatedNodeName_ = nominatedNodeName_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.hostIp_ = hostIp_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.podIp_ = podIp_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.startTime_ = startTime_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.qosClass_ = qosClass_;
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          result.resize_ = resize_;
          to_bitField0_ |= 0x00000100;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus) {
          return mergeFrom((ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus other) {
        if (other == ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus.getDefaultInstance()) return this;
        if (other.hasPhase()) {
          phase_ = other.phase_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (conditionsBuilder_ == null) {
          if (!other.conditions_.isEmpty()) {
            if (conditions_.isEmpty()) {
              conditions_ = other.conditions_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureConditionsIsMutable();
              conditions_.addAll(other.conditions_);
            }
            onChanged();
          }
        } else {
          if (!other.conditions_.isEmpty()) {
            if (conditionsBuilder_.isEmpty()) {
              conditionsBuilder_.dispose();
              conditionsBuilder_ = null;
              conditions_ = other.conditions_;
              bitField0_ = (bitField0_ & ~0x00000002);
              conditionsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getConditionsFieldBuilder() : null;
            } else {
              conditionsBuilder_.addAllMessages(other.conditions_);
            }
          }
        }
        if (other.hasMessage()) {
          message_ = other.message_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        if (other.hasReason()) {
          reason_ = other.reason_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (other.hasNominatedNodeName()) {
          nominatedNodeName_ = other.nominatedNodeName_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        if (other.hasHostIp()) {
          hostIp_ = other.hostIp_;
          bitField0_ |= 0x00000020;
          onChanged();
        }
        if (hostIpsBuilder_ == null) {
          if (!other.hostIps_.isEmpty()) {
            if (hostIps_.isEmpty()) {
              hostIps_ = other.hostIps_;
              bitField0_ = (bitField0_ & ~0x00000040);
            } else {
              ensureHostIpsIsMutable();
              hostIps_.addAll(other.hostIps_);
            }
            onChanged();
          }
        } else {
          if (!other.hostIps_.isEmpty()) {
            if (hostIpsBuilder_.isEmpty()) {
              hostIpsBuilder_.dispose();
              hostIpsBuilder_ = null;
              hostIps_ = other.hostIps_;
              bitField0_ = (bitField0_ & ~0x00000040);
              hostIpsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getHostIpsFieldBuilder() : null;
            } else {
              hostIpsBuilder_.addAllMessages(other.hostIps_);
            }
          }
        }
        if (other.hasPodIp()) {
          podIp_ = other.podIp_;
          bitField0_ |= 0x00000080;
          onChanged();
        }
        if (other.hasStartTime()) {
          setStartTime(other.getStartTime());
        }
        if (initContainerStatusesBuilder_ == null) {
          if (!other.initContainerStatuses_.isEmpty()) {
            if (initContainerStatuses_.isEmpty()) {
              initContainerStatuses_ = other.initContainerStatuses_;
              bitField0_ = (bitField0_ & ~0x00000200);
            } else {
              ensureInitContainerStatusesIsMutable();
              initContainerStatuses_.addAll(other.initContainerStatuses_);
            }
            onChanged();
          }
        } else {
          if (!other.initContainerStatuses_.isEmpty()) {
            if (initContainerStatusesBuilder_.isEmpty()) {
              initContainerStatusesBuilder_.dispose();
              initContainerStatusesBuilder_ = null;
              initContainerStatuses_ = other.initContainerStatuses_;
              bitField0_ = (bitField0_ & ~0x00000200);
              initContainerStatusesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getInitContainerStatusesFieldBuilder() : null;
            } else {
              initContainerStatusesBuilder_.addAllMessages(other.initContainerStatuses_);
            }
          }
        }
        if (containerStatusesBuilder_ == null) {
          if (!other.containerStatuses_.isEmpty()) {
            if (containerStatuses_.isEmpty()) {
              containerStatuses_ = other.containerStatuses_;
              bitField0_ = (bitField0_ & ~0x00000400);
            } else {
              ensureContainerStatusesIsMutable();
              containerStatuses_.addAll(other.containerStatuses_);
            }
            onChanged();
          }
        } else {
          if (!other.containerStatuses_.isEmpty()) {
            if (containerStatusesBuilder_.isEmpty()) {
              containerStatusesBuilder_.dispose();
              containerStatusesBuilder_ = null;
              containerStatuses_ = other.containerStatuses_;
              bitField0_ = (bitField0_ & ~0x00000400);
              containerStatusesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getContainerStatusesFieldBuilder() : null;
            } else {
              containerStatusesBuilder_.addAllMessages(other.containerStatuses_);
            }
          }
        }
        if (other.hasQosClass()) {
          qosClass_ = other.qosClass_;
          bitField0_ |= 0x00000800;
          onChanged();
        }
        if (ephemeralContainerStatusesBuilder_ == null) {
          if (!other.ephemeralContainerStatuses_.isEmpty()) {
            if (ephemeralContainerStatuses_.isEmpty()) {
              ephemeralContainerStatuses_ = other.ephemeralContainerStatuses_;
              bitField0_ = (bitField0_ & ~0x00001000);
            } else {
              ensureEphemeralContainerStatusesIsMutable();
              ephemeralContainerStatuses_.addAll(other.ephemeralContainerStatuses_);
            }
            onChanged();
          }
        } else {
          if (!other.ephemeralContainerStatuses_.isEmpty()) {
            if (ephemeralContainerStatusesBuilder_.isEmpty()) {
              ephemeralContainerStatusesBuilder_.dispose();
              ephemeralContainerStatusesBuilder_ = null;
              ephemeralContainerStatuses_ = other.ephemeralContainerStatuses_;
              bitField0_ = (bitField0_ & ~0x00001000);
              ephemeralContainerStatusesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getEphemeralContainerStatusesFieldBuilder() : null;
            } else {
              ephemeralContainerStatusesBuilder_.addAllMessages(other.ephemeralContainerStatuses_);
            }
          }
        }
        if (other.hasResize()) {
          resize_ = other.resize_;
          bitField0_ |= 0x00002000;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                phase_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition m =
                    input.readMessage(
                        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition.parser(),
                        extensionRegistry);
                if (conditionsBuilder_ == null) {
                  ensureConditionsIsMutable();
                  conditions_.add(m);
                } else {
                  conditionsBuilder_.addMessage(m);
                }
                break;
              } // case 18
              case 26: {
                message_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                reason_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                hostIp_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000020;
                break;
              } // case 42
              case 50: {
                podIp_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000080;
                break;
              } // case 50
              case 56: {
                startTime_ = input.readInt64();
                bitField0_ |= 0x00000100;
                break;
              } // case 56
              case 66: {
                ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus m =
                    input.readMessage(
                        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.parser(),
                        extensionRegistry);
                if (containerStatusesBuilder_ == null) {
                  ensureContainerStatusesIsMutable();
                  containerStatuses_.add(m);
                } else {
                  containerStatusesBuilder_.addMessage(m);
                }
                break;
              } // case 66
              case 74: {
                qosClass_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000800;
                break;
              } // case 74
              case 82: {
                ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus m =
                    input.readMessage(
                        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.parser(),
                        extensionRegistry);
                if (initContainerStatusesBuilder_ == null) {
                  ensureInitContainerStatusesIsMutable();
                  initContainerStatuses_.add(m);
                } else {
                  initContainerStatusesBuilder_.addMessage(m);
                }
                break;
              } // case 82
              case 90: {
                nominatedNodeName_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000010;
                break;
              } // case 90
              case 106: {
                ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus m =
                    input.readMessage(
                        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.parser(),
                        extensionRegistry);
                if (ephemeralContainerStatusesBuilder_ == null) {
                  ensureEphemeralContainerStatusesIsMutable();
                  ephemeralContainerStatuses_.add(m);
                } else {
                  ephemeralContainerStatusesBuilder_.addMessage(m);
                }
                break;
              } // case 106
              case 114: {
                resize_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00002000;
                break;
              } // case 114
              case 130: {
                ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP m =
                    input.readMessage(
                        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP.parser(),
                        extensionRegistry);
                if (hostIpsBuilder_ == null) {
                  ensureHostIpsIsMutable();
                  hostIps_.add(m);
                } else {
                  hostIpsBuilder_.addMessage(m);
                }
                break;
              } // case 130
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object phase_ = "";
      /**
       * <pre>
       * The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
       * The conditions array, the reason and message fields, and the individual container status
       * arrays contain more detail about the pod's status.
       * There are five possible phase values:
       *
       * Pending: The pod has been accepted by the Kubernetes system, but one or more of the
       * container images has not been created. This includes time before being scheduled as
       * well as time spent downloading images over the network, which could take a while.
       * Running: The pod has been bound to a node, and all of the containers have been created.
       * At least one container is still running, or is in the process of starting or restarting.
       * Succeeded: All containers in the pod have terminated in success, and will not be restarted.
       * Failed: All containers in the pod have terminated, and at least one container has
       * terminated in failure. The container either exited with non-zero status or was terminated
       * by the system.
       * Unknown: For some reason the state of the pod could not be obtained, typically due to an
       * error in communicating with the host of the pod.
       *
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
       * +optional
       * </pre>
       *
       * <code>optional string phase = 1 [json_name = "phase"];</code>
       * @return Whether the phase field is set.
       */
      public boolean hasPhase() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
       * The conditions array, the reason and message fields, and the individual container status
       * arrays contain more detail about the pod's status.
       * There are five possible phase values:
       *
       * Pending: The pod has been accepted by the Kubernetes system, but one or more of the
       * container images has not been created. This includes time before being scheduled as
       * well as time spent downloading images over the network, which could take a while.
       * Running: The pod has been bound to a node, and all of the containers have been created.
       * At least one container is still running, or is in the process of starting or restarting.
       * Succeeded: All containers in the pod have terminated in success, and will not be restarted.
       * Failed: All containers in the pod have terminated, and at least one container has
       * terminated in failure. The container either exited with non-zero status or was terminated
       * by the system.
       * Unknown: For some reason the state of the pod could not be obtained, typically due to an
       * error in communicating with the host of the pod.
       *
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
       * +optional
       * </pre>
       *
       * <code>optional string phase = 1 [json_name = "phase"];</code>
       * @return The phase.
       */
      public java.lang.String getPhase() {
        java.lang.Object ref = phase_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          phase_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
       * The conditions array, the reason and message fields, and the individual container status
       * arrays contain more detail about the pod's status.
       * There are five possible phase values:
       *
       * Pending: The pod has been accepted by the Kubernetes system, but one or more of the
       * container images has not been created. This includes time before being scheduled as
       * well as time spent downloading images over the network, which could take a while.
       * Running: The pod has been bound to a node, and all of the containers have been created.
       * At least one container is still running, or is in the process of starting or restarting.
       * Succeeded: All containers in the pod have terminated in success, and will not be restarted.
       * Failed: All containers in the pod have terminated, and at least one container has
       * terminated in failure. The container either exited with non-zero status or was terminated
       * by the system.
       * Unknown: For some reason the state of the pod could not be obtained, typically due to an
       * error in communicating with the host of the pod.
       *
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
       * +optional
       * </pre>
       *
       * <code>optional string phase = 1 [json_name = "phase"];</code>
       * @return The bytes for phase.
       */
      public com.google.protobuf.ByteString
          getPhaseBytes() {
        java.lang.Object ref = phase_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          phase_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
       * The conditions array, the reason and message fields, and the individual container status
       * arrays contain more detail about the pod's status.
       * There are five possible phase values:
       *
       * Pending: The pod has been accepted by the Kubernetes system, but one or more of the
       * container images has not been created. This includes time before being scheduled as
       * well as time spent downloading images over the network, which could take a while.
       * Running: The pod has been bound to a node, and all of the containers have been created.
       * At least one container is still running, or is in the process of starting or restarting.
       * Succeeded: All containers in the pod have terminated in success, and will not be restarted.
       * Failed: All containers in the pod have terminated, and at least one container has
       * terminated in failure. The container either exited with non-zero status or was terminated
       * by the system.
       * Unknown: For some reason the state of the pod could not be obtained, typically due to an
       * error in communicating with the host of the pod.
       *
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
       * +optional
       * </pre>
       *
       * <code>optional string phase = 1 [json_name = "phase"];</code>
       * @param value The phase to set.
       * @return This builder for chaining.
       */
      public Builder setPhase(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        phase_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
       * The conditions array, the reason and message fields, and the individual container status
       * arrays contain more detail about the pod's status.
       * There are five possible phase values:
       *
       * Pending: The pod has been accepted by the Kubernetes system, but one or more of the
       * container images has not been created. This includes time before being scheduled as
       * well as time spent downloading images over the network, which could take a while.
       * Running: The pod has been bound to a node, and all of the containers have been created.
       * At least one container is still running, or is in the process of starting or restarting.
       * Succeeded: All containers in the pod have terminated in success, and will not be restarted.
       * Failed: All containers in the pod have terminated, and at least one container has
       * terminated in failure. The container either exited with non-zero status or was terminated
       * by the system.
       * Unknown: For some reason the state of the pod could not be obtained, typically due to an
       * error in communicating with the host of the pod.
       *
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
       * +optional
       * </pre>
       *
       * <code>optional string phase = 1 [json_name = "phase"];</code>
       * @return This builder for chaining.
       */
      public Builder clearPhase() {
        phase_ = getDefaultInstance().getPhase();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
       * The conditions array, the reason and message fields, and the individual container status
       * arrays contain more detail about the pod's status.
       * There are five possible phase values:
       *
       * Pending: The pod has been accepted by the Kubernetes system, but one or more of the
       * container images has not been created. This includes time before being scheduled as
       * well as time spent downloading images over the network, which could take a while.
       * Running: The pod has been bound to a node, and all of the containers have been created.
       * At least one container is still running, or is in the process of starting or restarting.
       * Succeeded: All containers in the pod have terminated in success, and will not be restarted.
       * Failed: All containers in the pod have terminated, and at least one container has
       * terminated in failure. The container either exited with non-zero status or was terminated
       * by the system.
       * Unknown: For some reason the state of the pod could not be obtained, typically due to an
       * error in communicating with the host of the pod.
       *
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
       * +optional
       * </pre>
       *
       * <code>optional string phase = 1 [json_name = "phase"];</code>
       * @param value The bytes for phase to set.
       * @return This builder for chaining.
       */
      public Builder setPhaseBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        phase_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition> conditions_ =
        java.util.Collections.emptyList();
      private void ensureConditionsIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          conditions_ = new java.util.ArrayList<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition>(conditions_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodConditionOrBuilder> conditionsBuilder_;

      /**
       * <pre>
       * Current service state of pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
       */
      public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition> getConditionsList() {
        if (conditionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(conditions_);
        } else {
          return conditionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Current service state of pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
       */
      public int getConditionsCount() {
        if (conditionsBuilder_ == null) {
          return conditions_.size();
        } else {
          return conditionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Current service state of pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition getConditions(int index) {
        if (conditionsBuilder_ == null) {
          return conditions_.get(index);
        } else {
          return conditionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Current service state of pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
       */
      public Builder setConditions(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.set(index, value);
          onChanged();
        } else {
          conditionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Current service state of pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
       */
      public Builder setConditions(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.set(index, builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Current service state of pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
       */
      public Builder addConditions(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.add(value);
          onChanged();
        } else {
          conditionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Current service state of pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
       */
      public Builder addConditions(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.add(index, value);
          onChanged();
        } else {
          conditionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Current service state of pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
       */
      public Builder addConditions(
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.add(builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Current service state of pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
       */
      public Builder addConditions(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.add(index, builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Current service state of pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
       */
      public Builder addAllConditions(
          java.lang.Iterable<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition> values) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, conditions_);
          onChanged();
        } else {
          conditionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Current service state of pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
       */
      public Builder clearConditions() {
        if (conditionsBuilder_ == null) {
          conditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          conditionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Current service state of pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
       */
      public Builder removeConditions(int index) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.remove(index);
          onChanged();
        } else {
          conditionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Current service state of pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition.Builder getConditionsBuilder(
          int index) {
        return getConditionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Current service state of pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodConditionOrBuilder getConditionsOrBuilder(
          int index) {
        if (conditionsBuilder_ == null) {
          return conditions_.get(index);  } else {
          return conditionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Current service state of pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
       */
      public java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodConditionOrBuilder> 
           getConditionsOrBuilderList() {
        if (conditionsBuilder_ != null) {
          return conditionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(conditions_);
        }
      }
      /**
       * <pre>
       * Current service state of pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition.Builder addConditionsBuilder() {
        return getConditionsFieldBuilder().addBuilder(
            ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * Current service state of pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition.Builder addConditionsBuilder(
          int index) {
        return getConditionsFieldBuilder().addBuilder(
            index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * Current service state of pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.PodCondition conditions = 2 [json_name = "conditions"];</code>
       */
      public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition.Builder> 
           getConditionsBuilderList() {
        return getConditionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodConditionOrBuilder> 
          getConditionsFieldBuilder() {
        if (conditionsBuilder_ == null) {
          conditionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodCondition.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodConditionOrBuilder>(
                  conditions_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          conditions_ = null;
        }
        return conditionsBuilder_;
      }

      private java.lang.Object message_ = "";
      /**
       * <pre>
       * A human readable message indicating details about why the pod is in this condition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 3 [json_name = "message"];</code>
       * @return Whether the message field is set.
       */
      public boolean hasMessage() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * A human readable message indicating details about why the pod is in this condition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 3 [json_name = "message"];</code>
       * @return The message.
       */
      public java.lang.String getMessage() {
        java.lang.Object ref = message_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          message_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A human readable message indicating details about why the pod is in this condition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 3 [json_name = "message"];</code>
       * @return The bytes for message.
       */
      public com.google.protobuf.ByteString
          getMessageBytes() {
        java.lang.Object ref = message_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          message_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A human readable message indicating details about why the pod is in this condition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 3 [json_name = "message"];</code>
       * @param value The message to set.
       * @return This builder for chaining.
       */
      public Builder setMessage(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        message_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human readable message indicating details about why the pod is in this condition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 3 [json_name = "message"];</code>
       * @return This builder for chaining.
       */
      public Builder clearMessage() {
        message_ = getDefaultInstance().getMessage();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human readable message indicating details about why the pod is in this condition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 3 [json_name = "message"];</code>
       * @param value The bytes for message to set.
       * @return This builder for chaining.
       */
      public Builder setMessageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        message_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private java.lang.Object reason_ = "";
      /**
       * <pre>
       * A brief CamelCase message indicating details about why the pod is in this state.
       * e.g. 'Evicted'
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4 [json_name = "reason"];</code>
       * @return Whether the reason field is set.
       */
      public boolean hasReason() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * A brief CamelCase message indicating details about why the pod is in this state.
       * e.g. 'Evicted'
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4 [json_name = "reason"];</code>
       * @return The reason.
       */
      public java.lang.String getReason() {
        java.lang.Object ref = reason_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          reason_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A brief CamelCase message indicating details about why the pod is in this state.
       * e.g. 'Evicted'
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4 [json_name = "reason"];</code>
       * @return The bytes for reason.
       */
      public com.google.protobuf.ByteString
          getReasonBytes() {
        java.lang.Object ref = reason_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          reason_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A brief CamelCase message indicating details about why the pod is in this state.
       * e.g. 'Evicted'
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4 [json_name = "reason"];</code>
       * @param value The reason to set.
       * @return This builder for chaining.
       */
      public Builder setReason(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        reason_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A brief CamelCase message indicating details about why the pod is in this state.
       * e.g. 'Evicted'
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4 [json_name = "reason"];</code>
       * @return This builder for chaining.
       */
      public Builder clearReason() {
        reason_ = getDefaultInstance().getReason();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A brief CamelCase message indicating details about why the pod is in this state.
       * e.g. 'Evicted'
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4 [json_name = "reason"];</code>
       * @param value The bytes for reason to set.
       * @return This builder for chaining.
       */
      public Builder setReasonBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        reason_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private java.lang.Object nominatedNodeName_ = "";
      /**
       * <pre>
       * nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be
       * scheduled right away as preemption victims receive their graceful termination periods.
       * This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide
       * to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to
       * give the resources on this node to a higher priority pod that is created after preemption.
       * As a result, this field may be different than PodSpec.nodeName when the pod is
       * scheduled.
       * +optional
       * </pre>
       *
       * <code>optional string nominated_node_name = 11 [json_name = "nominatedNodeName"];</code>
       * @return Whether the nominatedNodeName field is set.
       */
      public boolean hasNominatedNodeName() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be
       * scheduled right away as preemption victims receive their graceful termination periods.
       * This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide
       * to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to
       * give the resources on this node to a higher priority pod that is created after preemption.
       * As a result, this field may be different than PodSpec.nodeName when the pod is
       * scheduled.
       * +optional
       * </pre>
       *
       * <code>optional string nominated_node_name = 11 [json_name = "nominatedNodeName"];</code>
       * @return The nominatedNodeName.
       */
      public java.lang.String getNominatedNodeName() {
        java.lang.Object ref = nominatedNodeName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          nominatedNodeName_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be
       * scheduled right away as preemption victims receive their graceful termination periods.
       * This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide
       * to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to
       * give the resources on this node to a higher priority pod that is created after preemption.
       * As a result, this field may be different than PodSpec.nodeName when the pod is
       * scheduled.
       * +optional
       * </pre>
       *
       * <code>optional string nominated_node_name = 11 [json_name = "nominatedNodeName"];</code>
       * @return The bytes for nominatedNodeName.
       */
      public com.google.protobuf.ByteString
          getNominatedNodeNameBytes() {
        java.lang.Object ref = nominatedNodeName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          nominatedNodeName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be
       * scheduled right away as preemption victims receive their graceful termination periods.
       * This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide
       * to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to
       * give the resources on this node to a higher priority pod that is created after preemption.
       * As a result, this field may be different than PodSpec.nodeName when the pod is
       * scheduled.
       * +optional
       * </pre>
       *
       * <code>optional string nominated_node_name = 11 [json_name = "nominatedNodeName"];</code>
       * @param value The nominatedNodeName to set.
       * @return This builder for chaining.
       */
      public Builder setNominatedNodeName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        nominatedNodeName_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be
       * scheduled right away as preemption victims receive their graceful termination periods.
       * This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide
       * to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to
       * give the resources on this node to a higher priority pod that is created after preemption.
       * As a result, this field may be different than PodSpec.nodeName when the pod is
       * scheduled.
       * +optional
       * </pre>
       *
       * <code>optional string nominated_node_name = 11 [json_name = "nominatedNodeName"];</code>
       * @return This builder for chaining.
       */
      public Builder clearNominatedNodeName() {
        nominatedNodeName_ = getDefaultInstance().getNominatedNodeName();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be
       * scheduled right away as preemption victims receive their graceful termination periods.
       * This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide
       * to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to
       * give the resources on this node to a higher priority pod that is created after preemption.
       * As a result, this field may be different than PodSpec.nodeName when the pod is
       * scheduled.
       * +optional
       * </pre>
       *
       * <code>optional string nominated_node_name = 11 [json_name = "nominatedNodeName"];</code>
       * @param value The bytes for nominatedNodeName to set.
       * @return This builder for chaining.
       */
      public Builder setNominatedNodeNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        nominatedNodeName_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      private java.lang.Object hostIp_ = "";
      /**
       * <pre>
       * hostIP holds the IP address of the host to which the pod is assigned. Empty if the pod has not started yet.
       * A pod can be assigned to a node that has a problem in kubelet which in turns mean that HostIP will
       * not be updated even if there is a node is assigned to pod
       * +optional
       * </pre>
       *
       * <code>optional string host_ip = 5 [json_name = "hostIp"];</code>
       * @return Whether the hostIp field is set.
       */
      public boolean hasHostIp() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * hostIP holds the IP address of the host to which the pod is assigned. Empty if the pod has not started yet.
       * A pod can be assigned to a node that has a problem in kubelet which in turns mean that HostIP will
       * not be updated even if there is a node is assigned to pod
       * +optional
       * </pre>
       *
       * <code>optional string host_ip = 5 [json_name = "hostIp"];</code>
       * @return The hostIp.
       */
      public java.lang.String getHostIp() {
        java.lang.Object ref = hostIp_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          hostIp_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * hostIP holds the IP address of the host to which the pod is assigned. Empty if the pod has not started yet.
       * A pod can be assigned to a node that has a problem in kubelet which in turns mean that HostIP will
       * not be updated even if there is a node is assigned to pod
       * +optional
       * </pre>
       *
       * <code>optional string host_ip = 5 [json_name = "hostIp"];</code>
       * @return The bytes for hostIp.
       */
      public com.google.protobuf.ByteString
          getHostIpBytes() {
        java.lang.Object ref = hostIp_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          hostIp_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * hostIP holds the IP address of the host to which the pod is assigned. Empty if the pod has not started yet.
       * A pod can be assigned to a node that has a problem in kubelet which in turns mean that HostIP will
       * not be updated even if there is a node is assigned to pod
       * +optional
       * </pre>
       *
       * <code>optional string host_ip = 5 [json_name = "hostIp"];</code>
       * @param value The hostIp to set.
       * @return This builder for chaining.
       */
      public Builder setHostIp(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        hostIp_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * hostIP holds the IP address of the host to which the pod is assigned. Empty if the pod has not started yet.
       * A pod can be assigned to a node that has a problem in kubelet which in turns mean that HostIP will
       * not be updated even if there is a node is assigned to pod
       * +optional
       * </pre>
       *
       * <code>optional string host_ip = 5 [json_name = "hostIp"];</code>
       * @return This builder for chaining.
       */
      public Builder clearHostIp() {
        hostIp_ = getDefaultInstance().getHostIp();
        bitField0_ = (bitField0_ & ~0x00000020);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * hostIP holds the IP address of the host to which the pod is assigned. Empty if the pod has not started yet.
       * A pod can be assigned to a node that has a problem in kubelet which in turns mean that HostIP will
       * not be updated even if there is a node is assigned to pod
       * +optional
       * </pre>
       *
       * <code>optional string host_ip = 5 [json_name = "hostIp"];</code>
       * @param value The bytes for hostIp to set.
       * @return This builder for chaining.
       */
      public Builder setHostIpBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        hostIp_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }

      private java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP> hostIps_ =
        java.util.Collections.emptyList();
      private void ensureHostIpsIsMutable() {
        if (!((bitField0_ & 0x00000040) != 0)) {
          hostIps_ = new java.util.ArrayList<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP>(hostIps_);
          bitField0_ |= 0x00000040;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIPOrBuilder> hostIpsBuilder_;

      /**
       * <pre>
       * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
       * match the hostIP field. This list is empty if the pod has not started yet.
       * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
       * not be updated even if there is a node is assigned to this pod.
       * +optional
       * +patchStrategy=merge
       * +patchMergeKey=ip
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
       */
      public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP> getHostIpsList() {
        if (hostIpsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(hostIps_);
        } else {
          return hostIpsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
       * match the hostIP field. This list is empty if the pod has not started yet.
       * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
       * not be updated even if there is a node is assigned to this pod.
       * +optional
       * +patchStrategy=merge
       * +patchMergeKey=ip
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
       */
      public int getHostIpsCount() {
        if (hostIpsBuilder_ == null) {
          return hostIps_.size();
        } else {
          return hostIpsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
       * match the hostIP field. This list is empty if the pod has not started yet.
       * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
       * not be updated even if there is a node is assigned to this pod.
       * +optional
       * +patchStrategy=merge
       * +patchMergeKey=ip
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP getHostIps(int index) {
        if (hostIpsBuilder_ == null) {
          return hostIps_.get(index);
        } else {
          return hostIpsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
       * match the hostIP field. This list is empty if the pod has not started yet.
       * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
       * not be updated even if there is a node is assigned to this pod.
       * +optional
       * +patchStrategy=merge
       * +patchMergeKey=ip
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
       */
      public Builder setHostIps(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP value) {
        if (hostIpsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureHostIpsIsMutable();
          hostIps_.set(index, value);
          onChanged();
        } else {
          hostIpsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
       * match the hostIP field. This list is empty if the pod has not started yet.
       * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
       * not be updated even if there is a node is assigned to this pod.
       * +optional
       * +patchStrategy=merge
       * +patchMergeKey=ip
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
       */
      public Builder setHostIps(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP.Builder builderForValue) {
        if (hostIpsBuilder_ == null) {
          ensureHostIpsIsMutable();
          hostIps_.set(index, builderForValue.build());
          onChanged();
        } else {
          hostIpsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
       * match the hostIP field. This list is empty if the pod has not started yet.
       * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
       * not be updated even if there is a node is assigned to this pod.
       * +optional
       * +patchStrategy=merge
       * +patchMergeKey=ip
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
       */
      public Builder addHostIps(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP value) {
        if (hostIpsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureHostIpsIsMutable();
          hostIps_.add(value);
          onChanged();
        } else {
          hostIpsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
       * match the hostIP field. This list is empty if the pod has not started yet.
       * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
       * not be updated even if there is a node is assigned to this pod.
       * +optional
       * +patchStrategy=merge
       * +patchMergeKey=ip
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
       */
      public Builder addHostIps(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP value) {
        if (hostIpsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureHostIpsIsMutable();
          hostIps_.add(index, value);
          onChanged();
        } else {
          hostIpsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
       * match the hostIP field. This list is empty if the pod has not started yet.
       * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
       * not be updated even if there is a node is assigned to this pod.
       * +optional
       * +patchStrategy=merge
       * +patchMergeKey=ip
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
       */
      public Builder addHostIps(
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP.Builder builderForValue) {
        if (hostIpsBuilder_ == null) {
          ensureHostIpsIsMutable();
          hostIps_.add(builderForValue.build());
          onChanged();
        } else {
          hostIpsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
       * match the hostIP field. This list is empty if the pod has not started yet.
       * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
       * not be updated even if there is a node is assigned to this pod.
       * +optional
       * +patchStrategy=merge
       * +patchMergeKey=ip
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
       */
      public Builder addHostIps(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP.Builder builderForValue) {
        if (hostIpsBuilder_ == null) {
          ensureHostIpsIsMutable();
          hostIps_.add(index, builderForValue.build());
          onChanged();
        } else {
          hostIpsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
       * match the hostIP field. This list is empty if the pod has not started yet.
       * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
       * not be updated even if there is a node is assigned to this pod.
       * +optional
       * +patchStrategy=merge
       * +patchMergeKey=ip
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
       */
      public Builder addAllHostIps(
          java.lang.Iterable<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP> values) {
        if (hostIpsBuilder_ == null) {
          ensureHostIpsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, hostIps_);
          onChanged();
        } else {
          hostIpsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
       * match the hostIP field. This list is empty if the pod has not started yet.
       * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
       * not be updated even if there is a node is assigned to this pod.
       * +optional
       * +patchStrategy=merge
       * +patchMergeKey=ip
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
       */
      public Builder clearHostIps() {
        if (hostIpsBuilder_ == null) {
          hostIps_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000040);
          onChanged();
        } else {
          hostIpsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
       * match the hostIP field. This list is empty if the pod has not started yet.
       * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
       * not be updated even if there is a node is assigned to this pod.
       * +optional
       * +patchStrategy=merge
       * +patchMergeKey=ip
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
       */
      public Builder removeHostIps(int index) {
        if (hostIpsBuilder_ == null) {
          ensureHostIpsIsMutable();
          hostIps_.remove(index);
          onChanged();
        } else {
          hostIpsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
       * match the hostIP field. This list is empty if the pod has not started yet.
       * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
       * not be updated even if there is a node is assigned to this pod.
       * +optional
       * +patchStrategy=merge
       * +patchMergeKey=ip
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP.Builder getHostIpsBuilder(
          int index) {
        return getHostIpsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
       * match the hostIP field. This list is empty if the pod has not started yet.
       * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
       * not be updated even if there is a node is assigned to this pod.
       * +optional
       * +patchStrategy=merge
       * +patchMergeKey=ip
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIPOrBuilder getHostIpsOrBuilder(
          int index) {
        if (hostIpsBuilder_ == null) {
          return hostIps_.get(index);  } else {
          return hostIpsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
       * match the hostIP field. This list is empty if the pod has not started yet.
       * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
       * not be updated even if there is a node is assigned to this pod.
       * +optional
       * +patchStrategy=merge
       * +patchMergeKey=ip
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
       */
      public java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIPOrBuilder> 
           getHostIpsOrBuilderList() {
        if (hostIpsBuilder_ != null) {
          return hostIpsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(hostIps_);
        }
      }
      /**
       * <pre>
       * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
       * match the hostIP field. This list is empty if the pod has not started yet.
       * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
       * not be updated even if there is a node is assigned to this pod.
       * +optional
       * +patchStrategy=merge
       * +patchMergeKey=ip
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP.Builder addHostIpsBuilder() {
        return getHostIpsFieldBuilder().addBuilder(
            ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP.getDefaultInstance());
      }
      /**
       * <pre>
       * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
       * match the hostIP field. This list is empty if the pod has not started yet.
       * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
       * not be updated even if there is a node is assigned to this pod.
       * +optional
       * +patchStrategy=merge
       * +patchMergeKey=ip
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP.Builder addHostIpsBuilder(
          int index) {
        return getHostIpsFieldBuilder().addBuilder(
            index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP.getDefaultInstance());
      }
      /**
       * <pre>
       * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
       * match the hostIP field. This list is empty if the pod has not started yet.
       * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
       * not be updated even if there is a node is assigned to this pod.
       * +optional
       * +patchStrategy=merge
       * +patchMergeKey=ip
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.HostIP host_ips = 16 [json_name = "hostIps"];</code>
       */
      public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP.Builder> 
           getHostIpsBuilderList() {
        return getHostIpsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIPOrBuilder> 
          getHostIpsFieldBuilder() {
        if (hostIpsBuilder_ == null) {
          hostIpsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIP.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.HostIPOrBuilder>(
                  hostIps_,
                  ((bitField0_ & 0x00000040) != 0),
                  getParentForChildren(),
                  isClean());
          hostIps_ = null;
        }
        return hostIpsBuilder_;
      }

      private java.lang.Object podIp_ = "";
      /**
       * <pre>
       * podIP address allocated to the pod. Routable at least within the cluster.
       * Empty if not yet allocated.
       * +optional
       * </pre>
       *
       * <code>optional string pod_ip = 6 [json_name = "podIp"];</code>
       * @return Whether the podIp field is set.
       */
      public boolean hasPodIp() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * podIP address allocated to the pod. Routable at least within the cluster.
       * Empty if not yet allocated.
       * +optional
       * </pre>
       *
       * <code>optional string pod_ip = 6 [json_name = "podIp"];</code>
       * @return The podIp.
       */
      public java.lang.String getPodIp() {
        java.lang.Object ref = podIp_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          podIp_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * podIP address allocated to the pod. Routable at least within the cluster.
       * Empty if not yet allocated.
       * +optional
       * </pre>
       *
       * <code>optional string pod_ip = 6 [json_name = "podIp"];</code>
       * @return The bytes for podIp.
       */
      public com.google.protobuf.ByteString
          getPodIpBytes() {
        java.lang.Object ref = podIp_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          podIp_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * podIP address allocated to the pod. Routable at least within the cluster.
       * Empty if not yet allocated.
       * +optional
       * </pre>
       *
       * <code>optional string pod_ip = 6 [json_name = "podIp"];</code>
       * @param value The podIp to set.
       * @return This builder for chaining.
       */
      public Builder setPodIp(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        podIp_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * podIP address allocated to the pod. Routable at least within the cluster.
       * Empty if not yet allocated.
       * +optional
       * </pre>
       *
       * <code>optional string pod_ip = 6 [json_name = "podIp"];</code>
       * @return This builder for chaining.
       */
      public Builder clearPodIp() {
        podIp_ = getDefaultInstance().getPodIp();
        bitField0_ = (bitField0_ & ~0x00000080);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * podIP address allocated to the pod. Routable at least within the cluster.
       * Empty if not yet allocated.
       * +optional
       * </pre>
       *
       * <code>optional string pod_ip = 6 [json_name = "podIp"];</code>
       * @param value The bytes for podIp to set.
       * @return This builder for chaining.
       */
      public Builder setPodIpBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        podIp_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }

      private long startTime_ ;
      /**
       * <pre>
       * RFC 3339 date and time at which the object was acknowledged by the Kubelet.
       * This is before the Kubelet pulled the container image(s) for the pod.
       * +optional
       * </pre>
       *
       * <code>optional int64 start_time = 7 [json_name = "startTime", (.gen_bq_schema.bigquery) = { ... }</code>
       * @return Whether the startTime field is set.
       */
      @java.lang.Override
      public boolean hasStartTime() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * RFC 3339 date and time at which the object was acknowledged by the Kubelet.
       * This is before the Kubelet pulled the container image(s) for the pod.
       * +optional
       * </pre>
       *
       * <code>optional int64 start_time = 7 [json_name = "startTime", (.gen_bq_schema.bigquery) = { ... }</code>
       * @return The startTime.
       */
      @java.lang.Override
      public long getStartTime() {
        return startTime_;
      }
      /**
       * <pre>
       * RFC 3339 date and time at which the object was acknowledged by the Kubelet.
       * This is before the Kubelet pulled the container image(s) for the pod.
       * +optional
       * </pre>
       *
       * <code>optional int64 start_time = 7 [json_name = "startTime", (.gen_bq_schema.bigquery) = { ... }</code>
       * @param value The startTime to set.
       * @return This builder for chaining.
       */
      public Builder setStartTime(long value) {

        startTime_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * RFC 3339 date and time at which the object was acknowledged by the Kubelet.
       * This is before the Kubelet pulled the container image(s) for the pod.
       * +optional
       * </pre>
       *
       * <code>optional int64 start_time = 7 [json_name = "startTime", (.gen_bq_schema.bigquery) = { ... }</code>
       * @return This builder for chaining.
       */
      public Builder clearStartTime() {
        bitField0_ = (bitField0_ & ~0x00000100);
        startTime_ = 0L;
        onChanged();
        return this;
      }

      private java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus> initContainerStatuses_ =
        java.util.Collections.emptyList();
      private void ensureInitContainerStatusesIsMutable() {
        if (!((bitField0_ & 0x00000200) != 0)) {
          initContainerStatuses_ = new java.util.ArrayList<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus>(initContainerStatuses_);
          bitField0_ |= 0x00000200;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder> initContainerStatusesBuilder_;

      /**
       * <pre>
       * The list has one entry per init container in the manifest. The most recent successful
       * init container will have ready = true, the most recently started container will have
       * startTime set.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
       */
      public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus> getInitContainerStatusesList() {
        if (initContainerStatusesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(initContainerStatuses_);
        } else {
          return initContainerStatusesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The list has one entry per init container in the manifest. The most recent successful
       * init container will have ready = true, the most recently started container will have
       * startTime set.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
       */
      public int getInitContainerStatusesCount() {
        if (initContainerStatusesBuilder_ == null) {
          return initContainerStatuses_.size();
        } else {
          return initContainerStatusesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The list has one entry per init container in the manifest. The most recent successful
       * init container will have ready = true, the most recently started container will have
       * startTime set.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus getInitContainerStatuses(int index) {
        if (initContainerStatusesBuilder_ == null) {
          return initContainerStatuses_.get(index);
        } else {
          return initContainerStatusesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The list has one entry per init container in the manifest. The most recent successful
       * init container will have ready = true, the most recently started container will have
       * startTime set.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
       */
      public Builder setInitContainerStatuses(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus value) {
        if (initContainerStatusesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInitContainerStatusesIsMutable();
          initContainerStatuses_.set(index, value);
          onChanged();
        } else {
          initContainerStatusesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The list has one entry per init container in the manifest. The most recent successful
       * init container will have ready = true, the most recently started container will have
       * startTime set.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
       */
      public Builder setInitContainerStatuses(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder builderForValue) {
        if (initContainerStatusesBuilder_ == null) {
          ensureInitContainerStatusesIsMutable();
          initContainerStatuses_.set(index, builderForValue.build());
          onChanged();
        } else {
          initContainerStatusesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The list has one entry per init container in the manifest. The most recent successful
       * init container will have ready = true, the most recently started container will have
       * startTime set.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
       */
      public Builder addInitContainerStatuses(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus value) {
        if (initContainerStatusesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInitContainerStatusesIsMutable();
          initContainerStatuses_.add(value);
          onChanged();
        } else {
          initContainerStatusesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The list has one entry per init container in the manifest. The most recent successful
       * init container will have ready = true, the most recently started container will have
       * startTime set.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
       */
      public Builder addInitContainerStatuses(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus value) {
        if (initContainerStatusesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInitContainerStatusesIsMutable();
          initContainerStatuses_.add(index, value);
          onChanged();
        } else {
          initContainerStatusesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The list has one entry per init container in the manifest. The most recent successful
       * init container will have ready = true, the most recently started container will have
       * startTime set.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
       */
      public Builder addInitContainerStatuses(
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder builderForValue) {
        if (initContainerStatusesBuilder_ == null) {
          ensureInitContainerStatusesIsMutable();
          initContainerStatuses_.add(builderForValue.build());
          onChanged();
        } else {
          initContainerStatusesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The list has one entry per init container in the manifest. The most recent successful
       * init container will have ready = true, the most recently started container will have
       * startTime set.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
       */
      public Builder addInitContainerStatuses(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder builderForValue) {
        if (initContainerStatusesBuilder_ == null) {
          ensureInitContainerStatusesIsMutable();
          initContainerStatuses_.add(index, builderForValue.build());
          onChanged();
        } else {
          initContainerStatusesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The list has one entry per init container in the manifest. The most recent successful
       * init container will have ready = true, the most recently started container will have
       * startTime set.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
       */
      public Builder addAllInitContainerStatuses(
          java.lang.Iterable<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus> values) {
        if (initContainerStatusesBuilder_ == null) {
          ensureInitContainerStatusesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, initContainerStatuses_);
          onChanged();
        } else {
          initContainerStatusesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The list has one entry per init container in the manifest. The most recent successful
       * init container will have ready = true, the most recently started container will have
       * startTime set.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
       */
      public Builder clearInitContainerStatuses() {
        if (initContainerStatusesBuilder_ == null) {
          initContainerStatuses_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000200);
          onChanged();
        } else {
          initContainerStatusesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The list has one entry per init container in the manifest. The most recent successful
       * init container will have ready = true, the most recently started container will have
       * startTime set.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
       */
      public Builder removeInitContainerStatuses(int index) {
        if (initContainerStatusesBuilder_ == null) {
          ensureInitContainerStatusesIsMutable();
          initContainerStatuses_.remove(index);
          onChanged();
        } else {
          initContainerStatusesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The list has one entry per init container in the manifest. The most recent successful
       * init container will have ready = true, the most recently started container will have
       * startTime set.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder getInitContainerStatusesBuilder(
          int index) {
        return getInitContainerStatusesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The list has one entry per init container in the manifest. The most recent successful
       * init container will have ready = true, the most recently started container will have
       * startTime set.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder getInitContainerStatusesOrBuilder(
          int index) {
        if (initContainerStatusesBuilder_ == null) {
          return initContainerStatuses_.get(index);  } else {
          return initContainerStatusesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The list has one entry per init container in the manifest. The most recent successful
       * init container will have ready = true, the most recently started container will have
       * startTime set.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
       */
      public java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder> 
           getInitContainerStatusesOrBuilderList() {
        if (initContainerStatusesBuilder_ != null) {
          return initContainerStatusesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(initContainerStatuses_);
        }
      }
      /**
       * <pre>
       * The list has one entry per init container in the manifest. The most recent successful
       * init container will have ready = true, the most recently started container will have
       * startTime set.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder addInitContainerStatusesBuilder() {
        return getInitContainerStatusesFieldBuilder().addBuilder(
            ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.getDefaultInstance());
      }
      /**
       * <pre>
       * The list has one entry per init container in the manifest. The most recent successful
       * init container will have ready = true, the most recently started container will have
       * startTime set.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder addInitContainerStatusesBuilder(
          int index) {
        return getInitContainerStatusesFieldBuilder().addBuilder(
            index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.getDefaultInstance());
      }
      /**
       * <pre>
       * The list has one entry per init container in the manifest. The most recent successful
       * init container will have ready = true, the most recently started container will have
       * startTime set.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus init_container_statuses = 10 [json_name = "initContainerStatuses"];</code>
       */
      public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder> 
           getInitContainerStatusesBuilderList() {
        return getInitContainerStatusesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder> 
          getInitContainerStatusesFieldBuilder() {
        if (initContainerStatusesBuilder_ == null) {
          initContainerStatusesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder>(
                  initContainerStatuses_,
                  ((bitField0_ & 0x00000200) != 0),
                  getParentForChildren(),
                  isClean());
          initContainerStatuses_ = null;
        }
        return initContainerStatusesBuilder_;
      }

      private java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus> containerStatuses_ =
        java.util.Collections.emptyList();
      private void ensureContainerStatusesIsMutable() {
        if (!((bitField0_ & 0x00000400) != 0)) {
          containerStatuses_ = new java.util.ArrayList<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus>(containerStatuses_);
          bitField0_ |= 0x00000400;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder> containerStatusesBuilder_;

      /**
       * <pre>
       * The list has one entry per container in the manifest.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
       */
      public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus> getContainerStatusesList() {
        if (containerStatusesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(containerStatuses_);
        } else {
          return containerStatusesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The list has one entry per container in the manifest.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
       */
      public int getContainerStatusesCount() {
        if (containerStatusesBuilder_ == null) {
          return containerStatuses_.size();
        } else {
          return containerStatusesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The list has one entry per container in the manifest.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus getContainerStatuses(int index) {
        if (containerStatusesBuilder_ == null) {
          return containerStatuses_.get(index);
        } else {
          return containerStatusesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The list has one entry per container in the manifest.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
       */
      public Builder setContainerStatuses(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus value) {
        if (containerStatusesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureContainerStatusesIsMutable();
          containerStatuses_.set(index, value);
          onChanged();
        } else {
          containerStatusesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The list has one entry per container in the manifest.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
       */
      public Builder setContainerStatuses(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder builderForValue) {
        if (containerStatusesBuilder_ == null) {
          ensureContainerStatusesIsMutable();
          containerStatuses_.set(index, builderForValue.build());
          onChanged();
        } else {
          containerStatusesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The list has one entry per container in the manifest.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
       */
      public Builder addContainerStatuses(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus value) {
        if (containerStatusesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureContainerStatusesIsMutable();
          containerStatuses_.add(value);
          onChanged();
        } else {
          containerStatusesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The list has one entry per container in the manifest.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
       */
      public Builder addContainerStatuses(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus value) {
        if (containerStatusesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureContainerStatusesIsMutable();
          containerStatuses_.add(index, value);
          onChanged();
        } else {
          containerStatusesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The list has one entry per container in the manifest.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
       */
      public Builder addContainerStatuses(
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder builderForValue) {
        if (containerStatusesBuilder_ == null) {
          ensureContainerStatusesIsMutable();
          containerStatuses_.add(builderForValue.build());
          onChanged();
        } else {
          containerStatusesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The list has one entry per container in the manifest.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
       */
      public Builder addContainerStatuses(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder builderForValue) {
        if (containerStatusesBuilder_ == null) {
          ensureContainerStatusesIsMutable();
          containerStatuses_.add(index, builderForValue.build());
          onChanged();
        } else {
          containerStatusesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The list has one entry per container in the manifest.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
       */
      public Builder addAllContainerStatuses(
          java.lang.Iterable<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus> values) {
        if (containerStatusesBuilder_ == null) {
          ensureContainerStatusesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, containerStatuses_);
          onChanged();
        } else {
          containerStatusesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The list has one entry per container in the manifest.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
       */
      public Builder clearContainerStatuses() {
        if (containerStatusesBuilder_ == null) {
          containerStatuses_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000400);
          onChanged();
        } else {
          containerStatusesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The list has one entry per container in the manifest.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
       */
      public Builder removeContainerStatuses(int index) {
        if (containerStatusesBuilder_ == null) {
          ensureContainerStatusesIsMutable();
          containerStatuses_.remove(index);
          onChanged();
        } else {
          containerStatusesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The list has one entry per container in the manifest.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder getContainerStatusesBuilder(
          int index) {
        return getContainerStatusesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The list has one entry per container in the manifest.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder getContainerStatusesOrBuilder(
          int index) {
        if (containerStatusesBuilder_ == null) {
          return containerStatuses_.get(index);  } else {
          return containerStatusesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The list has one entry per container in the manifest.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
       */
      public java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder> 
           getContainerStatusesOrBuilderList() {
        if (containerStatusesBuilder_ != null) {
          return containerStatusesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(containerStatuses_);
        }
      }
      /**
       * <pre>
       * The list has one entry per container in the manifest.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder addContainerStatusesBuilder() {
        return getContainerStatusesFieldBuilder().addBuilder(
            ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.getDefaultInstance());
      }
      /**
       * <pre>
       * The list has one entry per container in the manifest.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder addContainerStatusesBuilder(
          int index) {
        return getContainerStatusesFieldBuilder().addBuilder(
            index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.getDefaultInstance());
      }
      /**
       * <pre>
       * The list has one entry per container in the manifest.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus container_statuses = 8 [json_name = "containerStatuses"];</code>
       */
      public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder> 
           getContainerStatusesBuilderList() {
        return getContainerStatusesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder> 
          getContainerStatusesFieldBuilder() {
        if (containerStatusesBuilder_ == null) {
          containerStatusesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder>(
                  containerStatuses_,
                  ((bitField0_ & 0x00000400) != 0),
                  getParentForChildren(),
                  isClean());
          containerStatuses_ = null;
        }
        return containerStatusesBuilder_;
      }

      private java.lang.Object qosClass_ = "";
      /**
       * <pre>
       * The Quality of Service (QOS) classification assigned to the pod based on resource requirements
       * See PodQOSClass type for available QOS classes
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#quality-of-service-classes
       * +optional
       * </pre>
       *
       * <code>optional string qos_class = 9 [json_name = "qosClass"];</code>
       * @return Whether the qosClass field is set.
       */
      public boolean hasQosClass() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <pre>
       * The Quality of Service (QOS) classification assigned to the pod based on resource requirements
       * See PodQOSClass type for available QOS classes
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#quality-of-service-classes
       * +optional
       * </pre>
       *
       * <code>optional string qos_class = 9 [json_name = "qosClass"];</code>
       * @return The qosClass.
       */
      public java.lang.String getQosClass() {
        java.lang.Object ref = qosClass_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          qosClass_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The Quality of Service (QOS) classification assigned to the pod based on resource requirements
       * See PodQOSClass type for available QOS classes
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#quality-of-service-classes
       * +optional
       * </pre>
       *
       * <code>optional string qos_class = 9 [json_name = "qosClass"];</code>
       * @return The bytes for qosClass.
       */
      public com.google.protobuf.ByteString
          getQosClassBytes() {
        java.lang.Object ref = qosClass_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          qosClass_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The Quality of Service (QOS) classification assigned to the pod based on resource requirements
       * See PodQOSClass type for available QOS classes
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#quality-of-service-classes
       * +optional
       * </pre>
       *
       * <code>optional string qos_class = 9 [json_name = "qosClass"];</code>
       * @param value The qosClass to set.
       * @return This builder for chaining.
       */
      public Builder setQosClass(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        qosClass_ = value;
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The Quality of Service (QOS) classification assigned to the pod based on resource requirements
       * See PodQOSClass type for available QOS classes
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#quality-of-service-classes
       * +optional
       * </pre>
       *
       * <code>optional string qos_class = 9 [json_name = "qosClass"];</code>
       * @return This builder for chaining.
       */
      public Builder clearQosClass() {
        qosClass_ = getDefaultInstance().getQosClass();
        bitField0_ = (bitField0_ & ~0x00000800);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The Quality of Service (QOS) classification assigned to the pod based on resource requirements
       * See PodQOSClass type for available QOS classes
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#quality-of-service-classes
       * +optional
       * </pre>
       *
       * <code>optional string qos_class = 9 [json_name = "qosClass"];</code>
       * @param value The bytes for qosClass to set.
       * @return This builder for chaining.
       */
      public Builder setQosClassBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        qosClass_ = value;
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }

      private java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus> ephemeralContainerStatuses_ =
        java.util.Collections.emptyList();
      private void ensureEphemeralContainerStatusesIsMutable() {
        if (!((bitField0_ & 0x00001000) != 0)) {
          ephemeralContainerStatuses_ = new java.util.ArrayList<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus>(ephemeralContainerStatuses_);
          bitField0_ |= 0x00001000;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder> ephemeralContainerStatusesBuilder_;

      /**
       * <pre>
       * Status for any ephemeral containers that have run in this pod.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
       */
      public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus> getEphemeralContainerStatusesList() {
        if (ephemeralContainerStatusesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(ephemeralContainerStatuses_);
        } else {
          return ephemeralContainerStatusesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Status for any ephemeral containers that have run in this pod.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
       */
      public int getEphemeralContainerStatusesCount() {
        if (ephemeralContainerStatusesBuilder_ == null) {
          return ephemeralContainerStatuses_.size();
        } else {
          return ephemeralContainerStatusesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Status for any ephemeral containers that have run in this pod.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus getEphemeralContainerStatuses(int index) {
        if (ephemeralContainerStatusesBuilder_ == null) {
          return ephemeralContainerStatuses_.get(index);
        } else {
          return ephemeralContainerStatusesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Status for any ephemeral containers that have run in this pod.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
       */
      public Builder setEphemeralContainerStatuses(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus value) {
        if (ephemeralContainerStatusesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEphemeralContainerStatusesIsMutable();
          ephemeralContainerStatuses_.set(index, value);
          onChanged();
        } else {
          ephemeralContainerStatusesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Status for any ephemeral containers that have run in this pod.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
       */
      public Builder setEphemeralContainerStatuses(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder builderForValue) {
        if (ephemeralContainerStatusesBuilder_ == null) {
          ensureEphemeralContainerStatusesIsMutable();
          ephemeralContainerStatuses_.set(index, builderForValue.build());
          onChanged();
        } else {
          ephemeralContainerStatusesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Status for any ephemeral containers that have run in this pod.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
       */
      public Builder addEphemeralContainerStatuses(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus value) {
        if (ephemeralContainerStatusesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEphemeralContainerStatusesIsMutable();
          ephemeralContainerStatuses_.add(value);
          onChanged();
        } else {
          ephemeralContainerStatusesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Status for any ephemeral containers that have run in this pod.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
       */
      public Builder addEphemeralContainerStatuses(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus value) {
        if (ephemeralContainerStatusesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEphemeralContainerStatusesIsMutable();
          ephemeralContainerStatuses_.add(index, value);
          onChanged();
        } else {
          ephemeralContainerStatusesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Status for any ephemeral containers that have run in this pod.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
       */
      public Builder addEphemeralContainerStatuses(
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder builderForValue) {
        if (ephemeralContainerStatusesBuilder_ == null) {
          ensureEphemeralContainerStatusesIsMutable();
          ephemeralContainerStatuses_.add(builderForValue.build());
          onChanged();
        } else {
          ephemeralContainerStatusesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Status for any ephemeral containers that have run in this pod.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
       */
      public Builder addEphemeralContainerStatuses(
          int index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder builderForValue) {
        if (ephemeralContainerStatusesBuilder_ == null) {
          ensureEphemeralContainerStatusesIsMutable();
          ephemeralContainerStatuses_.add(index, builderForValue.build());
          onChanged();
        } else {
          ephemeralContainerStatusesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Status for any ephemeral containers that have run in this pod.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
       */
      public Builder addAllEphemeralContainerStatuses(
          java.lang.Iterable<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus> values) {
        if (ephemeralContainerStatusesBuilder_ == null) {
          ensureEphemeralContainerStatusesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, ephemeralContainerStatuses_);
          onChanged();
        } else {
          ephemeralContainerStatusesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Status for any ephemeral containers that have run in this pod.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
       */
      public Builder clearEphemeralContainerStatuses() {
        if (ephemeralContainerStatusesBuilder_ == null) {
          ephemeralContainerStatuses_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00001000);
          onChanged();
        } else {
          ephemeralContainerStatusesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Status for any ephemeral containers that have run in this pod.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
       */
      public Builder removeEphemeralContainerStatuses(int index) {
        if (ephemeralContainerStatusesBuilder_ == null) {
          ensureEphemeralContainerStatusesIsMutable();
          ephemeralContainerStatuses_.remove(index);
          onChanged();
        } else {
          ephemeralContainerStatusesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Status for any ephemeral containers that have run in this pod.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder getEphemeralContainerStatusesBuilder(
          int index) {
        return getEphemeralContainerStatusesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Status for any ephemeral containers that have run in this pod.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder getEphemeralContainerStatusesOrBuilder(
          int index) {
        if (ephemeralContainerStatusesBuilder_ == null) {
          return ephemeralContainerStatuses_.get(index);  } else {
          return ephemeralContainerStatusesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Status for any ephemeral containers that have run in this pod.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
       */
      public java.util.List<? extends ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder> 
           getEphemeralContainerStatusesOrBuilderList() {
        if (ephemeralContainerStatusesBuilder_ != null) {
          return ephemeralContainerStatusesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(ephemeralContainerStatuses_);
        }
      }
      /**
       * <pre>
       * Status for any ephemeral containers that have run in this pod.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder addEphemeralContainerStatusesBuilder() {
        return getEphemeralContainerStatusesFieldBuilder().addBuilder(
            ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.getDefaultInstance());
      }
      /**
       * <pre>
       * Status for any ephemeral containers that have run in this pod.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
       */
      public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder addEphemeralContainerStatusesBuilder(
          int index) {
        return getEphemeralContainerStatusesFieldBuilder().addBuilder(
            index, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.getDefaultInstance());
      }
      /**
       * <pre>
       * Status for any ephemeral containers that have run in this pod.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .chalk.pubsub.v1.PodStatusPubSub.ContainerStatus ephemeral_container_statuses = 13 [json_name = "ephemeralContainerStatuses"];</code>
       */
      public java.util.List<ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder> 
           getEphemeralContainerStatusesBuilderList() {
        return getEphemeralContainerStatusesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder> 
          getEphemeralContainerStatusesFieldBuilder() {
        if (ephemeralContainerStatusesBuilder_ == null) {
          ephemeralContainerStatusesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatus.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.ContainerStatusOrBuilder>(
                  ephemeralContainerStatuses_,
                  ((bitField0_ & 0x00001000) != 0),
                  getParentForChildren(),
                  isClean());
          ephemeralContainerStatuses_ = null;
        }
        return ephemeralContainerStatusesBuilder_;
      }

      private java.lang.Object resize_ = "";
      /**
       * <pre>
       * Status of resources resize desired for pod's containers.
       * It is empty if no resources resize is pending.
       * Any changes to container resources will automatically set this to "Proposed"
       * +featureGate=InPlacePodVerticalScaling
       * +optional
       * </pre>
       *
       * <code>optional string resize = 14 [json_name = "resize"];</code>
       * @return Whether the resize field is set.
       */
      public boolean hasResize() {
        return ((bitField0_ & 0x00002000) != 0);
      }
      /**
       * <pre>
       * Status of resources resize desired for pod's containers.
       * It is empty if no resources resize is pending.
       * Any changes to container resources will automatically set this to "Proposed"
       * +featureGate=InPlacePodVerticalScaling
       * +optional
       * </pre>
       *
       * <code>optional string resize = 14 [json_name = "resize"];</code>
       * @return The resize.
       */
      public java.lang.String getResize() {
        java.lang.Object ref = resize_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          resize_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Status of resources resize desired for pod's containers.
       * It is empty if no resources resize is pending.
       * Any changes to container resources will automatically set this to "Proposed"
       * +featureGate=InPlacePodVerticalScaling
       * +optional
       * </pre>
       *
       * <code>optional string resize = 14 [json_name = "resize"];</code>
       * @return The bytes for resize.
       */
      public com.google.protobuf.ByteString
          getResizeBytes() {
        java.lang.Object ref = resize_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          resize_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Status of resources resize desired for pod's containers.
       * It is empty if no resources resize is pending.
       * Any changes to container resources will automatically set this to "Proposed"
       * +featureGate=InPlacePodVerticalScaling
       * +optional
       * </pre>
       *
       * <code>optional string resize = 14 [json_name = "resize"];</code>
       * @param value The resize to set.
       * @return This builder for chaining.
       */
      public Builder setResize(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        resize_ = value;
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Status of resources resize desired for pod's containers.
       * It is empty if no resources resize is pending.
       * Any changes to container resources will automatically set this to "Proposed"
       * +featureGate=InPlacePodVerticalScaling
       * +optional
       * </pre>
       *
       * <code>optional string resize = 14 [json_name = "resize"];</code>
       * @return This builder for chaining.
       */
      public Builder clearResize() {
        resize_ = getDefaultInstance().getResize();
        bitField0_ = (bitField0_ & ~0x00002000);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Status of resources resize desired for pod's containers.
       * It is empty if no resources resize is pending.
       * Any changes to container resources will automatically set this to "Proposed"
       * +featureGate=InPlacePodVerticalScaling
       * +optional
       * </pre>
       *
       * <code>optional string resize = 14 [json_name = "resize"];</code>
       * @param value The bytes for resize to set.
       * @return This builder for chaining.
       */
      public Builder setResizeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        resize_ = value;
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chalk.pubsub.v1.PodStatusPubSub.PodStatus)
    }

    // @@protoc_insertion_point(class_scope:chalk.pubsub.v1.PodStatusPubSub.PodStatus)
    private static final ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus();
    }

    public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<PodStatus>
        PARSER = new com.google.protobuf.AbstractParser<PodStatus>() {
      @java.lang.Override
      public PodStatus parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<PodStatus> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PodStatus> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private int bitField0_;
  public static final int TEAM_FIELD_NUMBER = 1;
  @SuppressWarnings("serial")
  private volatile java.lang.Object team_ = "";
  /**
   * <pre>
   * The Chalk team name that incurred the usage.
   * </pre>
   *
   * <code>string team = 1 [json_name = "team"];</code>
   * @return The team.
   */
  @java.lang.Override
  public java.lang.String getTeam() {
    java.lang.Object ref = team_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      team_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * The Chalk team name that incurred the usage.
   * </pre>
   *
   * <code>string team = 1 [json_name = "team"];</code>
   * @return The bytes for team.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getTeamBytes() {
    java.lang.Object ref = team_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      team_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int APP_FIELD_NUMBER = 2;
  @SuppressWarnings("serial")
  private volatile java.lang.Object app_ = "";
  /**
   * <code>string app = 2 [json_name = "app"];</code>
   * @return The app.
   */
  @java.lang.Override
  public java.lang.String getApp() {
    java.lang.Object ref = app_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      app_ = s;
      return s;
    }
  }
  /**
   * <code>string app = 2 [json_name = "app"];</code>
   * @return The bytes for app.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getAppBytes() {
    java.lang.Object ref = app_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      app_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int COMPONENT_FIELD_NUMBER = 3;
  @SuppressWarnings("serial")
  private volatile java.lang.Object component_ = "";
  /**
   * <code>string component = 3 [json_name = "component"];</code>
   * @return The component.
   */
  @java.lang.Override
  public java.lang.String getComponent() {
    java.lang.Object ref = component_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      component_ = s;
      return s;
    }
  }
  /**
   * <code>string component = 3 [json_name = "component"];</code>
   * @return The bytes for component.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getComponentBytes() {
    java.lang.Object ref = component_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      component_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int DATADOG_SERVICE_FIELD_NUMBER = 4;
  @SuppressWarnings("serial")
  private volatile java.lang.Object datadogService_ = "";
  /**
   * <code>string datadog_service = 4 [json_name = "datadogService"];</code>
   * @return The datadogService.
   */
  @java.lang.Override
  public java.lang.String getDatadogService() {
    java.lang.Object ref = datadogService_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      datadogService_ = s;
      return s;
    }
  }
  /**
   * <code>string datadog_service = 4 [json_name = "datadogService"];</code>
   * @return The bytes for datadogService.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getDatadogServiceBytes() {
    java.lang.Object ref = datadogService_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      datadogService_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int DATADOG_VERSION_FIELD_NUMBER = 5;
  @SuppressWarnings("serial")
  private volatile java.lang.Object datadogVersion_ = "";
  /**
   * <code>string datadog_version = 5 [json_name = "datadogVersion"];</code>
   * @return The datadogVersion.
   */
  @java.lang.Override
  public java.lang.String getDatadogVersion() {
    java.lang.Object ref = datadogVersion_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      datadogVersion_ = s;
      return s;
    }
  }
  /**
   * <code>string datadog_version = 5 [json_name = "datadogVersion"];</code>
   * @return The bytes for datadogVersion.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getDatadogVersionBytes() {
    java.lang.Object ref = datadogVersion_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      datadogVersion_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int POD_TEMPLATE_HASH_FIELD_NUMBER = 6;
  @SuppressWarnings("serial")
  private volatile java.lang.Object podTemplateHash_ = "";
  /**
   * <code>string pod_template_hash = 6 [json_name = "podTemplateHash"];</code>
   * @return The podTemplateHash.
   */
  @java.lang.Override
  public java.lang.String getPodTemplateHash() {
    java.lang.Object ref = podTemplateHash_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      podTemplateHash_ = s;
      return s;
    }
  }
  /**
   * <code>string pod_template_hash = 6 [json_name = "podTemplateHash"];</code>
   * @return The bytes for podTemplateHash.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getPodTemplateHashBytes() {
    java.lang.Object ref = podTemplateHash_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      podTemplateHash_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int STATUS_FIELD_NUMBER = 7;
  private ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus status_;
  /**
   * <pre>
   * string status = 7;
   * </pre>
   *
   * <code>.chalk.pubsub.v1.PodStatusPubSub.PodStatus status = 7 [json_name = "status"];</code>
   * @return Whether the status field is set.
   */
  @java.lang.Override
  public boolean hasStatus() {
    return ((bitField0_ & 0x00000001) != 0);
  }
  /**
   * <pre>
   * string status = 7;
   * </pre>
   *
   * <code>.chalk.pubsub.v1.PodStatusPubSub.PodStatus status = 7 [json_name = "status"];</code>
   * @return The status.
   */
  @java.lang.Override
  public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus getStatus() {
    return status_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus.getDefaultInstance() : status_;
  }
  /**
   * <pre>
   * string status = 7;
   * </pre>
   *
   * <code>.chalk.pubsub.v1.PodStatusPubSub.PodStatus status = 7 [json_name = "status"];</code>
   */
  @java.lang.Override
  public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatusOrBuilder getStatusOrBuilder() {
    return status_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus.getDefaultInstance() : status_;
  }

  public static final int SPEC_FIELD_NUMBER = 8;
  private ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec spec_;
  /**
   * <code>.chalk.pubsub.v1.PodStatusPubSub.PodSpec spec = 8 [json_name = "spec"];</code>
   * @return Whether the spec field is set.
   */
  @java.lang.Override
  public boolean hasSpec() {
    return ((bitField0_ & 0x00000002) != 0);
  }
  /**
   * <code>.chalk.pubsub.v1.PodStatusPubSub.PodSpec spec = 8 [json_name = "spec"];</code>
   * @return The spec.
   */
  @java.lang.Override
  public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec getSpec() {
    return spec_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec.getDefaultInstance() : spec_;
  }
  /**
   * <code>.chalk.pubsub.v1.PodStatusPubSub.PodSpec spec = 8 [json_name = "spec"];</code>
   */
  @java.lang.Override
  public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpecOrBuilder getSpecOrBuilder() {
    return spec_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec.getDefaultInstance() : spec_;
  }

  public static final int CREATION_TIMESTAMP_FIELD_NUMBER = 18;
  private long creationTimestamp_ = 0L;
  /**
   * <pre>
   * The time that the instance was created.
   * pod.CreationTimestamp.Unix()
   * </pre>
   *
   * <code>int64 creation_timestamp = 18 [json_name = "creationTimestamp", (.gen_bq_schema.bigquery) = { ... }</code>
   * @return The creationTimestamp.
   */
  @java.lang.Override
  public long getCreationTimestamp() {
    return creationTimestamp_;
  }

  public static final int DELETION_TIMESTAMP_FIELD_NUMBER = 19;
  private long deletionTimestamp_ = 0L;
  /**
   * <pre>
   * pod.DeletionTimestamp.Unix()
   * The time that the instance was deleted. May be 0 if the instance is still running.
   * </pre>
   *
   * <code>int64 deletion_timestamp = 19 [json_name = "deletionTimestamp", (.gen_bq_schema.bigquery) = { ... }</code>
   * @return The deletionTimestamp.
   */
  @java.lang.Override
  public long getDeletionTimestamp() {
    return deletionTimestamp_;
  }

  public static final int OBSERVED_TIMESTAMP_FIELD_NUMBER = 20;
  private long observedTimestamp_ = 0L;
  /**
   * <pre>
   * The time that we polled the instance for usage.
   * </pre>
   *
   * <code>int64 observed_timestamp = 20 [json_name = "observedTimestamp", (.gen_bq_schema.bigquery) = { ... }</code>
   * @return The observedTimestamp.
   */
  @java.lang.Override
  public long getObservedTimestamp() {
    return observedTimestamp_;
  }

  public static final int LABELS_FIELD_NUMBER = 21;
  private static final class LabelsDefaultEntryHolder {
    static final com.google.protobuf.MapEntry<
        java.lang.String, java.lang.String> defaultEntry =
            com.google.protobuf.MapEntry
            .<java.lang.String, java.lang.String>newDefaultInstance(
                ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_LabelsEntry_descriptor, 
                com.google.protobuf.WireFormat.FieldType.STRING,
                "",
                com.google.protobuf.WireFormat.FieldType.STRING,
                "");
  }
  @SuppressWarnings("serial")
  private com.google.protobuf.MapField<
      java.lang.String, java.lang.String> labels_;
  private com.google.protobuf.MapField<java.lang.String, java.lang.String>
  internalGetLabels() {
    if (labels_ == null) {
      return com.google.protobuf.MapField.emptyMapField(
          LabelsDefaultEntryHolder.defaultEntry);
    }
    return labels_;
  }
  public int getLabelsCount() {
    return internalGetLabels().getMap().size();
  }
  /**
   * <pre>
   * pod.Labels
   * </pre>
   *
   * <code>map&lt;string, string&gt; labels = 21 [json_name = "labels"];</code>
   */
  @java.lang.Override
  public boolean containsLabels(
      java.lang.String key) {
    if (key == null) { throw new NullPointerException("map key"); }
    return internalGetLabels().getMap().containsKey(key);
  }
  /**
   * Use {@link #getLabelsMap()} instead.
   */
  @java.lang.Override
  @java.lang.Deprecated
  public java.util.Map<java.lang.String, java.lang.String> getLabels() {
    return getLabelsMap();
  }
  /**
   * <pre>
   * pod.Labels
   * </pre>
   *
   * <code>map&lt;string, string&gt; labels = 21 [json_name = "labels"];</code>
   */
  @java.lang.Override
  public java.util.Map<java.lang.String, java.lang.String> getLabelsMap() {
    return internalGetLabels().getMap();
  }
  /**
   * <pre>
   * pod.Labels
   * </pre>
   *
   * <code>map&lt;string, string&gt; labels = 21 [json_name = "labels"];</code>
   */
  @java.lang.Override
  public /* nullable */
java.lang.String getLabelsOrDefault(
      java.lang.String key,
      /* nullable */
java.lang.String defaultValue) {
    if (key == null) { throw new NullPointerException("map key"); }
    java.util.Map<java.lang.String, java.lang.String> map =
        internalGetLabels().getMap();
    return map.containsKey(key) ? map.get(key) : defaultValue;
  }
  /**
   * <pre>
   * pod.Labels
   * </pre>
   *
   * <code>map&lt;string, string&gt; labels = 21 [json_name = "labels"];</code>
   */
  @java.lang.Override
  public java.lang.String getLabelsOrThrow(
      java.lang.String key) {
    if (key == null) { throw new NullPointerException("map key"); }
    java.util.Map<java.lang.String, java.lang.String> map =
        internalGetLabels().getMap();
    if (!map.containsKey(key)) {
      throw new java.lang.IllegalArgumentException();
    }
    return map.get(key);
  }

  public static final int ANNOTATIONS_FIELD_NUMBER = 22;
  private static final class AnnotationsDefaultEntryHolder {
    static final com.google.protobuf.MapEntry<
        java.lang.String, java.lang.String> defaultEntry =
            com.google.protobuf.MapEntry
            .<java.lang.String, java.lang.String>newDefaultInstance(
                ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_AnnotationsEntry_descriptor, 
                com.google.protobuf.WireFormat.FieldType.STRING,
                "",
                com.google.protobuf.WireFormat.FieldType.STRING,
                "");
  }
  @SuppressWarnings("serial")
  private com.google.protobuf.MapField<
      java.lang.String, java.lang.String> annotations_;
  private com.google.protobuf.MapField<java.lang.String, java.lang.String>
  internalGetAnnotations() {
    if (annotations_ == null) {
      return com.google.protobuf.MapField.emptyMapField(
          AnnotationsDefaultEntryHolder.defaultEntry);
    }
    return annotations_;
  }
  public int getAnnotationsCount() {
    return internalGetAnnotations().getMap().size();
  }
  /**
   * <pre>
   * pod.Annotations
   * </pre>
   *
   * <code>map&lt;string, string&gt; annotations = 22 [json_name = "annotations"];</code>
   */
  @java.lang.Override
  public boolean containsAnnotations(
      java.lang.String key) {
    if (key == null) { throw new NullPointerException("map key"); }
    return internalGetAnnotations().getMap().containsKey(key);
  }
  /**
   * Use {@link #getAnnotationsMap()} instead.
   */
  @java.lang.Override
  @java.lang.Deprecated
  public java.util.Map<java.lang.String, java.lang.String> getAnnotations() {
    return getAnnotationsMap();
  }
  /**
   * <pre>
   * pod.Annotations
   * </pre>
   *
   * <code>map&lt;string, string&gt; annotations = 22 [json_name = "annotations"];</code>
   */
  @java.lang.Override
  public java.util.Map<java.lang.String, java.lang.String> getAnnotationsMap() {
    return internalGetAnnotations().getMap();
  }
  /**
   * <pre>
   * pod.Annotations
   * </pre>
   *
   * <code>map&lt;string, string&gt; annotations = 22 [json_name = "annotations"];</code>
   */
  @java.lang.Override
  public /* nullable */
java.lang.String getAnnotationsOrDefault(
      java.lang.String key,
      /* nullable */
java.lang.String defaultValue) {
    if (key == null) { throw new NullPointerException("map key"); }
    java.util.Map<java.lang.String, java.lang.String> map =
        internalGetAnnotations().getMap();
    return map.containsKey(key) ? map.get(key) : defaultValue;
  }
  /**
   * <pre>
   * pod.Annotations
   * </pre>
   *
   * <code>map&lt;string, string&gt; annotations = 22 [json_name = "annotations"];</code>
   */
  @java.lang.Override
  public java.lang.String getAnnotationsOrThrow(
      java.lang.String key) {
    if (key == null) { throw new NullPointerException("map key"); }
    java.util.Map<java.lang.String, java.lang.String> map =
        internalGetAnnotations().getMap();
    if (!map.containsKey(key)) {
      throw new java.lang.IllegalArgumentException();
    }
    return map.get(key);
  }

  public static final int CLUSTER_FIELD_NUMBER = 23;
  @SuppressWarnings("serial")
  private volatile java.lang.Object cluster_ = "";
  /**
   * <code>string cluster = 23 [json_name = "cluster"];</code>
   * @return The cluster.
   */
  @java.lang.Override
  public java.lang.String getCluster() {
    java.lang.Object ref = cluster_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      cluster_ = s;
      return s;
    }
  }
  /**
   * <code>string cluster = 23 [json_name = "cluster"];</code>
   * @return The bytes for cluster.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getClusterBytes() {
    java.lang.Object ref = cluster_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      cluster_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int UID_FIELD_NUMBER = 24;
  @SuppressWarnings("serial")
  private volatile java.lang.Object uid_ = "";
  /**
   * <pre>
   *  // node.UID
   * </pre>
   *
   * <code>string uid = 24 [json_name = "uid"];</code>
   * @return The uid.
   */
  @java.lang.Override
  public java.lang.String getUid() {
    java.lang.Object ref = uid_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      uid_ = s;
      return s;
    }
  }
  /**
   * <pre>
   *  // node.UID
   * </pre>
   *
   * <code>string uid = 24 [json_name = "uid"];</code>
   * @return The bytes for uid.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getUidBytes() {
    java.lang.Object ref = uid_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      uid_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int NAME_FIELD_NUMBER = 25;
  @SuppressWarnings("serial")
  private volatile java.lang.Object name_ = "";
  /**
   * <pre>
   *  // node.Name
   * </pre>
   *
   * <code>string name = 25 [json_name = "name"];</code>
   * @return The name.
   */
  @java.lang.Override
  public java.lang.String getName() {
    java.lang.Object ref = name_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      name_ = s;
      return s;
    }
  }
  /**
   * <pre>
   *  // node.Name
   * </pre>
   *
   * <code>string name = 25 [json_name = "name"];</code>
   * @return The bytes for name.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getNameBytes() {
    java.lang.Object ref = name_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      name_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int NAMESPACE_FIELD_NUMBER = 26;
  @SuppressWarnings("serial")
  private volatile java.lang.Object namespace_ = "";
  /**
   * <code>string namespace = 26 [json_name = "namespace"];</code>
   * @return The namespace.
   */
  @java.lang.Override
  public java.lang.String getNamespace() {
    java.lang.Object ref = namespace_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      namespace_ = s;
      return s;
    }
  }
  /**
   * <code>string namespace = 26 [json_name = "namespace"];</code>
   * @return The bytes for namespace.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getNamespaceBytes() {
    java.lang.Object ref = namespace_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      namespace_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  private byte memoizedIsInitialized = -1;
  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(team_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 1, team_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(app_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 2, app_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(component_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 3, component_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(datadogService_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 4, datadogService_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(datadogVersion_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 5, datadogVersion_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(podTemplateHash_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 6, podTemplateHash_);
    }
    if (((bitField0_ & 0x00000001) != 0)) {
      output.writeMessage(7, getStatus());
    }
    if (((bitField0_ & 0x00000002) != 0)) {
      output.writeMessage(8, getSpec());
    }
    if (creationTimestamp_ != 0L) {
      output.writeInt64(18, creationTimestamp_);
    }
    if (deletionTimestamp_ != 0L) {
      output.writeInt64(19, deletionTimestamp_);
    }
    if (observedTimestamp_ != 0L) {
      output.writeInt64(20, observedTimestamp_);
    }
    com.google.protobuf.GeneratedMessageV3
      .serializeStringMapTo(
        output,
        internalGetLabels(),
        LabelsDefaultEntryHolder.defaultEntry,
        21);
    com.google.protobuf.GeneratedMessageV3
      .serializeStringMapTo(
        output,
        internalGetAnnotations(),
        AnnotationsDefaultEntryHolder.defaultEntry,
        22);
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(cluster_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 23, cluster_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(uid_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 24, uid_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(name_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 25, name_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(namespace_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 26, namespace_);
    }
    getUnknownFields().writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(team_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, team_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(app_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, app_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(component_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, component_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(datadogService_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, datadogService_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(datadogVersion_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, datadogVersion_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(podTemplateHash_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, podTemplateHash_);
    }
    if (((bitField0_ & 0x00000001) != 0)) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(7, getStatus());
    }
    if (((bitField0_ & 0x00000002) != 0)) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(8, getSpec());
    }
    if (creationTimestamp_ != 0L) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt64Size(18, creationTimestamp_);
    }
    if (deletionTimestamp_ != 0L) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt64Size(19, deletionTimestamp_);
    }
    if (observedTimestamp_ != 0L) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt64Size(20, observedTimestamp_);
    }
    for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
         : internalGetLabels().getMap().entrySet()) {
      com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
      labels__ = LabelsDefaultEntryHolder.defaultEntry.newBuilderForType()
          .setKey(entry.getKey())
          .setValue(entry.getValue())
          .build();
      size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(21, labels__);
    }
    for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
         : internalGetAnnotations().getMap().entrySet()) {
      com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
      annotations__ = AnnotationsDefaultEntryHolder.defaultEntry.newBuilderForType()
          .setKey(entry.getKey())
          .setValue(entry.getValue())
          .build();
      size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(22, annotations__);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(cluster_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(23, cluster_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(uid_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(24, uid_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(name_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(25, name_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(namespace_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(26, namespace_);
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
     return true;
    }
    if (!(obj instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub)) {
      return super.equals(obj);
    }
    ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub other = (ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub) obj;

    if (!getTeam()
        .equals(other.getTeam())) return false;
    if (!getApp()
        .equals(other.getApp())) return false;
    if (!getComponent()
        .equals(other.getComponent())) return false;
    if (!getDatadogService()
        .equals(other.getDatadogService())) return false;
    if (!getDatadogVersion()
        .equals(other.getDatadogVersion())) return false;
    if (!getPodTemplateHash()
        .equals(other.getPodTemplateHash())) return false;
    if (hasStatus() != other.hasStatus()) return false;
    if (hasStatus()) {
      if (!getStatus()
          .equals(other.getStatus())) return false;
    }
    if (hasSpec() != other.hasSpec()) return false;
    if (hasSpec()) {
      if (!getSpec()
          .equals(other.getSpec())) return false;
    }
    if (getCreationTimestamp()
        != other.getCreationTimestamp()) return false;
    if (getDeletionTimestamp()
        != other.getDeletionTimestamp()) return false;
    if (getObservedTimestamp()
        != other.getObservedTimestamp()) return false;
    if (!internalGetLabels().equals(
        other.internalGetLabels())) return false;
    if (!internalGetAnnotations().equals(
        other.internalGetAnnotations())) return false;
    if (!getCluster()
        .equals(other.getCluster())) return false;
    if (!getUid()
        .equals(other.getUid())) return false;
    if (!getName()
        .equals(other.getName())) return false;
    if (!getNamespace()
        .equals(other.getNamespace())) return false;
    if (!getUnknownFields().equals(other.getUnknownFields())) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    hash = (37 * hash) + TEAM_FIELD_NUMBER;
    hash = (53 * hash) + getTeam().hashCode();
    hash = (37 * hash) + APP_FIELD_NUMBER;
    hash = (53 * hash) + getApp().hashCode();
    hash = (37 * hash) + COMPONENT_FIELD_NUMBER;
    hash = (53 * hash) + getComponent().hashCode();
    hash = (37 * hash) + DATADOG_SERVICE_FIELD_NUMBER;
    hash = (53 * hash) + getDatadogService().hashCode();
    hash = (37 * hash) + DATADOG_VERSION_FIELD_NUMBER;
    hash = (53 * hash) + getDatadogVersion().hashCode();
    hash = (37 * hash) + POD_TEMPLATE_HASH_FIELD_NUMBER;
    hash = (53 * hash) + getPodTemplateHash().hashCode();
    if (hasStatus()) {
      hash = (37 * hash) + STATUS_FIELD_NUMBER;
      hash = (53 * hash) + getStatus().hashCode();
    }
    if (hasSpec()) {
      hash = (37 * hash) + SPEC_FIELD_NUMBER;
      hash = (53 * hash) + getSpec().hashCode();
    }
    hash = (37 * hash) + CREATION_TIMESTAMP_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
        getCreationTimestamp());
    hash = (37 * hash) + DELETION_TIMESTAMP_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
        getDeletionTimestamp());
    hash = (37 * hash) + OBSERVED_TIMESTAMP_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
        getObservedTimestamp());
    if (!internalGetLabels().getMap().isEmpty()) {
      hash = (37 * hash) + LABELS_FIELD_NUMBER;
      hash = (53 * hash) + internalGetLabels().hashCode();
    }
    if (!internalGetAnnotations().getMap().isEmpty()) {
      hash = (37 * hash) + ANNOTATIONS_FIELD_NUMBER;
      hash = (53 * hash) + internalGetAnnotations().hashCode();
    }
    hash = (37 * hash) + CLUSTER_FIELD_NUMBER;
    hash = (53 * hash) + getCluster().hashCode();
    hash = (37 * hash) + UID_FIELD_NUMBER;
    hash = (53 * hash) + getUid().hashCode();
    hash = (37 * hash) + NAME_FIELD_NUMBER;
    hash = (53 * hash) + getName().hashCode();
    hash = (37 * hash) + NAMESPACE_FIELD_NUMBER;
    hash = (53 * hash) + getNamespace().hashCode();
    hash = (29 * hash) + getUnknownFields().hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }

  public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input);
  }

  public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
  }
  public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() { return newBuilder(); }
  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(
      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   * <pre>
   * PodStatusPubSub captures the state of a kubernetes pod.
   * </pre>
   *
   * Protobuf type {@code chalk.pubsub.v1.PodStatusPubSub}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
      // @@protoc_insertion_point(builder_implements:chalk.pubsub.v1.PodStatusPubSub)
      ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSubOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
        int number) {
      switch (number) {
        case 21:
          return internalGetLabels();
        case 22:
          return internalGetAnnotations();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapFieldReflectionAccessor internalGetMutableMapFieldReflection(
        int number) {
      switch (number) {
        case 21:
          return internalGetMutableLabels();
        case 22:
          return internalGetMutableAnnotations();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.class, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.Builder.class);
    }

    // Construct using ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }
    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3
              .alwaysUseFieldBuilders) {
        getStatusFieldBuilder();
        getSpecFieldBuilder();
      }
    }
    @java.lang.Override
    public Builder clear() {
      super.clear();
      bitField0_ = 0;
      team_ = "";
      app_ = "";
      component_ = "";
      datadogService_ = "";
      datadogVersion_ = "";
      podTemplateHash_ = "";
      status_ = null;
      if (statusBuilder_ != null) {
        statusBuilder_.dispose();
        statusBuilder_ = null;
      }
      spec_ = null;
      if (specBuilder_ != null) {
        specBuilder_.dispose();
        specBuilder_ = null;
      }
      creationTimestamp_ = 0L;
      deletionTimestamp_ = 0L;
      observedTimestamp_ = 0L;
      internalGetMutableLabels().clear();
      internalGetMutableAnnotations().clear();
      cluster_ = "";
      uid_ = "";
      name_ = "";
      namespace_ = "";
      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor
        getDescriptorForType() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusProto.internal_static_chalk_pubsub_v1_PodStatusPubSub_descriptor;
    }

    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub getDefaultInstanceForType() {
      return ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.getDefaultInstance();
    }

    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub build() {
      ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub buildPartial() {
      ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub result = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub(this);
      if (bitField0_ != 0) { buildPartial0(result); }
      onBuilt();
      return result;
    }

    private void buildPartial0(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub result) {
      int from_bitField0_ = bitField0_;
      if (((from_bitField0_ & 0x00000001) != 0)) {
        result.team_ = team_;
      }
      if (((from_bitField0_ & 0x00000002) != 0)) {
        result.app_ = app_;
      }
      if (((from_bitField0_ & 0x00000004) != 0)) {
        result.component_ = component_;
      }
      if (((from_bitField0_ & 0x00000008) != 0)) {
        result.datadogService_ = datadogService_;
      }
      if (((from_bitField0_ & 0x00000010) != 0)) {
        result.datadogVersion_ = datadogVersion_;
      }
      if (((from_bitField0_ & 0x00000020) != 0)) {
        result.podTemplateHash_ = podTemplateHash_;
      }
      int to_bitField0_ = 0;
      if (((from_bitField0_ & 0x00000040) != 0)) {
        result.status_ = statusBuilder_ == null
            ? status_
            : statusBuilder_.build();
        to_bitField0_ |= 0x00000001;
      }
      if (((from_bitField0_ & 0x00000080) != 0)) {
        result.spec_ = specBuilder_ == null
            ? spec_
            : specBuilder_.build();
        to_bitField0_ |= 0x00000002;
      }
      if (((from_bitField0_ & 0x00000100) != 0)) {
        result.creationTimestamp_ = creationTimestamp_;
      }
      if (((from_bitField0_ & 0x00000200) != 0)) {
        result.deletionTimestamp_ = deletionTimestamp_;
      }
      if (((from_bitField0_ & 0x00000400) != 0)) {
        result.observedTimestamp_ = observedTimestamp_;
      }
      if (((from_bitField0_ & 0x00000800) != 0)) {
        result.labels_ = internalGetLabels();
        result.labels_.makeImmutable();
      }
      if (((from_bitField0_ & 0x00001000) != 0)) {
        result.annotations_ = internalGetAnnotations();
        result.annotations_.makeImmutable();
      }
      if (((from_bitField0_ & 0x00002000) != 0)) {
        result.cluster_ = cluster_;
      }
      if (((from_bitField0_ & 0x00004000) != 0)) {
        result.uid_ = uid_;
      }
      if (((from_bitField0_ & 0x00008000) != 0)) {
        result.name_ = name_;
      }
      if (((from_bitField0_ & 0x00010000) != 0)) {
        result.namespace_ = namespace_;
      }
      result.bitField0_ |= to_bitField0_;
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }
    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.setField(field, value);
    }
    @java.lang.Override
    public Builder clearField(
        com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }
    @java.lang.Override
    public Builder clearOneof(
        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }
    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }
    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }
    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub) {
        return mergeFrom((ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub)other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub other) {
      if (other == ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.getDefaultInstance()) return this;
      if (!other.getTeam().isEmpty()) {
        team_ = other.team_;
        bitField0_ |= 0x00000001;
        onChanged();
      }
      if (!other.getApp().isEmpty()) {
        app_ = other.app_;
        bitField0_ |= 0x00000002;
        onChanged();
      }
      if (!other.getComponent().isEmpty()) {
        component_ = other.component_;
        bitField0_ |= 0x00000004;
        onChanged();
      }
      if (!other.getDatadogService().isEmpty()) {
        datadogService_ = other.datadogService_;
        bitField0_ |= 0x00000008;
        onChanged();
      }
      if (!other.getDatadogVersion().isEmpty()) {
        datadogVersion_ = other.datadogVersion_;
        bitField0_ |= 0x00000010;
        onChanged();
      }
      if (!other.getPodTemplateHash().isEmpty()) {
        podTemplateHash_ = other.podTemplateHash_;
        bitField0_ |= 0x00000020;
        onChanged();
      }
      if (other.hasStatus()) {
        mergeStatus(other.getStatus());
      }
      if (other.hasSpec()) {
        mergeSpec(other.getSpec());
      }
      if (other.getCreationTimestamp() != 0L) {
        setCreationTimestamp(other.getCreationTimestamp());
      }
      if (other.getDeletionTimestamp() != 0L) {
        setDeletionTimestamp(other.getDeletionTimestamp());
      }
      if (other.getObservedTimestamp() != 0L) {
        setObservedTimestamp(other.getObservedTimestamp());
      }
      internalGetMutableLabels().mergeFrom(
          other.internalGetLabels());
      bitField0_ |= 0x00000800;
      internalGetMutableAnnotations().mergeFrom(
          other.internalGetAnnotations());
      bitField0_ |= 0x00001000;
      if (!other.getCluster().isEmpty()) {
        cluster_ = other.cluster_;
        bitField0_ |= 0x00002000;
        onChanged();
      }
      if (!other.getUid().isEmpty()) {
        uid_ = other.uid_;
        bitField0_ |= 0x00004000;
        onChanged();
      }
      if (!other.getName().isEmpty()) {
        name_ = other.name_;
        bitField0_ |= 0x00008000;
        onChanged();
      }
      if (!other.getNamespace().isEmpty()) {
        namespace_ = other.namespace_;
        bitField0_ |= 0x00010000;
        onChanged();
      }
      this.mergeUnknownFields(other.getUnknownFields());
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              team_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00000001;
              break;
            } // case 10
            case 18: {
              app_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00000002;
              break;
            } // case 18
            case 26: {
              component_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00000004;
              break;
            } // case 26
            case 34: {
              datadogService_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00000008;
              break;
            } // case 34
            case 42: {
              datadogVersion_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00000010;
              break;
            } // case 42
            case 50: {
              podTemplateHash_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00000020;
              break;
            } // case 50
            case 58: {
              input.readMessage(
                  getStatusFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00000040;
              break;
            } // case 58
            case 66: {
              input.readMessage(
                  getSpecFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00000080;
              break;
            } // case 66
            case 144: {
              creationTimestamp_ = input.readInt64();
              bitField0_ |= 0x00000100;
              break;
            } // case 144
            case 152: {
              deletionTimestamp_ = input.readInt64();
              bitField0_ |= 0x00000200;
              break;
            } // case 152
            case 160: {
              observedTimestamp_ = input.readInt64();
              bitField0_ |= 0x00000400;
              break;
            } // case 160
            case 170: {
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              labels__ = input.readMessage(
                  LabelsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              internalGetMutableLabels().getMutableMap().put(
                  labels__.getKey(), labels__.getValue());
              bitField0_ |= 0x00000800;
              break;
            } // case 170
            case 178: {
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              annotations__ = input.readMessage(
                  AnnotationsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              internalGetMutableAnnotations().getMutableMap().put(
                  annotations__.getKey(), annotations__.getValue());
              bitField0_ |= 0x00001000;
              break;
            } // case 178
            case 186: {
              cluster_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00002000;
              break;
            } // case 186
            case 194: {
              uid_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00004000;
              break;
            } // case 194
            case 202: {
              name_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00008000;
              break;
            } // case 202
            case 210: {
              namespace_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00010000;
              break;
            } // case 210
            default: {
              if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                done = true; // was an endgroup tag
              }
              break;
            } // default:
          } // switch (tag)
        } // while (!done)
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.unwrapIOException();
      } finally {
        onChanged();
      } // finally
      return this;
    }
    private int bitField0_;

    private java.lang.Object team_ = "";
    /**
     * <pre>
     * The Chalk team name that incurred the usage.
     * </pre>
     *
     * <code>string team = 1 [json_name = "team"];</code>
     * @return The team.
     */
    public java.lang.String getTeam() {
      java.lang.Object ref = team_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        team_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * The Chalk team name that incurred the usage.
     * </pre>
     *
     * <code>string team = 1 [json_name = "team"];</code>
     * @return The bytes for team.
     */
    public com.google.protobuf.ByteString
        getTeamBytes() {
      java.lang.Object ref = team_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        team_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * The Chalk team name that incurred the usage.
     * </pre>
     *
     * <code>string team = 1 [json_name = "team"];</code>
     * @param value The team to set.
     * @return This builder for chaining.
     */
    public Builder setTeam(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      team_ = value;
      bitField0_ |= 0x00000001;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The Chalk team name that incurred the usage.
     * </pre>
     *
     * <code>string team = 1 [json_name = "team"];</code>
     * @return This builder for chaining.
     */
    public Builder clearTeam() {
      team_ = getDefaultInstance().getTeam();
      bitField0_ = (bitField0_ & ~0x00000001);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The Chalk team name that incurred the usage.
     * </pre>
     *
     * <code>string team = 1 [json_name = "team"];</code>
     * @param value The bytes for team to set.
     * @return This builder for chaining.
     */
    public Builder setTeamBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      team_ = value;
      bitField0_ |= 0x00000001;
      onChanged();
      return this;
    }

    private java.lang.Object app_ = "";
    /**
     * <code>string app = 2 [json_name = "app"];</code>
     * @return The app.
     */
    public java.lang.String getApp() {
      java.lang.Object ref = app_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        app_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <code>string app = 2 [json_name = "app"];</code>
     * @return The bytes for app.
     */
    public com.google.protobuf.ByteString
        getAppBytes() {
      java.lang.Object ref = app_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        app_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <code>string app = 2 [json_name = "app"];</code>
     * @param value The app to set.
     * @return This builder for chaining.
     */
    public Builder setApp(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      app_ = value;
      bitField0_ |= 0x00000002;
      onChanged();
      return this;
    }
    /**
     * <code>string app = 2 [json_name = "app"];</code>
     * @return This builder for chaining.
     */
    public Builder clearApp() {
      app_ = getDefaultInstance().getApp();
      bitField0_ = (bitField0_ & ~0x00000002);
      onChanged();
      return this;
    }
    /**
     * <code>string app = 2 [json_name = "app"];</code>
     * @param value The bytes for app to set.
     * @return This builder for chaining.
     */
    public Builder setAppBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      app_ = value;
      bitField0_ |= 0x00000002;
      onChanged();
      return this;
    }

    private java.lang.Object component_ = "";
    /**
     * <code>string component = 3 [json_name = "component"];</code>
     * @return The component.
     */
    public java.lang.String getComponent() {
      java.lang.Object ref = component_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        component_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <code>string component = 3 [json_name = "component"];</code>
     * @return The bytes for component.
     */
    public com.google.protobuf.ByteString
        getComponentBytes() {
      java.lang.Object ref = component_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        component_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <code>string component = 3 [json_name = "component"];</code>
     * @param value The component to set.
     * @return This builder for chaining.
     */
    public Builder setComponent(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      component_ = value;
      bitField0_ |= 0x00000004;
      onChanged();
      return this;
    }
    /**
     * <code>string component = 3 [json_name = "component"];</code>
     * @return This builder for chaining.
     */
    public Builder clearComponent() {
      component_ = getDefaultInstance().getComponent();
      bitField0_ = (bitField0_ & ~0x00000004);
      onChanged();
      return this;
    }
    /**
     * <code>string component = 3 [json_name = "component"];</code>
     * @param value The bytes for component to set.
     * @return This builder for chaining.
     */
    public Builder setComponentBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      component_ = value;
      bitField0_ |= 0x00000004;
      onChanged();
      return this;
    }

    private java.lang.Object datadogService_ = "";
    /**
     * <code>string datadog_service = 4 [json_name = "datadogService"];</code>
     * @return The datadogService.
     */
    public java.lang.String getDatadogService() {
      java.lang.Object ref = datadogService_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        datadogService_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <code>string datadog_service = 4 [json_name = "datadogService"];</code>
     * @return The bytes for datadogService.
     */
    public com.google.protobuf.ByteString
        getDatadogServiceBytes() {
      java.lang.Object ref = datadogService_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        datadogService_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <code>string datadog_service = 4 [json_name = "datadogService"];</code>
     * @param value The datadogService to set.
     * @return This builder for chaining.
     */
    public Builder setDatadogService(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      datadogService_ = value;
      bitField0_ |= 0x00000008;
      onChanged();
      return this;
    }
    /**
     * <code>string datadog_service = 4 [json_name = "datadogService"];</code>
     * @return This builder for chaining.
     */
    public Builder clearDatadogService() {
      datadogService_ = getDefaultInstance().getDatadogService();
      bitField0_ = (bitField0_ & ~0x00000008);
      onChanged();
      return this;
    }
    /**
     * <code>string datadog_service = 4 [json_name = "datadogService"];</code>
     * @param value The bytes for datadogService to set.
     * @return This builder for chaining.
     */
    public Builder setDatadogServiceBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      datadogService_ = value;
      bitField0_ |= 0x00000008;
      onChanged();
      return this;
    }

    private java.lang.Object datadogVersion_ = "";
    /**
     * <code>string datadog_version = 5 [json_name = "datadogVersion"];</code>
     * @return The datadogVersion.
     */
    public java.lang.String getDatadogVersion() {
      java.lang.Object ref = datadogVersion_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        datadogVersion_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <code>string datadog_version = 5 [json_name = "datadogVersion"];</code>
     * @return The bytes for datadogVersion.
     */
    public com.google.protobuf.ByteString
        getDatadogVersionBytes() {
      java.lang.Object ref = datadogVersion_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        datadogVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <code>string datadog_version = 5 [json_name = "datadogVersion"];</code>
     * @param value The datadogVersion to set.
     * @return This builder for chaining.
     */
    public Builder setDatadogVersion(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      datadogVersion_ = value;
      bitField0_ |= 0x00000010;
      onChanged();
      return this;
    }
    /**
     * <code>string datadog_version = 5 [json_name = "datadogVersion"];</code>
     * @return This builder for chaining.
     */
    public Builder clearDatadogVersion() {
      datadogVersion_ = getDefaultInstance().getDatadogVersion();
      bitField0_ = (bitField0_ & ~0x00000010);
      onChanged();
      return this;
    }
    /**
     * <code>string datadog_version = 5 [json_name = "datadogVersion"];</code>
     * @param value The bytes for datadogVersion to set.
     * @return This builder for chaining.
     */
    public Builder setDatadogVersionBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      datadogVersion_ = value;
      bitField0_ |= 0x00000010;
      onChanged();
      return this;
    }

    private java.lang.Object podTemplateHash_ = "";
    /**
     * <code>string pod_template_hash = 6 [json_name = "podTemplateHash"];</code>
     * @return The podTemplateHash.
     */
    public java.lang.String getPodTemplateHash() {
      java.lang.Object ref = podTemplateHash_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        podTemplateHash_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <code>string pod_template_hash = 6 [json_name = "podTemplateHash"];</code>
     * @return The bytes for podTemplateHash.
     */
    public com.google.protobuf.ByteString
        getPodTemplateHashBytes() {
      java.lang.Object ref = podTemplateHash_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        podTemplateHash_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <code>string pod_template_hash = 6 [json_name = "podTemplateHash"];</code>
     * @param value The podTemplateHash to set.
     * @return This builder for chaining.
     */
    public Builder setPodTemplateHash(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      podTemplateHash_ = value;
      bitField0_ |= 0x00000020;
      onChanged();
      return this;
    }
    /**
     * <code>string pod_template_hash = 6 [json_name = "podTemplateHash"];</code>
     * @return This builder for chaining.
     */
    public Builder clearPodTemplateHash() {
      podTemplateHash_ = getDefaultInstance().getPodTemplateHash();
      bitField0_ = (bitField0_ & ~0x00000020);
      onChanged();
      return this;
    }
    /**
     * <code>string pod_template_hash = 6 [json_name = "podTemplateHash"];</code>
     * @param value The bytes for podTemplateHash to set.
     * @return This builder for chaining.
     */
    public Builder setPodTemplateHashBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      podTemplateHash_ = value;
      bitField0_ |= 0x00000020;
      onChanged();
      return this;
    }

    private ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus status_;
    private com.google.protobuf.SingleFieldBuilderV3<
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatusOrBuilder> statusBuilder_;
    /**
     * <pre>
     * string status = 7;
     * </pre>
     *
     * <code>.chalk.pubsub.v1.PodStatusPubSub.PodStatus status = 7 [json_name = "status"];</code>
     * @return Whether the status field is set.
     */
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * string status = 7;
     * </pre>
     *
     * <code>.chalk.pubsub.v1.PodStatusPubSub.PodStatus status = 7 [json_name = "status"];</code>
     * @return The status.
     */
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus getStatus() {
      if (statusBuilder_ == null) {
        return status_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus.getDefaultInstance() : status_;
      } else {
        return statusBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * string status = 7;
     * </pre>
     *
     * <code>.chalk.pubsub.v1.PodStatusPubSub.PodStatus status = 7 [json_name = "status"];</code>
     */
    public Builder setStatus(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus value) {
      if (statusBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        status_ = value;
      } else {
        statusBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000040;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * string status = 7;
     * </pre>
     *
     * <code>.chalk.pubsub.v1.PodStatusPubSub.PodStatus status = 7 [json_name = "status"];</code>
     */
    public Builder setStatus(
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus.Builder builderForValue) {
      if (statusBuilder_ == null) {
        status_ = builderForValue.build();
      } else {
        statusBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000040;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * string status = 7;
     * </pre>
     *
     * <code>.chalk.pubsub.v1.PodStatusPubSub.PodStatus status = 7 [json_name = "status"];</code>
     */
    public Builder mergeStatus(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus value) {
      if (statusBuilder_ == null) {
        if (((bitField0_ & 0x00000040) != 0) &&
          status_ != null &&
          status_ != ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus.getDefaultInstance()) {
          getStatusBuilder().mergeFrom(value);
        } else {
          status_ = value;
        }
      } else {
        statusBuilder_.mergeFrom(value);
      }
      if (status_ != null) {
        bitField0_ |= 0x00000040;
        onChanged();
      }
      return this;
    }
    /**
     * <pre>
     * string status = 7;
     * </pre>
     *
     * <code>.chalk.pubsub.v1.PodStatusPubSub.PodStatus status = 7 [json_name = "status"];</code>
     */
    public Builder clearStatus() {
      bitField0_ = (bitField0_ & ~0x00000040);
      status_ = null;
      if (statusBuilder_ != null) {
        statusBuilder_.dispose();
        statusBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * string status = 7;
     * </pre>
     *
     * <code>.chalk.pubsub.v1.PodStatusPubSub.PodStatus status = 7 [json_name = "status"];</code>
     */
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus.Builder getStatusBuilder() {
      bitField0_ |= 0x00000040;
      onChanged();
      return getStatusFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * string status = 7;
     * </pre>
     *
     * <code>.chalk.pubsub.v1.PodStatusPubSub.PodStatus status = 7 [json_name = "status"];</code>
     */
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatusOrBuilder getStatusOrBuilder() {
      if (statusBuilder_ != null) {
        return statusBuilder_.getMessageOrBuilder();
      } else {
        return status_ == null ?
            ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus.getDefaultInstance() : status_;
      }
    }
    /**
     * <pre>
     * string status = 7;
     * </pre>
     *
     * <code>.chalk.pubsub.v1.PodStatusPubSub.PodStatus status = 7 [json_name = "status"];</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatusOrBuilder> 
        getStatusFieldBuilder() {
      if (statusBuilder_ == null) {
        statusBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatus.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodStatusOrBuilder>(
                getStatus(),
                getParentForChildren(),
                isClean());
        status_ = null;
      }
      return statusBuilder_;
    }

    private ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec spec_;
    private com.google.protobuf.SingleFieldBuilderV3<
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpecOrBuilder> specBuilder_;
    /**
     * <code>.chalk.pubsub.v1.PodStatusPubSub.PodSpec spec = 8 [json_name = "spec"];</code>
     * @return Whether the spec field is set.
     */
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <code>.chalk.pubsub.v1.PodStatusPubSub.PodSpec spec = 8 [json_name = "spec"];</code>
     * @return The spec.
     */
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec getSpec() {
      if (specBuilder_ == null) {
        return spec_ == null ? ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec.getDefaultInstance() : spec_;
      } else {
        return specBuilder_.getMessage();
      }
    }
    /**
     * <code>.chalk.pubsub.v1.PodStatusPubSub.PodSpec spec = 8 [json_name = "spec"];</code>
     */
    public Builder setSpec(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec value) {
      if (specBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        spec_ = value;
      } else {
        specBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000080;
      onChanged();
      return this;
    }
    /**
     * <code>.chalk.pubsub.v1.PodStatusPubSub.PodSpec spec = 8 [json_name = "spec"];</code>
     */
    public Builder setSpec(
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec.Builder builderForValue) {
      if (specBuilder_ == null) {
        spec_ = builderForValue.build();
      } else {
        specBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000080;
      onChanged();
      return this;
    }
    /**
     * <code>.chalk.pubsub.v1.PodStatusPubSub.PodSpec spec = 8 [json_name = "spec"];</code>
     */
    public Builder mergeSpec(ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec value) {
      if (specBuilder_ == null) {
        if (((bitField0_ & 0x00000080) != 0) &&
          spec_ != null &&
          spec_ != ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec.getDefaultInstance()) {
          getSpecBuilder().mergeFrom(value);
        } else {
          spec_ = value;
        }
      } else {
        specBuilder_.mergeFrom(value);
      }
      if (spec_ != null) {
        bitField0_ |= 0x00000080;
        onChanged();
      }
      return this;
    }
    /**
     * <code>.chalk.pubsub.v1.PodStatusPubSub.PodSpec spec = 8 [json_name = "spec"];</code>
     */
    public Builder clearSpec() {
      bitField0_ = (bitField0_ & ~0x00000080);
      spec_ = null;
      if (specBuilder_ != null) {
        specBuilder_.dispose();
        specBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <code>.chalk.pubsub.v1.PodStatusPubSub.PodSpec spec = 8 [json_name = "spec"];</code>
     */
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec.Builder getSpecBuilder() {
      bitField0_ |= 0x00000080;
      onChanged();
      return getSpecFieldBuilder().getBuilder();
    }
    /**
     * <code>.chalk.pubsub.v1.PodStatusPubSub.PodSpec spec = 8 [json_name = "spec"];</code>
     */
    public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpecOrBuilder getSpecOrBuilder() {
      if (specBuilder_ != null) {
        return specBuilder_.getMessageOrBuilder();
      } else {
        return spec_ == null ?
            ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec.getDefaultInstance() : spec_;
      }
    }
    /**
     * <code>.chalk.pubsub.v1.PodStatusPubSub.PodSpec spec = 8 [json_name = "spec"];</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpecOrBuilder> 
        getSpecFieldBuilder() {
      if (specBuilder_ == null) {
        specBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpec.Builder, ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub.PodSpecOrBuilder>(
                getSpec(),
                getParentForChildren(),
                isClean());
        spec_ = null;
      }
      return specBuilder_;
    }

    private long creationTimestamp_ ;
    /**
     * <pre>
     * The time that the instance was created.
     * pod.CreationTimestamp.Unix()
     * </pre>
     *
     * <code>int64 creation_timestamp = 18 [json_name = "creationTimestamp", (.gen_bq_schema.bigquery) = { ... }</code>
     * @return The creationTimestamp.
     */
    @java.lang.Override
    public long getCreationTimestamp() {
      return creationTimestamp_;
    }
    /**
     * <pre>
     * The time that the instance was created.
     * pod.CreationTimestamp.Unix()
     * </pre>
     *
     * <code>int64 creation_timestamp = 18 [json_name = "creationTimestamp", (.gen_bq_schema.bigquery) = { ... }</code>
     * @param value The creationTimestamp to set.
     * @return This builder for chaining.
     */
    public Builder setCreationTimestamp(long value) {

      creationTimestamp_ = value;
      bitField0_ |= 0x00000100;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The time that the instance was created.
     * pod.CreationTimestamp.Unix()
     * </pre>
     *
     * <code>int64 creation_timestamp = 18 [json_name = "creationTimestamp", (.gen_bq_schema.bigquery) = { ... }</code>
     * @return This builder for chaining.
     */
    public Builder clearCreationTimestamp() {
      bitField0_ = (bitField0_ & ~0x00000100);
      creationTimestamp_ = 0L;
      onChanged();
      return this;
    }

    private long deletionTimestamp_ ;
    /**
     * <pre>
     * pod.DeletionTimestamp.Unix()
     * The time that the instance was deleted. May be 0 if the instance is still running.
     * </pre>
     *
     * <code>int64 deletion_timestamp = 19 [json_name = "deletionTimestamp", (.gen_bq_schema.bigquery) = { ... }</code>
     * @return The deletionTimestamp.
     */
    @java.lang.Override
    public long getDeletionTimestamp() {
      return deletionTimestamp_;
    }
    /**
     * <pre>
     * pod.DeletionTimestamp.Unix()
     * The time that the instance was deleted. May be 0 if the instance is still running.
     * </pre>
     *
     * <code>int64 deletion_timestamp = 19 [json_name = "deletionTimestamp", (.gen_bq_schema.bigquery) = { ... }</code>
     * @param value The deletionTimestamp to set.
     * @return This builder for chaining.
     */
    public Builder setDeletionTimestamp(long value) {

      deletionTimestamp_ = value;
      bitField0_ |= 0x00000200;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * pod.DeletionTimestamp.Unix()
     * The time that the instance was deleted. May be 0 if the instance is still running.
     * </pre>
     *
     * <code>int64 deletion_timestamp = 19 [json_name = "deletionTimestamp", (.gen_bq_schema.bigquery) = { ... }</code>
     * @return This builder for chaining.
     */
    public Builder clearDeletionTimestamp() {
      bitField0_ = (bitField0_ & ~0x00000200);
      deletionTimestamp_ = 0L;
      onChanged();
      return this;
    }

    private long observedTimestamp_ ;
    /**
     * <pre>
     * The time that we polled the instance for usage.
     * </pre>
     *
     * <code>int64 observed_timestamp = 20 [json_name = "observedTimestamp", (.gen_bq_schema.bigquery) = { ... }</code>
     * @return The observedTimestamp.
     */
    @java.lang.Override
    public long getObservedTimestamp() {
      return observedTimestamp_;
    }
    /**
     * <pre>
     * The time that we polled the instance for usage.
     * </pre>
     *
     * <code>int64 observed_timestamp = 20 [json_name = "observedTimestamp", (.gen_bq_schema.bigquery) = { ... }</code>
     * @param value The observedTimestamp to set.
     * @return This builder for chaining.
     */
    public Builder setObservedTimestamp(long value) {

      observedTimestamp_ = value;
      bitField0_ |= 0x00000400;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The time that we polled the instance for usage.
     * </pre>
     *
     * <code>int64 observed_timestamp = 20 [json_name = "observedTimestamp", (.gen_bq_schema.bigquery) = { ... }</code>
     * @return This builder for chaining.
     */
    public Builder clearObservedTimestamp() {
      bitField0_ = (bitField0_ & ~0x00000400);
      observedTimestamp_ = 0L;
      onChanged();
      return this;
    }

    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> labels_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
        internalGetLabels() {
      if (labels_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            LabelsDefaultEntryHolder.defaultEntry);
      }
      return labels_;
    }
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
        internalGetMutableLabels() {
      if (labels_ == null) {
        labels_ = com.google.protobuf.MapField.newMapField(
            LabelsDefaultEntryHolder.defaultEntry);
      }
      if (!labels_.isMutable()) {
        labels_ = labels_.copy();
      }
      bitField0_ |= 0x00000800;
      onChanged();
      return labels_;
    }
    public int getLabelsCount() {
      return internalGetLabels().getMap().size();
    }
    /**
     * <pre>
     * pod.Labels
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 21 [json_name = "labels"];</code>
     */
    @java.lang.Override
    public boolean containsLabels(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      return internalGetLabels().getMap().containsKey(key);
    }
    /**
     * Use {@link #getLabelsMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getLabels() {
      return getLabelsMap();
    }
    /**
     * <pre>
     * pod.Labels
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 21 [json_name = "labels"];</code>
     */
    @java.lang.Override
    public java.util.Map<java.lang.String, java.lang.String> getLabelsMap() {
      return internalGetLabels().getMap();
    }
    /**
     * <pre>
     * pod.Labels
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 21 [json_name = "labels"];</code>
     */
    @java.lang.Override
    public /* nullable */
java.lang.String getLabelsOrDefault(
        java.lang.String key,
        /* nullable */
java.lang.String defaultValue) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetLabels().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * pod.Labels
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 21 [json_name = "labels"];</code>
     */
    @java.lang.Override
    public java.lang.String getLabelsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetLabels().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    public Builder clearLabels() {
      bitField0_ = (bitField0_ & ~0x00000800);
      internalGetMutableLabels().getMutableMap()
          .clear();
      return this;
    }
    /**
     * <pre>
     * pod.Labels
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 21 [json_name = "labels"];</code>
     */
    public Builder removeLabels(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      internalGetMutableLabels().getMutableMap()
          .remove(key);
      return this;
    }
    /**
     * Use alternate mutation accessors instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String>
        getMutableLabels() {
      bitField0_ |= 0x00000800;
      return internalGetMutableLabels().getMutableMap();
    }
    /**
     * <pre>
     * pod.Labels
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 21 [json_name = "labels"];</code>
     */
    public Builder putLabels(
        java.lang.String key,
        java.lang.String value) {
      if (key == null) { throw new NullPointerException("map key"); }
      if (value == null) { throw new NullPointerException("map value"); }
      internalGetMutableLabels().getMutableMap()
          .put(key, value);
      bitField0_ |= 0x00000800;
      return this;
    }
    /**
     * <pre>
     * pod.Labels
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 21 [json_name = "labels"];</code>
     */
    public Builder putAllLabels(
        java.util.Map<java.lang.String, java.lang.String> values) {
      internalGetMutableLabels().getMutableMap()
          .putAll(values);
      bitField0_ |= 0x00000800;
      return this;
    }

    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> annotations_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
        internalGetAnnotations() {
      if (annotations_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            AnnotationsDefaultEntryHolder.defaultEntry);
      }
      return annotations_;
    }
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
        internalGetMutableAnnotations() {
      if (annotations_ == null) {
        annotations_ = com.google.protobuf.MapField.newMapField(
            AnnotationsDefaultEntryHolder.defaultEntry);
      }
      if (!annotations_.isMutable()) {
        annotations_ = annotations_.copy();
      }
      bitField0_ |= 0x00001000;
      onChanged();
      return annotations_;
    }
    public int getAnnotationsCount() {
      return internalGetAnnotations().getMap().size();
    }
    /**
     * <pre>
     * pod.Annotations
     * </pre>
     *
     * <code>map&lt;string, string&gt; annotations = 22 [json_name = "annotations"];</code>
     */
    @java.lang.Override
    public boolean containsAnnotations(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      return internalGetAnnotations().getMap().containsKey(key);
    }
    /**
     * Use {@link #getAnnotationsMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getAnnotations() {
      return getAnnotationsMap();
    }
    /**
     * <pre>
     * pod.Annotations
     * </pre>
     *
     * <code>map&lt;string, string&gt; annotations = 22 [json_name = "annotations"];</code>
     */
    @java.lang.Override
    public java.util.Map<java.lang.String, java.lang.String> getAnnotationsMap() {
      return internalGetAnnotations().getMap();
    }
    /**
     * <pre>
     * pod.Annotations
     * </pre>
     *
     * <code>map&lt;string, string&gt; annotations = 22 [json_name = "annotations"];</code>
     */
    @java.lang.Override
    public /* nullable */
java.lang.String getAnnotationsOrDefault(
        java.lang.String key,
        /* nullable */
java.lang.String defaultValue) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetAnnotations().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * pod.Annotations
     * </pre>
     *
     * <code>map&lt;string, string&gt; annotations = 22 [json_name = "annotations"];</code>
     */
    @java.lang.Override
    public java.lang.String getAnnotationsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetAnnotations().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    public Builder clearAnnotations() {
      bitField0_ = (bitField0_ & ~0x00001000);
      internalGetMutableAnnotations().getMutableMap()
          .clear();
      return this;
    }
    /**
     * <pre>
     * pod.Annotations
     * </pre>
     *
     * <code>map&lt;string, string&gt; annotations = 22 [json_name = "annotations"];</code>
     */
    public Builder removeAnnotations(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      internalGetMutableAnnotations().getMutableMap()
          .remove(key);
      return this;
    }
    /**
     * Use alternate mutation accessors instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String>
        getMutableAnnotations() {
      bitField0_ |= 0x00001000;
      return internalGetMutableAnnotations().getMutableMap();
    }
    /**
     * <pre>
     * pod.Annotations
     * </pre>
     *
     * <code>map&lt;string, string&gt; annotations = 22 [json_name = "annotations"];</code>
     */
    public Builder putAnnotations(
        java.lang.String key,
        java.lang.String value) {
      if (key == null) { throw new NullPointerException("map key"); }
      if (value == null) { throw new NullPointerException("map value"); }
      internalGetMutableAnnotations().getMutableMap()
          .put(key, value);
      bitField0_ |= 0x00001000;
      return this;
    }
    /**
     * <pre>
     * pod.Annotations
     * </pre>
     *
     * <code>map&lt;string, string&gt; annotations = 22 [json_name = "annotations"];</code>
     */
    public Builder putAllAnnotations(
        java.util.Map<java.lang.String, java.lang.String> values) {
      internalGetMutableAnnotations().getMutableMap()
          .putAll(values);
      bitField0_ |= 0x00001000;
      return this;
    }

    private java.lang.Object cluster_ = "";
    /**
     * <code>string cluster = 23 [json_name = "cluster"];</code>
     * @return The cluster.
     */
    public java.lang.String getCluster() {
      java.lang.Object ref = cluster_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        cluster_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <code>string cluster = 23 [json_name = "cluster"];</code>
     * @return The bytes for cluster.
     */
    public com.google.protobuf.ByteString
        getClusterBytes() {
      java.lang.Object ref = cluster_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        cluster_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <code>string cluster = 23 [json_name = "cluster"];</code>
     * @param value The cluster to set.
     * @return This builder for chaining.
     */
    public Builder setCluster(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      cluster_ = value;
      bitField0_ |= 0x00002000;
      onChanged();
      return this;
    }
    /**
     * <code>string cluster = 23 [json_name = "cluster"];</code>
     * @return This builder for chaining.
     */
    public Builder clearCluster() {
      cluster_ = getDefaultInstance().getCluster();
      bitField0_ = (bitField0_ & ~0x00002000);
      onChanged();
      return this;
    }
    /**
     * <code>string cluster = 23 [json_name = "cluster"];</code>
     * @param value The bytes for cluster to set.
     * @return This builder for chaining.
     */
    public Builder setClusterBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      cluster_ = value;
      bitField0_ |= 0x00002000;
      onChanged();
      return this;
    }

    private java.lang.Object uid_ = "";
    /**
     * <pre>
     *  // node.UID
     * </pre>
     *
     * <code>string uid = 24 [json_name = "uid"];</code>
     * @return The uid.
     */
    public java.lang.String getUid() {
      java.lang.Object ref = uid_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        uid_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     *  // node.UID
     * </pre>
     *
     * <code>string uid = 24 [json_name = "uid"];</code>
     * @return The bytes for uid.
     */
    public com.google.protobuf.ByteString
        getUidBytes() {
      java.lang.Object ref = uid_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        uid_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     *  // node.UID
     * </pre>
     *
     * <code>string uid = 24 [json_name = "uid"];</code>
     * @param value The uid to set.
     * @return This builder for chaining.
     */
    public Builder setUid(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      uid_ = value;
      bitField0_ |= 0x00004000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     *  // node.UID
     * </pre>
     *
     * <code>string uid = 24 [json_name = "uid"];</code>
     * @return This builder for chaining.
     */
    public Builder clearUid() {
      uid_ = getDefaultInstance().getUid();
      bitField0_ = (bitField0_ & ~0x00004000);
      onChanged();
      return this;
    }
    /**
     * <pre>
     *  // node.UID
     * </pre>
     *
     * <code>string uid = 24 [json_name = "uid"];</code>
     * @param value The bytes for uid to set.
     * @return This builder for chaining.
     */
    public Builder setUidBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      uid_ = value;
      bitField0_ |= 0x00004000;
      onChanged();
      return this;
    }

    private java.lang.Object name_ = "";
    /**
     * <pre>
     *  // node.Name
     * </pre>
     *
     * <code>string name = 25 [json_name = "name"];</code>
     * @return The name.
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     *  // node.Name
     * </pre>
     *
     * <code>string name = 25 [json_name = "name"];</code>
     * @return The bytes for name.
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     *  // node.Name
     * </pre>
     *
     * <code>string name = 25 [json_name = "name"];</code>
     * @param value The name to set.
     * @return This builder for chaining.
     */
    public Builder setName(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      name_ = value;
      bitField0_ |= 0x00008000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     *  // node.Name
     * </pre>
     *
     * <code>string name = 25 [json_name = "name"];</code>
     * @return This builder for chaining.
     */
    public Builder clearName() {
      name_ = getDefaultInstance().getName();
      bitField0_ = (bitField0_ & ~0x00008000);
      onChanged();
      return this;
    }
    /**
     * <pre>
     *  // node.Name
     * </pre>
     *
     * <code>string name = 25 [json_name = "name"];</code>
     * @param value The bytes for name to set.
     * @return This builder for chaining.
     */
    public Builder setNameBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      name_ = value;
      bitField0_ |= 0x00008000;
      onChanged();
      return this;
    }

    private java.lang.Object namespace_ = "";
    /**
     * <code>string namespace = 26 [json_name = "namespace"];</code>
     * @return The namespace.
     */
    public java.lang.String getNamespace() {
      java.lang.Object ref = namespace_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        namespace_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <code>string namespace = 26 [json_name = "namespace"];</code>
     * @return The bytes for namespace.
     */
    public com.google.protobuf.ByteString
        getNamespaceBytes() {
      java.lang.Object ref = namespace_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        namespace_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <code>string namespace = 26 [json_name = "namespace"];</code>
     * @param value The namespace to set.
     * @return This builder for chaining.
     */
    public Builder setNamespace(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      namespace_ = value;
      bitField0_ |= 0x00010000;
      onChanged();
      return this;
    }
    /**
     * <code>string namespace = 26 [json_name = "namespace"];</code>
     * @return This builder for chaining.
     */
    public Builder clearNamespace() {
      namespace_ = getDefaultInstance().getNamespace();
      bitField0_ = (bitField0_ & ~0x00010000);
      onChanged();
      return this;
    }
    /**
     * <code>string namespace = 26 [json_name = "namespace"];</code>
     * @param value The bytes for namespace to set.
     * @return This builder for chaining.
     */
    public Builder setNamespaceBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      namespace_ = value;
      bitField0_ |= 0x00010000;
      onChanged();
      return this;
    }
    @java.lang.Override
    public final Builder setUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }


    // @@protoc_insertion_point(builder_scope:chalk.pubsub.v1.PodStatusPubSub)
  }

  // @@protoc_insertion_point(class_scope:chalk.pubsub.v1.PodStatusPubSub)
  private static final ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub();
  }

  public static ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<PodStatusPubSub>
      PARSER = new com.google.protobuf.AbstractParser<PodStatusPubSub>() {
    @java.lang.Override
    public PodStatusPubSub parsePartialFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      Builder builder = newBuilder();
      try {
        builder.mergeFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(builder.buildPartial());
      } catch (com.google.protobuf.UninitializedMessageException e) {
        throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e)
            .setUnfinishedMessage(builder.buildPartial());
      }
      return builder.buildPartial();
    }
  };

  public static com.google.protobuf.Parser<PodStatusPubSub> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<PodStatusPubSub> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public ai.chalk.protos.chalk.pubsub.v1.PodStatusPubSub getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }

}

