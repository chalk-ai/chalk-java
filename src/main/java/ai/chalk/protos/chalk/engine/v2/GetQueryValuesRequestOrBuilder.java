// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chalk/engine/v2/query_values.proto

// Protobuf Java Version: 3.25.1
package ai.chalk.protos.chalk.engine.v2;

public interface GetQueryValuesRequestOrBuilder extends
    // @@protoc_insertion_point(interface_extends:chalk.engine.v2.GetQueryValuesRequest)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * Forcing the client to specify the table name can be a bit narly. Instead, for use case 1), it can be easier to allow the client to specify the operation id,
   * and the engine can figure out what table to query.
   * </pre>
   *
   * <code>.chalk.engine.v2.OperationIdTableIdentifier operation_id_identifier = 1 [json_name = "operationIdIdentifier"];</code>
   * @return Whether the operationIdIdentifier field is set.
   */
  boolean hasOperationIdIdentifier();
  /**
   * <pre>
   * Forcing the client to specify the table name can be a bit narly. Instead, for use case 1), it can be easier to allow the client to specify the operation id,
   * and the engine can figure out what table to query.
   * </pre>
   *
   * <code>.chalk.engine.v2.OperationIdTableIdentifier operation_id_identifier = 1 [json_name = "operationIdIdentifier"];</code>
   * @return The operationIdIdentifier.
   */
  ai.chalk.protos.chalk.engine.v2.OperationIdTableIdentifier getOperationIdIdentifier();
  /**
   * <pre>
   * Forcing the client to specify the table name can be a bit narly. Instead, for use case 1), it can be easier to allow the client to specify the operation id,
   * and the engine can figure out what table to query.
   * </pre>
   *
   * <code>.chalk.engine.v2.OperationIdTableIdentifier operation_id_identifier = 1 [json_name = "operationIdIdentifier"];</code>
   */
  ai.chalk.protos.chalk.engine.v2.OperationIdTableIdentifierOrBuilder getOperationIdIdentifierOrBuilder();

  /**
   * <pre>
   * For use case 2, you have to specify which table name to look up, if you want to query across multiple queries
   * </pre>
   *
   * <code>.chalk.engine.v2.TableNameTableIdentifier table_name_identifier = 2 [json_name = "tableNameIdentifier"];</code>
   * @return Whether the tableNameIdentifier field is set.
   */
  boolean hasTableNameIdentifier();
  /**
   * <pre>
   * For use case 2, you have to specify which table name to look up, if you want to query across multiple queries
   * </pre>
   *
   * <code>.chalk.engine.v2.TableNameTableIdentifier table_name_identifier = 2 [json_name = "tableNameIdentifier"];</code>
   * @return The tableNameIdentifier.
   */
  ai.chalk.protos.chalk.engine.v2.TableNameTableIdentifier getTableNameIdentifier();
  /**
   * <pre>
   * For use case 2, you have to specify which table name to look up, if you want to query across multiple queries
   * </pre>
   *
   * <code>.chalk.engine.v2.TableNameTableIdentifier table_name_identifier = 2 [json_name = "tableNameIdentifier"];</code>
   */
  ai.chalk.protos.chalk.engine.v2.TableNameTableIdentifierOrBuilder getTableNameIdentifierOrBuilder();

  /**
   * <pre>
   * The query log table is partitioned / sorted by timestamp, so we must provide these
   * for the queries to be efficient, even if we are querying for a single operation id
   * This is always required.
   * If you know the operation id, then its feasible that you know the exact query timestamp, too.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp query_timestamp_lower_bound_inclusive = 3 [json_name = "queryTimestampLowerBoundInclusive"];</code>
   * @return Whether the queryTimestampLowerBoundInclusive field is set.
   */
  boolean hasQueryTimestampLowerBoundInclusive();
  /**
   * <pre>
   * The query log table is partitioned / sorted by timestamp, so we must provide these
   * for the queries to be efficient, even if we are querying for a single operation id
   * This is always required.
   * If you know the operation id, then its feasible that you know the exact query timestamp, too.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp query_timestamp_lower_bound_inclusive = 3 [json_name = "queryTimestampLowerBoundInclusive"];</code>
   * @return The queryTimestampLowerBoundInclusive.
   */
  com.google.protobuf.Timestamp getQueryTimestampLowerBoundInclusive();
  /**
   * <pre>
   * The query log table is partitioned / sorted by timestamp, so we must provide these
   * for the queries to be efficient, even if we are querying for a single operation id
   * This is always required.
   * If you know the operation id, then its feasible that you know the exact query timestamp, too.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp query_timestamp_lower_bound_inclusive = 3 [json_name = "queryTimestampLowerBoundInclusive"];</code>
   */
  com.google.protobuf.TimestampOrBuilder getQueryTimestampLowerBoundInclusiveOrBuilder();

  /**
   * <pre>
   * If the upper bound is ommitted, then the lower bound will be used as an exact (equality) filter
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp query_timestamp_upper_bound_exclusive = 4 [json_name = "queryTimestampUpperBoundExclusive"];</code>
   * @return Whether the queryTimestampUpperBoundExclusive field is set.
   */
  boolean hasQueryTimestampUpperBoundExclusive();
  /**
   * <pre>
   * If the upper bound is ommitted, then the lower bound will be used as an exact (equality) filter
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp query_timestamp_upper_bound_exclusive = 4 [json_name = "queryTimestampUpperBoundExclusive"];</code>
   * @return The queryTimestampUpperBoundExclusive.
   */
  com.google.protobuf.Timestamp getQueryTimestampUpperBoundExclusive();
  /**
   * <pre>
   * If the upper bound is ommitted, then the lower bound will be used as an exact (equality) filter
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp query_timestamp_upper_bound_exclusive = 4 [json_name = "queryTimestampUpperBoundExclusive"];</code>
   */
  com.google.protobuf.TimestampOrBuilder getQueryTimestampUpperBoundExclusiveOrBuilder();

  /**
   * <pre>
   * If you're insterested in a subset of features, specify those here. Other columns won't be selected from the database, which will help reduce query costs.
   * If empty, all features will be returned
   * </pre>
   *
   * <code>repeated string features = 5 [json_name = "features"];</code>
   * @return A list containing the features.
   */
  java.util.List<java.lang.String>
      getFeaturesList();
  /**
   * <pre>
   * If you're insterested in a subset of features, specify those here. Other columns won't be selected from the database, which will help reduce query costs.
   * If empty, all features will be returned
   * </pre>
   *
   * <code>repeated string features = 5 [json_name = "features"];</code>
   * @return The count of features.
   */
  int getFeaturesCount();
  /**
   * <pre>
   * If you're insterested in a subset of features, specify those here. Other columns won't be selected from the database, which will help reduce query costs.
   * If empty, all features will be returned
   * </pre>
   *
   * <code>repeated string features = 5 [json_name = "features"];</code>
   * @param index The index of the element to return.
   * @return The features at the given index.
   */
  java.lang.String getFeatures(int index);
  /**
   * <pre>
   * If you're insterested in a subset of features, specify those here. Other columns won't be selected from the database, which will help reduce query costs.
   * If empty, all features will be returned
   * </pre>
   *
   * <code>repeated string features = 5 [json_name = "features"];</code>
   * @param index The index of the value to return.
   * @return The bytes of the features at the given index.
   */
  com.google.protobuf.ByteString
      getFeaturesBytes(int index);

  /**
   * <pre>
   * The (maximum) page size for results. If zero, then the server picks.
   * </pre>
   *
   * <code>int32 page_size = 7 [json_name = "pageSize"];</code>
   * @return The pageSize.
   */
  int getPageSize();

  /**
   * <pre>
   * When dealing with paginated responses, specify the next token to resume where you left off. The subsequent request must be identicial to the original (except for the value of the next_token)
   * Leave empty if querying for the zeroth page.
   * </pre>
   *
   * <code>string page_token = 8 [json_name = "pageToken"];</code>
   * @return The pageToken.
   */
  java.lang.String getPageToken();
  /**
   * <pre>
   * When dealing with paginated responses, specify the next token to resume where you left off. The subsequent request must be identicial to the original (except for the value of the next_token)
   * Leave empty if querying for the zeroth page.
   * </pre>
   *
   * <code>string page_token = 8 [json_name = "pageToken"];</code>
   * @return The bytes for pageToken.
   */
  com.google.protobuf.ByteString
      getPageTokenBytes();

  ai.chalk.protos.chalk.engine.v2.GetQueryValuesRequest.TableIdentifierCase getTableIdentifierCase();
}
