// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chalk/engine/v2/feature_values_chart.proto

// Protobuf Java Version: 3.25.1
package ai.chalk.protos.chalk.engine.v2;

public interface GetFeatureValuesTimeSeriesChartRequestOrBuilder extends
    // @@protoc_insertion_point(interface_extends:chalk.engine.v2.GetFeatureValuesTimeSeriesChartRequest)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <code>optional string title = 1 [json_name = "title"];</code>
   * @return Whether the title field is set.
   */
  boolean hasTitle();
  /**
   * <code>optional string title = 1 [json_name = "title"];</code>
   * @return The title.
   */
  java.lang.String getTitle();
  /**
   * <code>optional string title = 1 [json_name = "title"];</code>
   * @return The bytes for title.
   */
  com.google.protobuf.ByteString
      getTitleBytes();

  /**
   * <code>repeated .chalk.engine.v2.FeatureValueSeries series = 2 [json_name = "series"];</code>
   */
  java.util.List<ai.chalk.protos.chalk.engine.v2.FeatureValueSeries> 
      getSeriesList();
  /**
   * <code>repeated .chalk.engine.v2.FeatureValueSeries series = 2 [json_name = "series"];</code>
   */
  ai.chalk.protos.chalk.engine.v2.FeatureValueSeries getSeries(int index);
  /**
   * <code>repeated .chalk.engine.v2.FeatureValueSeries series = 2 [json_name = "series"];</code>
   */
  int getSeriesCount();
  /**
   * <code>repeated .chalk.engine.v2.FeatureValueSeries series = 2 [json_name = "series"];</code>
   */
  java.util.List<? extends ai.chalk.protos.chalk.engine.v2.FeatureValueSeriesOrBuilder> 
      getSeriesOrBuilderList();
  /**
   * <code>repeated .chalk.engine.v2.FeatureValueSeries series = 2 [json_name = "series"];</code>
   */
  ai.chalk.protos.chalk.engine.v2.FeatureValueSeriesOrBuilder getSeriesOrBuilder(
      int index);

  /**
   * <pre>
   * The size of each time bucket + how far apart time points are in the chart
   * Ideally a divisor of the total window between end and start ms
   * If not, the bucket aligned with end_timestamp_exclusive will be of size total_window % window_period
   * For JSON format, this is a string `${duration_in_seconds}s`
   * </pre>
   *
   * <code>.google.protobuf.Duration window_period = 3 [json_name = "windowPeriod"];</code>
   * @return Whether the windowPeriod field is set.
   */
  boolean hasWindowPeriod();
  /**
   * <pre>
   * The size of each time bucket + how far apart time points are in the chart
   * Ideally a divisor of the total window between end and start ms
   * If not, the bucket aligned with end_timestamp_exclusive will be of size total_window % window_period
   * For JSON format, this is a string `${duration_in_seconds}s`
   * </pre>
   *
   * <code>.google.protobuf.Duration window_period = 3 [json_name = "windowPeriod"];</code>
   * @return The windowPeriod.
   */
  com.google.protobuf.Duration getWindowPeriod();
  /**
   * <pre>
   * The size of each time bucket + how far apart time points are in the chart
   * Ideally a divisor of the total window between end and start ms
   * If not, the bucket aligned with end_timestamp_exclusive will be of size total_window % window_period
   * For JSON format, this is a string `${duration_in_seconds}s`
   * </pre>
   *
   * <code>.google.protobuf.Duration window_period = 3 [json_name = "windowPeriod"];</code>
   */
  com.google.protobuf.DurationOrBuilder getWindowPeriodOrBuilder();

  /**
   * <code>.google.protobuf.Timestamp start_timestamp_inclusive = 4 [json_name = "startTimestampInclusive"];</code>
   * @return Whether the startTimestampInclusive field is set.
   */
  boolean hasStartTimestampInclusive();
  /**
   * <code>.google.protobuf.Timestamp start_timestamp_inclusive = 4 [json_name = "startTimestampInclusive"];</code>
   * @return The startTimestampInclusive.
   */
  com.google.protobuf.Timestamp getStartTimestampInclusive();
  /**
   * <code>.google.protobuf.Timestamp start_timestamp_inclusive = 4 [json_name = "startTimestampInclusive"];</code>
   */
  com.google.protobuf.TimestampOrBuilder getStartTimestampInclusiveOrBuilder();

  /**
   * <pre>
   * If not provided, will assume current time is the ending time
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp end_timestamp_exclusive = 5 [json_name = "endTimestampExclusive"];</code>
   * @return Whether the endTimestampExclusive field is set.
   */
  boolean hasEndTimestampExclusive();
  /**
   * <pre>
   * If not provided, will assume current time is the ending time
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp end_timestamp_exclusive = 5 [json_name = "endTimestampExclusive"];</code>
   * @return The endTimestampExclusive.
   */
  com.google.protobuf.Timestamp getEndTimestampExclusive();
  /**
   * <pre>
   * If not provided, will assume current time is the ending time
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp end_timestamp_exclusive = 5 [json_name = "endTimestampExclusive"];</code>
   */
  com.google.protobuf.TimestampOrBuilder getEndTimestampExclusiveOrBuilder();

  /**
   * <pre>
   * The dimension to use as the time series axis. Defaults to inserted_at if not specified
   * </pre>
   *
   * <code>optional .chalk.engine.v2.FeatureValueTimeSeries time_series = 6 [json_name = "timeSeries"];</code>
   * @return Whether the timeSeries field is set.
   */
  boolean hasTimeSeries();
  /**
   * <pre>
   * The dimension to use as the time series axis. Defaults to inserted_at if not specified
   * </pre>
   *
   * <code>optional .chalk.engine.v2.FeatureValueTimeSeries time_series = 6 [json_name = "timeSeries"];</code>
   * @return The enum numeric value on the wire for timeSeries.
   */
  int getTimeSeriesValue();
  /**
   * <pre>
   * The dimension to use as the time series axis. Defaults to inserted_at if not specified
   * </pre>
   *
   * <code>optional .chalk.engine.v2.FeatureValueTimeSeries time_series = 6 [json_name = "timeSeries"];</code>
   * @return The timeSeries.
   */
  ai.chalk.protos.chalk.engine.v2.FeatureValueTimeSeries getTimeSeries();

  /**
   * <pre>
   * The group bys to apply to this chart. Multiple group bys may produce high #'s of axes.
   * </pre>
   *
   * <code>repeated .chalk.engine.v2.FeatureValueGroupBy group_by = 7 [json_name = "groupBy"];</code>
   * @return A list containing the groupBy.
   */
  java.util.List<ai.chalk.protos.chalk.engine.v2.FeatureValueGroupBy> getGroupByList();
  /**
   * <pre>
   * The group bys to apply to this chart. Multiple group bys may produce high #'s of axes.
   * </pre>
   *
   * <code>repeated .chalk.engine.v2.FeatureValueGroupBy group_by = 7 [json_name = "groupBy"];</code>
   * @return The count of groupBy.
   */
  int getGroupByCount();
  /**
   * <pre>
   * The group bys to apply to this chart. Multiple group bys may produce high #'s of axes.
   * </pre>
   *
   * <code>repeated .chalk.engine.v2.FeatureValueGroupBy group_by = 7 [json_name = "groupBy"];</code>
   * @param index The index of the element to return.
   * @return The groupBy at the given index.
   */
  ai.chalk.protos.chalk.engine.v2.FeatureValueGroupBy getGroupBy(int index);
  /**
   * <pre>
   * The group bys to apply to this chart. Multiple group bys may produce high #'s of axes.
   * </pre>
   *
   * <code>repeated .chalk.engine.v2.FeatureValueGroupBy group_by = 7 [json_name = "groupBy"];</code>
   * @return A list containing the enum numeric values on the wire for groupBy.
   */
  java.util.List<java.lang.Integer>
  getGroupByValueList();
  /**
   * <pre>
   * The group bys to apply to this chart. Multiple group bys may produce high #'s of axes.
   * </pre>
   *
   * <code>repeated .chalk.engine.v2.FeatureValueGroupBy group_by = 7 [json_name = "groupBy"];</code>
   * @param index The index of the value to return.
   * @return The enum numeric value on the wire of groupBy at the given index.
   */
  int getGroupByValue(int index);

  /**
   * <pre>
   * The maximum number of series produced by the group by.
   * Important because some group bys are high cardinality (ex. value)
   * </pre>
   *
   * <code>optional int32 group_by_series_limit = 8 [json_name = "groupBySeriesLimit"];</code>
   * @return Whether the groupBySeriesLimit field is set.
   */
  boolean hasGroupBySeriesLimit();
  /**
   * <pre>
   * The maximum number of series produced by the group by.
   * Important because some group bys are high cardinality (ex. value)
   * </pre>
   *
   * <code>optional int32 group_by_series_limit = 8 [json_name = "groupBySeriesLimit"];</code>
   * @return The groupBySeriesLimit.
   */
  int getGroupBySeriesLimit();
}
