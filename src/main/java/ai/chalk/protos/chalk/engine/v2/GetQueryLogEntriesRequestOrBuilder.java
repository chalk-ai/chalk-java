// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chalk/engine/v2/query_log.proto

// Protobuf Java Version: 3.25.1
package ai.chalk.protos.chalk.engine.v2;

public interface GetQueryLogEntriesRequestOrBuilder extends
    // @@protoc_insertion_point(interface_extends:chalk.engine.v2.GetQueryLogEntriesRequest)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * The query log table is partitioned / sorted by timestamp, so we must provide these
   * for the queries to be efficient, even if we are querying for a single operation id
   * </pre>
   *
   * <code>.google.protobuf.Timestamp query_timestamp_lower_bound_inclusive = 1 [json_name = "queryTimestampLowerBoundInclusive"];</code>
   * @return Whether the queryTimestampLowerBoundInclusive field is set.
   */
  boolean hasQueryTimestampLowerBoundInclusive();
  /**
   * <pre>
   * The query log table is partitioned / sorted by timestamp, so we must provide these
   * for the queries to be efficient, even if we are querying for a single operation id
   * </pre>
   *
   * <code>.google.protobuf.Timestamp query_timestamp_lower_bound_inclusive = 1 [json_name = "queryTimestampLowerBoundInclusive"];</code>
   * @return The queryTimestampLowerBoundInclusive.
   */
  com.google.protobuf.Timestamp getQueryTimestampLowerBoundInclusive();
  /**
   * <pre>
   * The query log table is partitioned / sorted by timestamp, so we must provide these
   * for the queries to be efficient, even if we are querying for a single operation id
   * </pre>
   *
   * <code>.google.protobuf.Timestamp query_timestamp_lower_bound_inclusive = 1 [json_name = "queryTimestampLowerBoundInclusive"];</code>
   */
  com.google.protobuf.TimestampOrBuilder getQueryTimestampLowerBoundInclusiveOrBuilder();

  /**
   * <pre>
   * If the upper bound is omitted, then the lower bound will be used as an "equality" filter
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp query_timestamp_upper_bound_exclusive = 2 [json_name = "queryTimestampUpperBoundExclusive"];</code>
   * @return Whether the queryTimestampUpperBoundExclusive field is set.
   */
  boolean hasQueryTimestampUpperBoundExclusive();
  /**
   * <pre>
   * If the upper bound is omitted, then the lower bound will be used as an "equality" filter
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp query_timestamp_upper_bound_exclusive = 2 [json_name = "queryTimestampUpperBoundExclusive"];</code>
   * @return The queryTimestampUpperBoundExclusive.
   */
  com.google.protobuf.Timestamp getQueryTimestampUpperBoundExclusive();
  /**
   * <pre>
   * If the upper bound is omitted, then the lower bound will be used as an "equality" filter
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp query_timestamp_upper_bound_exclusive = 2 [json_name = "queryTimestampUpperBoundExclusive"];</code>
   */
  com.google.protobuf.TimestampOrBuilder getQueryTimestampUpperBoundExclusiveOrBuilder();

  /**
   * <pre>
   * Any filters for searching the query log. See the QueryLogFilters message above
   * </pre>
   *
   * <code>.chalk.engine.v2.QueryLogFilters filters = 3 [json_name = "filters"];</code>
   * @return Whether the filters field is set.
   */
  boolean hasFilters();
  /**
   * <pre>
   * Any filters for searching the query log. See the QueryLogFilters message above
   * </pre>
   *
   * <code>.chalk.engine.v2.QueryLogFilters filters = 3 [json_name = "filters"];</code>
   * @return The filters.
   */
  ai.chalk.protos.chalk.engine.v2.QueryLogFilters getFilters();
  /**
   * <pre>
   * Any filters for searching the query log. See the QueryLogFilters message above
   * </pre>
   *
   * <code>.chalk.engine.v2.QueryLogFilters filters = 3 [json_name = "filters"];</code>
   */
  ai.chalk.protos.chalk.engine.v2.QueryLogFiltersOrBuilder getFiltersOrBuilder();

  /**
   * <pre>
   * The (maximum) page size. If zero, the server gets to choose.
   * </pre>
   *
   * <code>int32 page_size = 4 [json_name = "pageSize"];</code>
   * @return The pageSize.
   */
  int getPageSize();

  /**
   * <pre>
   * When dealing with paginated responses, the next token can be provided to get the next page of responses
   * The query parameters above must be exactly the same when using a next token
   * This is opaque to the clients, but in practice, it is an encoding of the GetQueryLogEntriesPageToken
   * </pre>
   *
   * <code>string page_token = 5 [json_name = "pageToken"];</code>
   * @return The pageToken.
   */
  java.lang.String getPageToken();
  /**
   * <pre>
   * When dealing with paginated responses, the next token can be provided to get the next page of responses
   * The query parameters above must be exactly the same when using a next token
   * This is opaque to the clients, but in practice, it is an encoding of the GetQueryLogEntriesPageToken
   * </pre>
   *
   * <code>string page_token = 5 [json_name = "pageToken"];</code>
   * @return The bytes for pageToken.
   */
  com.google.protobuf.ByteString
      getPageTokenBytes();
}
